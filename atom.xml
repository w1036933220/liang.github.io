<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Liang的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liang5757.github.io/"/>
  <updated>2021-01-03T16:39:13.316Z</updated>
  <id>https://liang5757.github.io/</id>
  
  <author>
    <name>Liang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode239. 滑动窗口最大值</title>
    <link href="https://liang5757.github.io/2021/01/04/Leetcode/Leetcode239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>https://liang5757.github.io/2021/01/04/Leetcode/Leetcode239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</id>
    <published>2021-01-03T16:25:15.000Z</published>
    <updated>2021-01-03T16:39:13.316Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>主要是记录一下分块做法，没想懂为什么比双向单调队列快，想懂了回来补充</p></blockquote><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1], k &#x3D; 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,-1], k &#x3D; 1</span><br><span class="line">输出：[1,-1]</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [9,11], k &#x3D; 2</span><br><span class="line">输出：[11]</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [4,-2], k &#x3D; 2</span><br><span class="line">输出：[4]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>1 &lt;= k &lt;= nums.length</code></li></ul><h2 id="题解一：双端单调队列"><a href="#题解一：双端单调队列" class="headerlink" title="题解一：双端单调队列"></a>题解一：双端单调队列</h2><p>维护一个双端单调队列，队尾存最大值的索引，如果当前遍历的数比队尾大，则一直弹出直到队列重新满足单调队列的性质，则<strong>滑动窗口的最大值为队尾元素</strong>，然后因为需要的只是当前窗口的最大值，所以每次循环需要判断队头是不是在当前窗口上，如果不是则弹出队头</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSlidingWindow = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span> nums;</span><br><span class="line">    <span class="comment">// 双向队列 保存当前窗口最大值的数组位置 保证队列中数组位置的数值按从大到小排序</span></span><br><span class="line">    <span class="keyword">let</span> queue = [];</span><br><span class="line">    <span class="comment">// 结果数组</span></span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="comment">// 遍历nums数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="comment">// 保证从大到小 如果前面数小则需要依次弹出，直至满足要求</span></span><br><span class="line">        <span class="keyword">while</span>(queue.length !== <span class="number">0</span> &amp;&amp; nums[queue[queue.length - <span class="number">1</span>]] &lt;= nums[i])&#123;</span><br><span class="line">            queue.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加当前值对应的数组下标</span></span><br><span class="line">        queue.push(i);</span><br><span class="line">        <span class="comment">// 判断当前队列中队首的值是否有效</span></span><br><span class="line">        <span class="keyword">if</span>(queue[<span class="number">0</span>] &lt;= i - k)&#123;</span><br><span class="line">            queue.shift();   </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 当窗口长度为k时 保存当前窗口中最大值</span></span><br><span class="line">        <span class="keyword">if</span>(i + <span class="number">1</span> &gt;= k)&#123;</span><br><span class="line">            result[i+<span class="number">1</span>-k] = nums[queue[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="/2021/01/04/Leetcode/Leetcode239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/image-20210103235509444.png" alt="image-20210103235509444"></p><h2 id="题解二：优先队列"><a href="#题解二：优先队列" class="headerlink" title="题解二：优先队列"></a>题解二：优先队列</h2><p>和单调队列基本一个道理，不过键是索引，值是映射到正向区间的nums[i]，优先队列的队头是最大值，当最大值的索引不属于当前的滑动窗口时，则出队。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSlidingWindow = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> q = <span class="keyword">new</span> MaxPriorityQueue, r = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(nums.length - k + <span class="number">1</span>), i = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (++i &lt; k) q.enqueue(i, nums[i] + <span class="number">10001</span>)</span><br><span class="line">    r[<span class="number">0</span>] = q.front().priority - <span class="number">10001</span>, i--</span><br><span class="line">    <span class="keyword">while</span> (++i &lt; nums.length) &#123;</span><br><span class="line">        q.enqueue(i, nums[i] + <span class="number">10001</span>)</span><br><span class="line">        <span class="keyword">while</span> (q.front().element &lt;= i - k) q.dequeue()</span><br><span class="line">        r[i - k + <span class="number">1</span>] = q.front().priority - <span class="number">10001</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="/2021/01/04/Leetcode/Leetcode239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/image-20210103235832538.png" alt="image-20210103235832538"></p><h2 id="题解三：分块"><a href="#题解三：分块" class="headerlink" title="题解三：分块"></a>题解三：分块</h2><p>将数组分成<code>k</code>块</p><p>指针<code>j</code>→ 统计每块内从<code>块开头</code>到<code>j</code>最大值<br>指针<code>i</code>← 统计每块内从<code>块结尾</code>到<code>i</code>最大值<br>滑动区间[i, i + k - 1]最大值 = <code>某块结尾</code>到<code>i</code>最大值 与 <code>某块开头</code>到<code>i + k - 1</code>最大值 取大</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSlidingWindow = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> n = nums.length, p = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(n), </span><br><span class="line">        s = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(n), r = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(n - k + <span class="number">1</span>), i = n, j = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        p[++j] = j % k ? <span class="built_in">Math</span>.max(p[j - <span class="number">1</span>], nums[j]) : nums[j]</span><br><span class="line">        s[i]   = i % k ? <span class="built_in">Math</span>.max(s[i + <span class="number">1</span>], nums[i]) : nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i++ &lt; n - k) r[i] = <span class="built_in">Math</span>.max(s[i], p[i + k - <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="/2021/01/04/Leetcode/Leetcode239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/1609569283-BTeNfl-image.png" alt="image.png"></p><p>ps：离谱，为什么这个比双端队列要快的</p><p><img src= "/img/loading.gif" data-src="/2021/01/04/Leetcode/Leetcode239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/image-20210104000919976.png" alt="image-20210104000919976"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;主要是记录一下分块做法，没想懂为什么比双向单调队列快，想懂了回来补充&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt;，有一个大小为 &lt;code&gt;k&lt;/code&gt; 的滑动窗口从数组的最左侧移动到数组的最
      
    
    </summary>
    
    
      <category term="算法" scheme="https://liang5757.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="https://liang5757.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>策略模式</title>
    <link href="https://liang5757.github.io/2020/12/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://liang5757.github.io/2020/12/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-12-17T14:21:59.000Z</published>
    <updated>2020-12-17T14:22:36.436Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>定义一系列算法，把他们一个个封装起来，并且使它们互相可替换</p></blockquote><h2 id="1-创建"><a href="#1-创建" class="headerlink" title="1. 创建"></a>1. 创建</h2><h3 id="1-1-利用对象封装实现"><a href="#1-1-利用对象封装实现" class="headerlink" title="1.1 利用对象封装实现"></a>1.1 利用对象封装实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将算法的实现与算法的使用分离，strategies是一个策略类</span></span><br><span class="line"><span class="keyword">let</span> strategies = &#123;</span><br><span class="line">  <span class="string">&quot;boss&quot;</span>: <span class="function"><span class="keyword">function</span> (<span class="params">salary</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">4</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;rookie&quot;</span>: <span class="function"><span class="keyword">function</span> (<span class="params">salary</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">3</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;liang&quot;</span>: <span class="function"><span class="keyword">function</span> (<span class="params">salary</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要调用计算类，只需要提供名字，解决了if else的问题</span></span><br><span class="line"><span class="keyword">let</span> calculateBonus = <span class="function"><span class="keyword">function</span> (<span class="params">level, salary</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> strategies[level](salary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-利用传递函数实现"><a href="#1-2-利用传递函数实现" class="headerlink" title="1.2 利用传递函数实现"></a>1.2 利用传递函数实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">boss</span>(<span class="params">salary</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> salary * <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rookie</span>(<span class="params">salary</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> salary * <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">liang</span> (<span class="params">salary</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> salary * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> calculateBonus2 = <span class="function"><span class="keyword">function</span> (<span class="params">func, salary</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> func(salary);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(calculateBonus2(rookie, <span class="number">10000</span>)); <span class="comment">// 30000</span></span><br></pre></td></tr></table></figure><h2 id="2-优点"><a href="#2-优点" class="headerlink" title="2. 优点"></a>2. 优点</h2><ul><li>有效避免多重条件选择语句</li><li>契合了开放封闭原则，易于扩展</li><li>策略类封装的算法可复用</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《javascript设计模式与开发实践》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;定义一系列算法，把他们一个个封装起来，并且使它们互相可替换&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-创建&quot;&gt;&lt;a href=&quot;#1-创建&quot; class=&quot;headerlink&quot; title=&quot;1. 创建&quot;&gt;&lt;/a&gt;1. 创建&lt;/h2
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://liang5757.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="js" scheme="https://liang5757.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>webstorm识别webpack别名</title>
    <link href="https://liang5757.github.io/2020/12/16/%E7%BC%96%E8%AF%91%E5%99%A8/webstorm%E8%AF%86%E5%88%ABwebpack%E5%88%AB%E5%90%8D/"/>
    <id>https://liang5757.github.io/2020/12/16/%E7%BC%96%E8%AF%91%E5%99%A8/webstorm%E8%AF%86%E5%88%ABwebpack%E5%88%AB%E5%90%8D/</id>
    <published>2020-12-16T13:01:28.000Z</published>
    <updated>2020-12-16T13:16:08.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webstorm识别webpack别名"><a href="#webstorm识别webpack别名" class="headerlink" title="webstorm识别webpack别名"></a>webstorm识别webpack别名</h1><blockquote><p>重装webstorm发现之前配置过的别名识别无了，跳转也跳转不了，在此记录一下</p></blockquote><p>你是否烦恼于设置别名后，webstorm警告并且无法跳转的问题</p><p><img src= "/img/loading.gif" data-src="/2020/12/16/%E7%BC%96%E8%AF%91%E5%99%A8/webstorm%E8%AF%86%E5%88%ABwebpack%E5%88%AB%E5%90%8D/image-20201216210710111.png" alt="image-20201216210710111"></p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>首先创建一个文件webstorm.config.js</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  context: path.resolve(__dirname, <span class="string">&#x27;./&#x27;</span>),</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.vue&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>],</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">&#x27;@&#x27;</span>: path.resolve(<span class="string">&#x27;src&#x27;</span>),</span><br><span class="line">      <span class="string">&#x27;@assets&#x27;</span>: path.resolve(__dirname, <span class="string">&#x27;src/assets&#x27;</span>),</span><br><span class="line">  <span class="string">&quot;@components&quot;</span>: path.resolve(<span class="string">&quot;src/components&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>然后进入webstorm设置</li></ol><p><img src= "/img/loading.gif" data-src="/2020/12/16/%E7%BC%96%E8%AF%91%E5%99%A8/webstorm%E8%AF%86%E5%88%ABwebpack%E5%88%AB%E5%90%8D/image-20201216211532346.png" alt="image-20201216205942930"></p><p>然后我们就可以愉快的进行跳转了</p><p><img src= "/img/loading.gif" data-src="/2020/12/16/%E7%BC%96%E8%AF%91%E5%99%A8/webstorm%E8%AF%86%E5%88%ABwebpack%E5%88%AB%E5%90%8D/image-20201216210918827.png" alt="image-20201216210918827"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;webstorm识别webpack别名&quot;&gt;&lt;a href=&quot;#webstorm识别webpack别名&quot; class=&quot;headerlink&quot; title=&quot;webstorm识别webpack别名&quot;&gt;&lt;/a&gt;webstorm识别webpack别名&lt;/h1&gt;&lt;bloc
      
    
    </summary>
    
    
      <category term="编译器配置" scheme="https://liang5757.github.io/categories/%E7%BC%96%E8%AF%91%E5%99%A8%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="编译器配置" scheme="https://liang5757.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="https://liang5757.github.io/2020/12/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://liang5757.github.io/2020/12/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-12-15T12:29:28.000Z</published>
    <updated>2020-12-15T12:32:22.552Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点<br>比如vuex、window对象、线程池</p></blockquote><h2 id="1-实现单例模式"><a href="#1-实现单例模式" class="headerlink" title="1. 实现单例模式"></a>1. 实现单例模式</h2><h3 id="1-1-基于闭包实现"><a href="#1-1-基于闭包实现" class="headerlink" title="1.1 基于闭包实现"></a>1.1 基于闭包实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Singleton</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton.getInstance = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> Singleton(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = Singleton.getInstance(<span class="string">&#x27;liang1&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> b = Singleton.getInstance(<span class="string">&#x27;liang2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a === b); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="1-2-利用代理模式"><a href="#1-2-利用代理模式" class="headerlink" title="1.2 利用代理模式"></a>1.2 利用代理模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ProxySingleton = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> Singleton(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> ProxySingleton(<span class="string">&#x27;liang1&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> ProxySingleton(<span class="string">&#x27;liang2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(c === d); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>利用代理模式来解耦管理单例的逻辑</p><h3 id="1-3-通用的惰性单例"><a href="#1-3-通用的惰性单例" class="headerlink" title="1.3 通用的惰性单例"></a>1.3 通用的惰性单例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSingle</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result || (result = fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要给<code>getSingle</code>传递一个创建实例的<code>fn</code>就能创建单例模式</p><h2 id="2-弹窗实例"><a href="#2-弹窗实例" class="headerlink" title="2. 弹窗实例"></a>2. 弹窗实例</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>打开弹窗<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 通用的创建惰性单例模式</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">getSingle</span>(<span class="params">fn</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> result;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> result || (result = fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>));</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 创建弹窗并添加到body下，并用getSingle创建单例模式</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> createDialog = getSingle(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    div.className = <span class="string">&quot;message-box&quot;</span>;</span></span><br><span class="line">    div.innerHTML = `</span><br><span class="line"><span class="javascript">      &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;mask&quot;</span>&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="javascript">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;dialog&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;dialog-bd&quot;</span>&gt;这是一个弹窗哦&lt;/div&gt;</span></span><br><span class="line"><span class="javascript">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;dialog-ft&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">          &lt;a href=<span class="string">&quot;javascript:&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;dialog-btn&quot;</span>&gt;确定&lt;/a&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">    `.trim();</span><br><span class="line"><span class="javascript">    div.style.display = <span class="string">&quot;none&quot;</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.appendChild(div);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> div;</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn&quot;</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> dialog = createDialog();</span></span><br><span class="line"><span class="javascript">    dialog.style.display = <span class="string">&quot;block&quot;</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 为弹窗按钮绑定关闭事件</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (event.target.className === <span class="string">&quot;dialog-btn&quot;</span>) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> dialog = createDialog();</span></span><br><span class="line"><span class="javascript">      dialog.style.display = <span class="string">&quot;none&quot;</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>getSingle函数通过变量<code>result</code>保存弹窗实例，如果已经存在则直接返回该实例，否则创建弹窗实例，保证了弹窗的唯一性</p><p><img src= "/img/loading.gif" data-src="/2020/12/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/4du1f-5c1xe-1607154327111.gif" alt="4du1f-5c1xe"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《JavaScript设计模式与开发实战》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;保证一个类仅有一个实例，并提供一个访问它的全局访问点&lt;br&gt;比如vuex、window对象、线程池&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-实现单例模式&quot;&gt;&lt;a href=&quot;#1-实现单例模式&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://liang5757.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="js" scheme="https://liang5757.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Webpack 模块热替换</title>
    <link href="https://liang5757.github.io/2020/12/11/Webpack/Webpack-%E6%A8%A1%E5%9D%97%E7%83%AD%E6%9B%BF%E6%8D%A2/"/>
    <id>https://liang5757.github.io/2020/12/11/Webpack/Webpack-%E6%A8%A1%E5%9D%97%E7%83%AD%E6%9B%BF%E6%8D%A2/</id>
    <published>2020-12-11T15:36:39.000Z</published>
    <updated>2020-12-11T15:38:27.440Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>让代码在网页不刷新的前提下得到最新的改动，这就是Hot Module Replacement，HMR</p></blockquote><h2 id="1-开启HMR"><a href="#1-开启HMR" class="headerlink" title="1. 开启HMR"></a>1. 开启HMR</h2><p>配置文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">    ],</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        hot: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在应用的入口index.js下调用HMR API，这样HMR对于index.js及其依赖的所有模块都会生效</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line"><span class="built_in">module</span>.hot.accept();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h2><blockquote><p>在本地开发环境下，浏览器是我们的客户端，webpack-dev-server（WDS）相当于我们的服务端，核心就是客户端从服务端（WDS）拉取更新后的资源（HMR拉取的不是整个资源文件，而是chunk diff，即chunk需要更新的部分）</p></blockquote><p>实际上WDS与浏览器之间建立了一个<strong>websorket</strong>，当本地资源发生变化时WDS会向浏览器推送更新事件，并带上这次构建的hash，让客户端与上一次资源进行比对可以防止冗余更新的出现。</p><p><img src= "/img/loading.gif" data-src="/2020/12/11/Webpack/Webpack-%E6%A8%A1%E5%9D%97%E7%83%AD%E6%9B%BF%E6%8D%A2/image-20201211231509387.png" alt="image-20201211231509387"></p><p>现在客户端根据hash比对后知道新的构建结构和当前的有了差别，就会向WDS发起一个请求来获取更改文件的列表，通常这个请求的名字为<code>[hash].hot-update.json</code></p><p><img src= "/img/loading.gif" data-src="/2020/12/11/Webpack/Webpack-%E6%A8%A1%E5%9D%97%E7%83%AD%E6%9B%BF%E6%8D%A2/image-20201211232331368.png" alt="image-20201211232331368"></p><p><img src= "/img/loading.gif" data-src="/2020/12/11/Webpack/Webpack-%E6%A8%A1%E5%9D%97%E7%83%AD%E6%9B%BF%E6%8D%A2/image-20201211232346317.png" alt="image-20201211232346317"></p><p>该返回结构告诉客户端，需要更新的chunk为<code>18</code>，版本为（构建hash）2ef4d1d91c537e43ce76。这样客户端就可以再借助这些信息继续向WDS获取该chunk的增量更新。</p><p><img src= "/img/loading.gif" data-src="/2020/12/11/Webpack/Webpack-%E6%A8%A1%E5%9D%97%E7%83%AD%E6%9B%BF%E6%8D%A2/image-20201211232412630.png" alt="image-20201211232412630"></p><p><img src= "/img/loading.gif" data-src="/2020/12/11/Webpack/Webpack-%E6%A8%A1%E5%9D%97%E7%83%AD%E6%9B%BF%E6%8D%A2/image-20201211232443976.png" alt="image-20201211232443976"></p><p>现在客户端已经获取到chunk的更新，现在还有一个问题，客户端获取到这些增量更新之后如何处理，这就不属于webpack的工作了，但是HMR提供了相关的api。官方api文档：<a href="https://www.webpackjs.com/api/hot-module-replacement/">https://www.webpackjs.com/api/hot-module-replacement/</a></p><p>可以看到HMR是使用了<code>webpackHotUpdate</code>来处理的，执行 <code>webpackHotUpdate</code> 时如发现模块代码实现了 HMR 接口，就会执行相应的回调或者方法，从而达到应用更新时，模块可以自行管理自己所需要额外做的工作。</p><p>这里还有一个问题是，webpack 如何保证 HMR 接口中的引用是最新的模块代码？我们看一个简单的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> hello <span class="keyword">from</span> <span class="string">&#x27;./bar&#x27;</span></span><br><span class="line"></span><br><span class="line">hello()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">  <span class="built_in">module</span>.hot.accept(<span class="string">&#x27;./bar&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(&#x27;Accepting the updated bar module!&#x27;)</span></span><br><span class="line">    hello()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码上看，hello 都是同一个，这样的话并没有办法引用最新的模块代码，但是我们看一下上述代码在 webpack 构建后的结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">module</span>.hot.accept(<span class="string">&quot;./src/bar.js&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">__WEBPACK_OUTDATED_DEPENDENCIES__</span>) </span>&#123; </span><br><span class="line">    <span class="comment">/* harmony import */</span> </span><br><span class="line">    __WEBPACK_IMPORTED_MODULE_1__bar__ = __webpack_require__(<span class="string">&quot;./src/bar.js&quot;</span>); </span><br><span class="line">    (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(&#x27;Accepting the updated bar module!&#x27;)</span></span><br><span class="line">      <span class="built_in">Object</span>(__WEBPACK_IMPORTED_MODULE_1__bar__[<span class="string">&quot;default&quot;</span>])()</span><br><span class="line">    &#125;)(__WEBPACK_OUTDATED_DEPENDENCIES__); </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他代码比较杂，我们集中看 <code>module.hot</code> 的处理部分。这里可以发现，我们的 hello 已经重新使用 <code>__webpack_require__</code> 来引用了，所以可以确保它是最新的模块代码。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Webpack实战》<br>掘金小册：《使用 webpack 定制前端开发环境》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;让代码在网页不刷新的前提下得到最新的改动，这就是Hot Module Replacement，HMR&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-开启HMR&quot;&gt;&lt;a href=&quot;#1-开启HMR&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="前端" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Webpack" scheme="https://liang5757.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>Webpack Tree Shaking</title>
    <link href="https://liang5757.github.io/2020/12/11/Webpack/Webpack-Tree-Shaking/"/>
    <id>https://liang5757.github.io/2020/12/11/Webpack/Webpack-Tree-Shaking/</id>
    <published>2020-12-10T17:44:53.000Z</published>
    <updated>2020-12-10T17:53:11.674Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>由Rollup提出，为了消除无用的JavaScript代码而被引入的，对于es模块依赖关系确定的，就可以进行静态分析，CJS不可以</p></blockquote><h2 id="1-作用对象"><a href="#1-作用对象" class="headerlink" title="1. 作用对象"></a>1. 作用对象</h2><ul><li>不会被执行、不可到达的代码</li><li>代码执行的结果不会被用到</li><li>代码只会影响死变量（只写不读）</li></ul><h2 id="2-作用方式"><a href="#2-作用方式" class="headerlink" title="2. 作用方式"></a>2. 作用方式</h2><blockquote><p>tree shaking 只会对满足上述条件的代码进行<strong>注释标记</strong>，由<code>UglifyJSPlugin</code>清除</p></blockquote><p>webpack 负责对代码进行标记，把<code>import</code>&amp;<code>export</code>标记为 3 类：</p><ol><li>所有<code>import</code>标记为<code>/* harmony import */</code></li><li>被使用过的<code>export</code>标记为<code>/* harmony export ([type]) */</code>，其中<code>[type]</code>和 webpack 内部有关，可能是<code>binding</code>, <code>immutable</code>等等。</li><li>没被使用过的<code>export</code>标记为<code>/* unused harmony export [FuncName] */</code>，其中 <code>[FuncName]</code>为<code>export</code>的方法名称</li></ol><h2 id="3-不会清除类和IIFE"><a href="#3-不会清除类和IIFE" class="headerlink" title="3. 不会清除类和IIFE"></a>3. 不会清除类和IIFE</h2><p>下面摘取了rollup核心贡献者的的一些回答：</p><p><img src= "/img/loading.gif" data-src="/2020/12/11/Webpack/Webpack-Tree-Shaking/160bfd6bef36c293" alt="img"></p><ul><li>rollup只处理函数和顶层的import/export变量，不能把没用到的类的方法消除掉</li><li>javascrip<strong>t动态语言的特性使得静态分析比较困难</strong></li><li>下部分的代码就是副作用的一个例子，如果静态分析的时候删除里run或者jump，程序运行时就可能报错，那就本末倒置了，我们的目的是优化，肯定不能影响执行</li></ul><p>下面这篇文章介绍了Babel编译类文件导致副作用，以及UglifyJs贡献者对处理有副作用代码的态度<br><a href="https://juejin.cn/post/6844903549290151949">https://juejin.cn/post/6844903549290151949</a> (你的Tree-Shaking并没什么卵用)</p><h2 id="4-对于IIFE返回的函数，如果未被使用则会清除"><a href="#4-对于IIFE返回的函数，如果未被使用则会清除" class="headerlink" title="4. 对于IIFE返回的函数，如果未被使用则会清除"></a>4. 对于IIFE返回的函数，如果未被使用则会清除</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//App.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; cube &#125; <span class="keyword">from</span> <span class="string">&#x27;./utils.js&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(cube(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//utils.js</span></span><br><span class="line"><span class="keyword">var</span> square = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;square&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSquare</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;getSquare&#x27;</span>);</span><br><span class="line">  square();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">cube</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;cube&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> x * x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">e, t, n</span>) </span>&#123;</span><br><span class="line"><span class="meta">  &quot;use strict&quot;</span>;</span><br><span class="line">  n.r(t);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;square&quot;</span>);  <span class="comment">// square这个IIFE内部的代码还在</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">&quot;cube&quot;</span>), e * e * e  </span><br><span class="line">    <span class="comment">// square这个IIFEreturn的方法因为getSquare未被调用而被删除</span></span><br><span class="line">  &#125;(<span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-Tree-shaking结合第三方包使用"><a href="#5-Tree-shaking结合第三方包使用" class="headerlink" title="5.Tree shaking结合第三方包使用"></a>5.Tree shaking结合第三方包使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//App.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; getLast &#125; <span class="keyword">from</span> <span class="string">&#x27;./utils.js&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(getLast(<span class="string">&#x27;abcdefg&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//utils.js</span></span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span>;  <span class="comment">// 这里的引用方式不同，会造成bundle的不同结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getLast</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;getLast&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> _.last(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br><span class="line">    Asset      Size </span><br><span class="line">bundle.js  <span class="number">70.5</span> KiB</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; last &#125; <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br><span class="line">    Asset      Size</span><br><span class="line">bundle.js  <span class="number">70.5</span> KiB</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> last <span class="keyword">from</span> <span class="string">&#x27;lodash/last&#x27;</span>;   <span class="comment">// 这种引用方式明显降低了打包后的大小</span></span><br><span class="line">    Asset      Size</span><br><span class="line">bundle.js  <span class="number">1.14</span> KiB</span><br></pre></td></tr></table></figure><h2 id="6-tree-shaking结合第三方包使用"><a href="#6-tree-shaking结合第三方包使用" class="headerlink" title="6. tree shaking结合第三方包使用"></a>6. tree shaking结合第三方包使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//App.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; Add &#125; <span class="keyword">from</span> <span class="string">&#x27;./utils&#x27;</span></span><br><span class="line">Add(<span class="number">1</span> + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//utils.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; isArray &#125; <span class="keyword">from</span> <span class="string">&#x27;lodash-es&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">array</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;isArray&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> isArray(array);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Add&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个&#96;array&#96;函数未被使用，但是lodash-es这个包的部分代码还是会被build到bundle.js中</span><br></pre></td></tr></table></figure><p>可以使用这个插件<a href="https://github.com/vincentdchan/webpack-deep-scope-analysis-plugin">webpack-deep-scope-analysis-plugin</a>解决</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844903544756109319#heading-0">https://juejin.cn/post/6844903544756109319#heading-0</a><br><a href="https://juejin.cn/post/6844903774192926728">https://juejin.cn/post/6844903774192926728</a><br><a href="https://juejin.cn/post/6844903687412776974#heading-8">https://juejin.cn/post/6844903687412776974#heading-8</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;由Rollup提出，为了消除无用的JavaScript代码而被引入的，对于es模块依赖关系确定的，就可以进行静态分析，CJS不可以&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-作用对象&quot;&gt;&lt;a href=&quot;#1-作用对象&quot; class=
      
    
    </summary>
    
    
      <category term="前端" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Webpack" scheme="https://liang5757.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>惰性加载函数</title>
    <link href="https://liang5757.github.io/2020/12/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%83%B0%E6%80%A7%E5%8A%A0%E8%BD%BD%E5%87%BD%E6%95%B0/"/>
    <id>https://liang5757.github.io/2020/12/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%83%B0%E6%80%A7%E5%8A%A0%E8%BD%BD%E5%87%BD%E6%95%B0/</id>
    <published>2020-12-10T06:33:02.000Z</published>
    <updated>2020-12-10T07:13:45.991Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>写一个各浏览器兼容事件绑定函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> addEvent = <span class="function"><span class="keyword">function</span> (<span class="params">elem, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">        <span class="keyword">return</span> elem.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.attachEvent) &#123;</span><br><span class="line">        <span class="keyword">return</span> elem.attachEvent(<span class="string">&#x27;on&#x27;</span> + type, handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：每一次调用都必须执行一次if判断</p><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>在该代码被加载时，利用立即执行函数做一次判断，然后返回给<code>addEvent</code>正确的事件绑定函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> addEvent = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">elem, type, handler</span>) </span>&#123;</span><br><span class="line">            elem.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.attachEvent) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">elem, type, handler</span>) </span>&#123;</span><br><span class="line">            elem.attachEvent(<span class="string">&#x27;on&#x27;</span> + type, handler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>缺点：如果<code>addEvent</code>绑定事件函数一直都没有被调用，那么就白白做了一次浏览器嗅探</p><h2 id="方案二：惰性载入函数"><a href="#方案二：惰性载入函数" class="headerlink" title="方案二：惰性载入函数"></a>方案二：惰性载入函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> addEvent = <span class="function"><span class="keyword">function</span>(<span class="params">elem, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">        addEvent = <span class="function"><span class="keyword">function</span> (<span class="params">elem, type, handler</span>) </span>&#123;</span><br><span class="line">            elem.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.attachEvent) &#123;</span><br><span class="line">        addEvent = <span class="function"><span class="keyword">function</span> (<span class="params">elem, type, handler</span>) </span>&#123;</span><br><span class="line">            elem.attachEvent(<span class="string">&#x27;on&#x27;</span> + type, handler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    addEvent(elem, type, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：首次调用较慢</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Javascript设计模式与开发实践》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h2&gt;&lt;p&gt;写一个各浏览器兼容事件绑定函数&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://liang5757.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="js" scheme="https://liang5757.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>webpack loader</title>
    <link href="https://liang5757.github.io/2020/11/27/Webpack/webpack%20loader/"/>
    <id>https://liang5757.github.io/2020/11/27/Webpack/webpack%20loader/</id>
    <published>2020-11-27T14:19:51.000Z</published>
    <updated>2020-11-27T14:26:33.055Z</updated>
    
    <content type="html"><![CDATA[<p>关于loader的作用和配置方法，在 初识webpack 这篇文章中已经讲过，本篇文章会讲常用的一些loader，并自己实现一个loader函数。</p><h2 id="1-转义es6"><a href="#1-转义es6" class="headerlink" title="1. 转义es6"></a>1. 转义es6</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i @babel&#x2F;core babel-loader @babel&#x2F;preset-env -D</span><br></pre></td></tr></table></figure><ul><li>babel-loader：它是使babel与webpack协同工作的模块</li><li>@babel/core：是babel编译器的核心模块</li><li>@babel/preset-env：官方推荐的预置器，可根据用户设置的目标环境自动添加所需的插件和补丁来编译es6代码</li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">    &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">            loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">            <span class="comment">// 配置选项里的presets</span></span><br><span class="line">            <span class="comment">// 包含ES6还有之后的版本和那些仅仅是草案的内容</span></span><br><span class="line">            options: &#123;</span><br><span class="line">                cacheDirectory: <span class="literal">true</span>, <span class="comment">// 启动缓存机制，在重复打包未改变过的模块时防止二次编译，加快打包速度</span></span><br><span class="line">                presets: [<span class="string">&#x27;@babel/preset-env&#x27;</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        include: <span class="regexp">/src/</span>,          <span class="comment">// 只转化src目录下的js</span></span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>  <span class="comment">// 排除掉node_modules，优化打包速度</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="2-转义Ts"><a href="#2-转义Ts" class="headerlink" title="2. 转义Ts"></a>2. 转义Ts</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i ts-loader typescript</span><br></pre></td></tr></table></figure><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">    &#123;</span><br><span class="line">        test: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">        use: <span class="string">&#x27;ts-loader&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>与寻常loader不同的是，ts配置项是在工程目录下的<code>tsconfig.json</code>中</p><h2 id="3-html-loader"><a href="#3-html-loader" class="headerlink" title="3. html-loader"></a>3. html-loader</h2><p>用于将HTML文件转化为字符串并进行格式化，这使得外面可以把一个HTML片段通过js加载进来。</p><h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i html-loader</span><br></pre></td></tr></table></figure><h3 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">    &#123;</span><br><span class="line">        test: <span class="regexp">/\.html$/</span>,</span><br><span class="line">        use: <span class="string">&#x27;html-loader&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="4-file-loader"><a href="#4-file-loader" class="headerlink" title="4. file-loader"></a>4. file-loader</h2><p>用于打包文件类型的资源，并返回其publicPath</p><h3 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i file-loader</span><br></pre></td></tr></table></figure><h3 id="配置-3"><a href="#配置-3" class="headerlink" title="配置"></a>配置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">    &#123;</span><br><span class="line">        test: <span class="regexp">/\.(jpe?g|png|gif)$/</span>,</span><br><span class="line">        use: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="5-url-loader"><a href="#5-url-loader" class="headerlink" title="5. url-loader"></a>5. url-loader</h2><h3 id="安装-4"><a href="#安装-4" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i url-loader</span><br></pre></td></tr></table></figure><h3 id="配置-4"><a href="#配置-4" class="headerlink" title="配置"></a>配置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">    &#123;</span><br><span class="line">        test: <span class="regexp">/\.(jpe?g|png|gif)$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">            loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">                limit: <span class="number">10240</span>, <span class="comment">// 如果小于该配置大小，则返回文件的base64形式</span></span><br><span class="line">                name: <span class="string">&#x27;[name].[ext]&#x27;</span>,</span><br><span class="line">                publicPath: <span class="string">&#x27;./assets-path/&#x27;</span>, <span class="comment">// 会覆盖webpack配置的publicPath</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="6-加载样式"><a href="#6-加载样式" class="headerlink" title="6. 加载样式"></a>6. 加载样式</h2><h3 id="安装-5"><a href="#安装-5" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i style-loader css-loader less-loader -D</span><br></pre></td></tr></table></figure><h3 id="配置-5"><a href="#配置-5" class="headerlink" title="配置"></a>配置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">    &#123;</span><br><span class="line">        test: <span class="regexp">/.less$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">            <span class="string">&#x27;style-loader&#x27;</span>, <span class="comment">// 将样式通过&lt;style&gt;标签插入到head中</span></span><br><span class="line">            <span class="string">&#x27;css-loader&#x27;</span>, <span class="comment">// 用于加载.css文件，并转化成commonjs对象</span></span><br><span class="line">            <span class="string">&#x27;less-loader&#x27;</span> <span class="comment">// 将less转化成css</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="7-自定义loader"><a href="#7-自定义loader" class="headerlink" title="7. 自定义loader"></a>7. 自定义loader</h2><p>我们将实现一个loader，它会为所有JS文件开启严格模式，也就是说它会在文件头部加上如下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;user strict&#x27;</span></span><br></pre></td></tr></table></figure><p>force-strict-loader.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提供一些帮助函数，这里用于获取options中的配置项</span></span><br><span class="line"><span class="keyword">var</span> loaderUtils = <span class="built_in">require</span>(<span class="string">&quot;loader-utils&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> SourceNode = <span class="built_in">require</span>(<span class="string">&#x27;source-map&#x27;</span>).SourceNode;</span><br><span class="line"><span class="keyword">var</span> SourceMapConsumer = <span class="built_in">require</span>(<span class="string">&#x27;source-map&#x27;</span>).SourceMapConsumer;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">content, sourceMap</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> useStrictPrefix = <span class="string">&#x27;\&#x27;use strict\&#x27;;\n\n&#x27;</span>;</span><br><span class="line">    <span class="comment">// 开启缓存，如果文件输入和其依赖没有发生变化时，应该让loader直接使用缓存，提高webpack打包的速度</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.cacheable) &#123;</span><br><span class="line">        <span class="built_in">this</span>.cacheable();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开启source-map可以便于实际开发者在浏览器控制台查看源代码</span></span><br><span class="line">    <span class="comment">// 如果没有处理，最终无法生成正确的map文件，在dev tool中可能看到错乱的源码</span></span><br><span class="line">    <span class="keyword">var</span> options = loaderUtils.getOptions(<span class="built_in">this</span>) || &#123;&#125;;</span><br><span class="line">    <span class="comment">// 只有在从配置中获取sourceMap或者从上一个loader中传递下来才会继续处理</span></span><br><span class="line">    <span class="keyword">if</span> (options.sourceMap &amp;&amp; sourceMap) &#123;</span><br><span class="line">        <span class="keyword">var</span> currentReguest = loaderUtils.getCurrentRequest(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">var</span> node = SourceNode.formStringWithSourceMap(</span><br><span class="line">            content,</span><br><span class="line">            <span class="keyword">new</span> SourceMapConsumer(sourceMap)</span><br><span class="line">        );</span><br><span class="line">        node.prepend(useStrictPrefix);</span><br><span class="line">        <span class="keyword">var</span> result = node.toStringWithSourceMap(&#123; <span class="attr">file</span>: currentReguest&#125;);</span><br><span class="line">        <span class="keyword">var</span> callback = <span class="built_in">this</span>.async();</span><br><span class="line">        callback(<span class="literal">null</span>, result.code, result.map.toJSON());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> useStrictPrefix + content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的插件提供了source-map的配置选项，source-map是一个信息文件，里面储存着位置信息，在debug的时候就会显示原文件的信息和位置，而不是转化后的信息。</p><p>使用方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use: &#123;</span><br><span class="line">    loader: <span class="string">&#x27;force-strict-loader&#x27;</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">        sourceMap: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Webpack实战入门、进阶与调优》<br><a href="https://juejin.cn/post/6844903599080734728#heading-14">https://juejin.cn/post/6844903599080734728#heading-14</a><br><a href="http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html">http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于loader的作用和配置方法，在 初识webpack 这篇文章中已经讲过，本篇文章会讲常用的一些loader，并自己实现一个loader函数。&lt;/p&gt;
&lt;h2 id=&quot;1-转义es6&quot;&gt;&lt;a href=&quot;#1-转义es6&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="前端" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Webpack" scheme="https://liang5757.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack文件指纹</title>
    <link href="https://liang5757.github.io/2020/11/22/Webpack/webpack%E6%96%87%E4%BB%B6%E6%8C%87%E7%BA%B9/"/>
    <id>https://liang5757.github.io/2020/11/22/Webpack/webpack%E6%96%87%E4%BB%B6%E6%8C%87%E7%BA%B9/</id>
    <published>2020-11-22T14:35:32.000Z</published>
    <updated>2020-11-27T14:26:33.251Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>打包后的文件后缀，通常用于做版本管理，文件被修改后打包出来的文件指纹不同，浏览器只会下载这些不同的文件，没被修改的文件从缓存读取，加快浏览速度</p></blockquote><h2 id="1-三种文件指纹的策略"><a href="#1-三种文件指纹的策略" class="headerlink" title="1. 三种文件指纹的策略"></a>1. 三种文件指纹的策略</h2><table><thead><tr><th>文件指纹</th><th>策略</th></tr></thead><tbody><tr><td>hash</td><td>只要有文件被修改，每一次构建过程生成唯一hash，所有文件共用</td></tr><tr><td>chunkhash</td><td>基于chunk内容生成，不同的entry会生成不同的chunkhash值</td></tr><tr><td>contenthash</td><td>根据文件内容来定义hash，文件内容不变，则contenthash不变</td></tr></tbody></table><p>chunkhash的问题：如果在js中引入了style文件，之后只修改了style文件，但打包后js的文件指纹也一起修改了</p><h2 id="2-文件指纹的设置"><a href="#2-文件指纹的设置" class="headerlink" title="2. 文件指纹的设置"></a>2. 文件指纹的设置</h2><h3 id="2-1-js的文件指纹设置"><a href="#2-1-js的文件指纹设置" class="headerlink" title="2.1 js的文件指纹设置"></a>2.1 js的文件指纹设置</h3><p> js使用chunkhash型的文件指纹</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        app: <span class="string">&#x27;./src/app.js&#x27;</span>,</span><br><span class="line">        search: <span class="string">&#x27;./src/search.js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">&#x27;[name][chunkhash:8].js&#x27;</span>, <span class="comment">// 取chunkhash的前8位</span></span><br><span class="line">        path: __dirname + <span class="string">&#x27;/dist&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-2-css的文件指纹设置"><a href="#2-2-css的文件指纹设置" class="headerlink" title="2.2 css的文件指纹设置"></a>2.2 css的文件指纹设置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        app: <span class="string">&#x27;./src/app.js&#x27;</span>,</span><br><span class="line">        search: <span class="string">&#x27;./src/search.js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">&#x27;[name][chunkhash:8].js&#x27;</span>,</span><br><span class="line">        path: __dirname + <span class="string">&#x27;/dist&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="comment">// 如果使用style-loader设置解析样式，做不到各自独立的css文件</span></span><br><span class="line">        <span class="comment">// 所以使用 MiniCssExtractPlugin 插件抽离出各个独立的css文件</span></span><br><span class="line">        <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">            filename: <span class="string">`[name][contenthash:8].css`</span></span><br><span class="line">        &#125;);</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-3-图片的文件指纹"><a href="#2-3-图片的文件指纹" class="headerlink" title="2.3 图片的文件指纹"></a>2.3 图片的文件指纹</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.(png|svg|jpg|gif)$/</span>,</span><br><span class="line">                use: [&#123;</span><br><span class="line">                    loader: <span class="string">&#x27;file-loader’,</span></span><br><span class="line"><span class="string">                    options: &#123;</span></span><br><span class="line"><span class="string">                    name: &#x27;</span>img/[name][hash:<span class="number">8</span>].[ext]<span class="string">&#x27;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                &#125;]</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        ]</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;打包后的文件后缀，通常用于做版本管理，文件被修改后打包出来的文件指纹不同，浏览器只会下载这些不同的文件，没被修改的文件从缓存读取，加快浏览速度&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-三种文件指纹的策略&quot;&gt;&lt;a href=&quot;#1-三
      
    
    </summary>
    
    
      <category term="前端" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Webpack" scheme="https://liang5757.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>初识webpack</title>
    <link href="https://liang5757.github.io/2020/11/22/Webpack/%E5%88%9D%E8%AF%86webpack/"/>
    <id>https://liang5757.github.io/2020/11/22/Webpack/%E5%88%9D%E8%AF%86webpack/</id>
    <published>2020-11-22T14:34:14.000Z</published>
    <updated>2020-11-27T14:26:33.342Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-cli --save-dev</span><br></pre></td></tr></table></figure><p>webpack是核心模块，webpack-cli则是命令行工具</p><p>然后在根目录下创建webpack.config.js来配置webpack</p><h2 id="2-配置资源入口"><a href="#2-配置资源入口" class="headerlink" title="2. 配置资源入口"></a>2. 配置资源入口</h2><p>在配置入口的时候，实际上是做了两件事：</p><ul><li>确定入口模块的位置，告诉webpack从那里开始打包</li><li>定义<code>chunk name</code>，如果只有一个入口，默认<code>chunk name</code>为“main”，如果为多入口，则需要为每一个入口定义<code>chunk name</code>作为其唯一标识</li></ul><h3 id="2-1-context"><a href="#2-1-context" class="headerlink" title="2.1 context"></a>2.1 context</h3><blockquote><p>entry路径前缀</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    context: path.join(__dirname, <span class="string">&#x27;./src&#x27;</span>), <span class="comment">// 资源入口前缀（为了让entry编写的更简洁</span></span><br><span class="line">    entry: <span class="string">&#x27;./index.js&#x27;</span>, <span class="comment">// string | object | array | function</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-2-entry"><a href="#2-2-entry" class="headerlink" title="2.2 entry"></a>2.2 entry</h3><p>支持四种类型的值</p><ol><li><p>字符串类型</p><p> 直接传入文件路径（绝对路径 | 相对路径）</p></li><li><p>数组类型</p><p> 作用是将<strong>多个资源预先合并</strong></p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: [<span class="string">&quot;babel-polyfill&quot;</span>, <span class="string">&quot;./src/index.js&quot;</span>], <span class="comment">// 最后的文件作为入口</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>对象类型</p><p> 想要定义多入口，则必须使用对象的形式</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        <span class="comment">// chunk name为index，入口路径为./src/index.js</span></span><br><span class="line">        index: [<span class="string">&quot;babel-polyfill&quot;</span>, <span class="string">&quot;./src/index.js&quot;</span>],</span><br><span class="line">        <span class="comment">// chunk name为lib1，入口路径为./src/lib.js</span></span><br><span class="line">        lib1: <span class="string">&#x27;./src/lib.js&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>函数类型</p><p> 可以动态设置文件路口，甚至加上异步逻辑</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">&#x27;./src/index.js&#x27;</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-3-vender"><a href="#2-3-vender" class="headerlink" title="2.3 vender"></a>2.3 vender</h3><p>一般是把工程所使用的库、框架等第三方模块集中打包而产生的bundle，可以使用CommonsChunkPlugin将app与vendor这两个chunk中的公共模块提取处理，使app.js产生的bundle将只包含业务模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        app: <span class="string">&#x27;./src/app.js&#x27;</span>,</span><br><span class="line">        vendor: [<span class="string">&#x27;vue&#x27;</span>],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-配置资源出口"><a href="#3-配置资源出口" class="headerlink" title="3. 配置资源出口"></a>3. 配置资源出口</h2><h3 id="3-1-filename"><a href="#3-1-filename" class="headerlink" title="3.1 filename"></a>3.1 filename</h3><p>作用是控制<strong>输出资源的文件名</strong>，也可以为相对路径 和 模板变量（用于控制客户端缓存，下一篇博客将会讲文件指纹）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">&#x27;./src/app.js&#x27;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">&quot;bundle.js&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-2-path"><a href="#3-2-path" class="headerlink" title="3.2 path"></a>3.2 path</h3><p>可以指定资源输出的位置，要求值必须为绝对路径</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">&#x27;./src/app.js&#x27;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">        path: path.join(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-3-publicPath"><a href="#3-3-publicPath" class="headerlink" title="3.3 publicPath"></a>3.3 publicPath</h3><p><code>path</code>用来指定资源输出位置，而<code>publicPath</code>用来指定资源请求位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设当前地址为 https://example.com/app/index.html</span></span><br><span class="line"><span class="comment">// 异步加载的资源名为 0.chunk.js</span></span><br><span class="line">publicPath: <span class="string">&quot;./js&quot;</span> <span class="comment">// 实际路径 https://example.com/app/js/0.chunk.js</span></span><br></pre></td></tr></table></figure><h2 id="4-loader"><a href="#4-loader" class="headerlink" title="4. loader"></a>4. loader</h2><p>webpack 开箱即用只支持 JS 和 JSON 两种文件类型，通过 Loader 去支持其它文件类型并且把它们转化成有效的模块，并且可以添加到依赖图中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            enforce: normal <span class="comment">// pre: 在所有loader之前调用 | normal | post: 在所有loader之后调用</span></span><br><span class="line">            test: <span class="regexp">/\.css$/</span>, <span class="comment">// 可以接受正则表达式或者正则数组</span></span><br><span class="line">            use: [<span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;less-loader&#x27;</span>], <span class="comment">// 可以接收一个数组，包含匹配项所使用loader，从右向左处理</span></span><br><span class="line">            exclude: <span class="regexp">/src\/lib/</span>, <span class="comment">// 排除目录</span></span><br><span class="line">            include: <span class="regexp">/src/</span>, <span class="comment">// 包含目录，exclude和include同时存在时-exclude优先级更高</span></span><br><span class="line">            issuer: &#123; <span class="comment">// 上面是对被加载者的配置，这是加载者的配置</span></span><br><span class="line">test: <span class="regexp">/\.js$/</span>, <span class="comment">// 该配置的意思为只有 /src/pages目录下的js可以引用css</span></span><br><span class="line">             include: <span class="regexp">/src/</span>pages/,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-plugins"><a href="#5-plugins" class="headerlink" title="5.plugins"></a>5.plugins</h2><p>对webpack loader的扩展，作用于构建的整个过程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;<span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span>&#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="6-mode"><a href="#6-mode" class="headerlink" title="6. mode"></a>6. mode</h2><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>development</code></td><td>设置<code>process.env.NODE_ENV</code>的值为<code>development</code>开启<code>NamedChunksPlugin</code>和<code>NamedModulesPlugin</code></td></tr><tr><td><code>production</code></td><td>设置<code>process.env.NODE_ENV</code>的值为<code>production</code>开启<code>FlagDependencyUsagePlugin</code>，<code>FlagInc ludedChunksPlugin</code>，                       <code>ModuleConcatenationPlugin</code>，<code>NoEmitOnErrorsPlugin</code>，<code>OccurrenceOrderPlugin</code>， <code>SideEffectsFlagPlugin</code>和<code>TerserPlugin</code></td></tr><tr><td><code>none</code></td><td>不开启任何优化选项</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-安装&quot;&gt;&lt;a href=&quot;#1-安装&quot; class=&quot;headerlink&quot; title=&quot;1. 安装&quot;&gt;&lt;/a&gt;1. 安装&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="前端" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Webpack" scheme="https://liang5757.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>Jest自动化测试入门</title>
    <link href="https://liang5757.github.io/2020/11/17/%E6%B5%8B%E8%AF%95/Jest%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8/"/>
    <id>https://liang5757.github.io/2020/11/17/%E6%B5%8B%E8%AF%95/Jest%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8/</id>
    <published>2020-11-17T07:55:41.000Z</published>
    <updated>2020-11-27T14:41:25.335Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1. 环境搭建"></a>1. 环境搭建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev jest</span><br></pre></td></tr></table></figure><p>然后在项目根目录下，控制台执行如下命令，就会初始化jest配置 jest.config.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx jest --init</span><br></pre></td></tr></table></figure><p>生成代码覆盖率</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx jest --coverage</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="/2020/11/17/%E6%B5%8B%E8%AF%95/Jest%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8/image-20201117155410176.png" alt="image-20201117155410176"></p><h2 id="2-简单测试"><a href="#2-简单测试" class="headerlink" title="2.简单测试"></a>2.简单测试</h2><p>首先有两个文件</p><p>liang.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">money</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> money &gt; <span class="number">10000</span> ? <span class="string">&#x27;有钱哩&#x27;</span> : <span class="string">&#x27;难受&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">money</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> money &gt; <span class="number">1000</span> ? <span class="string">&#x27;吃大餐&#x27;</span> : <span class="string">&#x27;吃空气&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  foo,</span><br><span class="line">  bar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>liang.test.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; foo, bar &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./liang&#x27;</span>);</span><br><span class="line"></span><br><span class="line">test(<span class="string">&#x27;foo方法-5000&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// toBe ~= ===</span></span><br><span class="line">  expect(foo(<span class="number">5000</span>)).toBe(<span class="string">&#x27;难受&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">&#x27;bar方法-2000&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  expect(bar(<span class="number">2000</span>)).toBe(<span class="string">&#x27;吃大餐&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>把待测试函数包在<code>expect</code>中，用匹配器（这里是<code>toBe</code>）进行检查输出</p><p>然后在<code>package.json</code>中添加运行指令</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;jest&quot;</span><span class="comment">// 想要有监视功能就加上 --watchAll</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后<code>npm run test</code>就能运行我们第一个jest测试了</p><p><img src= "/img/loading.gif" data-src="/2020/11/17/%E6%B5%8B%E8%AF%95/Jest%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8/image-20201116165402179.png" alt="image-20201116165402179"></p><h2 id="3-常用匹配器"><a href="#3-常用匹配器" class="headerlink" title="3.常用匹配器"></a>3.常用匹配器</h2><table><thead><tr><th>匹配器</th><th>功能</th></tr></thead><tbody><tr><td>toBe</td><td>===</td></tr><tr><td>toEqual</td><td>递归比较对象所有属性的值（深度相等）</td></tr><tr><td>toBeNull</td><td>只匹配 <code>null</code></td></tr><tr><td>toBeUndefined</td><td>只匹配 <code>undefined</code></td></tr><tr><td>toBeDefined</td><td>不为<code>undefined</code></td></tr><tr><td>toBeTruthy</td><td>匹配任何 <code>if</code> 语句为真</td></tr><tr><td>toBeFalsy</td><td>匹配任何 <code>if</code> 语句为假</td></tr></tbody></table><p>可以在上述匹配器前加个not表示取反，比如<code>.not.toBe</code>表示不严格等于</p><p>有关匹配器的完整列表，请查阅 <a href="https://jestjs.io/docs/zh-Hans/expect">参考文档</a></p><h2 id="4-测试异步方法"><a href="#4-测试异步方法" class="headerlink" title="4. 测试异步方法"></a>4. 测试异步方法</h2><h3 id="4-1-引入文件"><a href="#4-1-引入文件" class="headerlink" title="4.1 引入文件"></a>4.1 引入文件</h3><p>fetchData.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchData</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">&#x27;http://localhost:3000/&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fetchData.test.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; fetchData &#125; <span class="keyword">from</span> <span class="string">&#x27;./fetchData&#x27;</span></span><br><span class="line"></span><br><span class="line">test(<span class="string">&#x27;fetchData 方法测试1&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  fetchData().then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    expect(response.data).toEqual(&#123;</span><br><span class="line">      success: <span class="literal">true</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>无论怎么样都会测试成功，因为jest测试一旦执行到末尾就会完成</strong><br>所以问题再与一旦<code>fetchData</code>执行结束，此测试就在没用调用回调函数前结束</p><h3 id="4-2-解决方法"><a href="#4-2-解决方法" class="headerlink" title="4.2 解决方法"></a>4.2 解决方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">&#x27;fetchData 方法测试2&#x27;</span>, <span class="function">(<span class="params">done</span>) =&gt;</span> &#123;</span><br><span class="line">  fetchData().then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    expect(response.data).toEqual(&#123;</span><br><span class="line">      success: <span class="literal">true</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    done(); <span class="comment">// Jest会等 done 回调函数执行结束后，结束测试，所以会</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="4-3-export数量断言"><a href="#4-3-export数量断言" class="headerlink" title="4.3 export数量断言"></a>4.3 export数量断言</h3><p>下面一段代码的功能：检查接口是否存在，如果不存在就测试成功</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">&#x27;fetchData catch方法测试&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  expect.assertions(<span class="number">1</span>) <span class="comment">// 断言，必须执行一次export，如果不执行则报错</span></span><br><span class="line">  <span class="comment">// 如果不加断言，那么如果没有错误被catch到，则测试不会被执行，显示不出报错</span></span><br><span class="line">  fetchData().catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    expect(err.toString().indexOf(<span class="string">&#x27;404&#x27;</span>) &gt; -<span class="number">1</span>).toBe(<span class="literal">true</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="4-4-async和await的测试方法"><a href="#4-4-async和await的测试方法" class="headerlink" title="4.4 async和await的测试方法"></a>4.4 async和await的测试方法</h3><p>如果是用await进行测试的话，可以使用<code>export</code>的<code>resolves</code>和<code>rejects</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">&#x27;fetchData async方法&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> expect(fetchData()).resolves.toMatchObject(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      success: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="5-钩子函数"><a href="#5-钩子函数" class="headerlink" title="5. 钩子函数"></a>5. 钩子函数</h2><h3 id="5-1-功能描述"><a href="#5-1-功能描述" class="headerlink" title="5.1 功能描述"></a>5.1 功能描述</h3><p>像vue-router的导航守卫一样的，jest也有四个钩子函数</p><table><thead><tr><th>钩子函数</th><th>功能</th></tr></thead><tbody><tr><td>beforeAll</td><td>在<strong>所有</strong>测试用例<strong>之前</strong>执行</td></tr><tr><td>afterAll</td><td>在所有测试用例<strong>之后</strong>执行</td></tr><tr><td>beforeEach</td><td>在<strong>每一个</strong>测试用例之前执行</td></tr><tr><td>afterEach</td><td>在<strong>每一个</strong>测试用例<strong>之后</strong>执行</td></tr></tbody></table><h3 id="5-2-作用域"><a href="#5-2-作用域" class="headerlink" title="5.2 作用域"></a>5.2 作用域</h3><p>默认情况下<code>before</code> 和 <code>after</code> 的块可以应用到文件中的每个测试，可以使用<code>describe</code>声明一个作用域，这些钩子函数在<code>describe</code>声明 的作用域内调用，则只会作用在该作用域内。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">&#x27;../simpleDemo/liang&#x27;</span></span><br><span class="line"></span><br><span class="line">beforeAll(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;我是在外面的beforeAll&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">beforeEach(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;我是在外面的beforeEach&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">describe(<span class="string">&#x27;describe inner&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  beforeAll(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我是在里面的beforeAll&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  test(<span class="string">&#x27;foo方法-5000&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// toBe ~= ===</span></span><br><span class="line">    expect(foo(<span class="number">5000</span>)).toBe(<span class="string">&#x27;难受&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  test(<span class="string">&#x27;bar方法-2000&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    expect(bar(<span class="number">2000</span>)).toBe(<span class="string">&#x27;吃大餐&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="/2020/11/17/%E6%B5%8B%E8%AF%95/Jest%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8/image-20201117153234402.png" alt="image-20201117153234402"></p><h3 id="5-3-钩子函数的作用规则"><a href="#5-3-钩子函数的作用规则" class="headerlink" title="5.3 钩子函数的作用规则"></a>5.3 钩子函数的作用规则</h3><p>由上面截图的执行顺序，可以引出以下三条规则</p><ul><li>钩子函数在父级分组可作用于子集</li><li>钩子函数同级分组作用域互不干扰，各起作用</li><li>先执行外部的钩子函数，再执行内部的钩子函数</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-环境搭建&quot;&gt;&lt;a href=&quot;#1-环境搭建&quot; class=&quot;headerlink&quot; title=&quot;1. 环境搭建&quot;&gt;&lt;/a&gt;1. 环境搭建&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g
      
    
    </summary>
    
    
      <category term="测试" scheme="https://liang5757.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="js" scheme="https://liang5757.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>深拷贝、浅拷贝</title>
    <link href="https://liang5757.github.io/2020/10/31/Js/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>https://liang5757.github.io/2020/10/31/Js/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-10-31T15:02:13.000Z</published>
    <updated>2020-11-27T14:44:02.930Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-区别"><a href="#1-区别" class="headerlink" title="1. 区别"></a>1. 区别</h2><blockquote><p>浅拷贝：复制基本类型和引用类型</p><p>深拷贝：引用类型所指向的内存空间也完全拷贝</p></blockquote><h2 id="2-浅拷贝的实现方式"><a href="#2-浅拷贝的实现方式" class="headerlink" title="2. 浅拷贝的实现方式"></a>2. 浅拷贝的实现方式</h2><h3 id="2-1-Object-assign-target-…sources"><a href="#2-1-Object-assign-target-…sources" class="headerlink" title="2.1 Object.assign(target, …sources)"></a>2.1 Object.assign(target, …sources)</h3><p>把对象的可枚举属性拷贝给目标对象</p><h3 id="2-2-展开运算符…"><a href="#2-2-展开运算符…" class="headerlink" title="2.2 展开运算符…"></a>2.2 展开运算符…</h3><p>与Object.assign相同</p><h4 id="2-3-Array-prototype-concat"><a href="#2-3-Array-prototype-concat" class="headerlink" title="2.3 Array.prototype.concat()"></a>2.3 Array.prototype.concat()</h4><h4 id="2-4-Array-prototype-slice"><a href="#2-4-Array-prototype-slice" class="headerlink" title="2.4 Array.prototype.slice()"></a>2.4 Array.prototype.slice()</h4><h2 id="3-深拷贝的实现方式"><a href="#3-深拷贝的实现方式" class="headerlink" title="3.  深拷贝的实现方式"></a>3.  深拷贝的实现方式</h2><h4 id="3-1-JSON-parse-JSON-stringify"><a href="#3-1-JSON-parse-JSON-stringify" class="headerlink" title="3.1.JSON.parse(JSON.stringify())"></a>3.1.JSON.parse(JSON.stringify())</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, &#123; <span class="attr">username</span>: <span class="string">&#x27;liangliang&#x27;</span> &#125;];</span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(arr)); <span class="comment">// 深拷贝，会为对象开辟新的栈空间</span></span><br></pre></td></tr></table></figure><p><strong>优点</strong></p><ul><li>可以解决对象内部循环引用的问题，JSON.stringify内部做了循环引用的检测</li></ul><p><strong>缺点</strong></p><ul><li>会抛弃对象的constructor，无论原本的构造函数是什么，在此之后都会变成Object</li><li>但是这样对正则表达式处理后会变成空对象，数组或者对象中的函数变为null</li></ul><h3 id="3-2-jQuery-extend"><a href="#3-2-jQuery-extend" class="headerlink" title="3.2 jQuery.extend"></a>3.2 jQuery.extend</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery.extend( [deep], target, object1 [, objectN ] )</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/6844904197595332622">https://juejin.im/post/6844904197595332622</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/33（内含jQuery的实现）">https://github.com/mqyqingfeng/Blog/issues/33（内含jQuery的实现）</a><br><a href="https://segmentfault.com/a/1190000016672263（内含循环深拷贝）">https://segmentfault.com/a/1190000016672263（内含循环深拷贝）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-区别&quot;&gt;&lt;a href=&quot;#1-区别&quot; class=&quot;headerlink&quot; title=&quot;1. 区别&quot;&gt;&lt;/a&gt;1. 区别&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;浅拷贝：复制基本类型和引用类型&lt;/p&gt;
&lt;p&gt;深拷贝：引用类型所指向的内存空间也完全拷贝&lt;/p
      
    
    </summary>
    
    
      <category term="前端" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://liang5757.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>圣杯布局、双飞翼布局</title>
    <link href="https://liang5757.github.io/2020/10/30/Css/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E3%80%81%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/"/>
    <id>https://liang5757.github.io/2020/10/30/Css/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E3%80%81%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/</id>
    <published>2020-10-30T12:33:32.000Z</published>
    <updated>2020-11-27T14:28:14.244Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-问题场景"><a href="#1-问题场景" class="headerlink" title="1. 问题场景"></a>1. 问题场景</h2><p>三列布局中，如果想要将主要内容main优先加载优化，则DOM如下所示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;g-container&quot;</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;g-main&quot;</span>&gt;</span>我是主列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;g-left&quot;</span>&gt;</span>我是左列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;g-right&quot;</span>&gt;</span>我是右列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但又想将主要内容在中间位置显示，便有如下css</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.g-container</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line"></span><br><span class="line">  &amp; &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">190px</span>;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">30px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-container</span> <span class="selector-class">.g-main</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#cc6630</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f00</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">190px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#00f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面逐行分析一下：<br>第1行：grid-s5m0e5 是一个布局框的名称，我们为其定义了宽度100%（在IE6一不定义100%时，有点小问题，亲们自己可以一试）</p><p>第2行：col-main 【主列】：浮动左侧，宽度100%（宽度全让它给占了，左右两侧的层该怎么办？）</p><p>第3行：col-sub 【子列】：浮动左侧，宽度190，左边界为-100%（此处是关键：浮动情况下，负边界值会导致DIV上移，而使用-100%可以确实它移动到最左侧。）</p><p>第4行：col-extra 【附加列】：左浮动，宽度190，左边界为-190px（道理同上，注意的是，负左边界一定要大于或等于该DIV的宽度，才能靠到上一行去）</p><p>让我们看看效果</p><p><img src= "/img/loading.gif" data-src="/2020/10/30/Css/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E3%80%81%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/1565423970941.png" alt="1565423970941"></p><p><strong>但这样布局后发现主列中的文字不见了</strong>，经过DOM分析发现，原来是<strong>被col-sub挡住</strong>了，那么如何给main正确的定位呢。</p><h2 id="1-圣杯布局-margin-position"><a href="#1-圣杯布局-margin-position" class="headerlink" title="1.圣杯布局(margin+position)"></a>1.圣杯布局(margin+position)</h2><blockquote><p>左右两列通过<code>margin-left</code>与<code>left和right</code>准确定位，中间列用width:100%撑开<br>圣杯布局的关键点父元素需要设置<code>padding</code><br><code>margin-left</code>取值为百分比时，是以其父元素的宽度为基准的</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.g-container</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">190px</span>;</span><br><span class="line"></span><br><span class="line">  &amp; &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">30px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-main</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#cc6630</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-left</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">190px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">190px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ffcc00</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-right</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">190px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">190px</span>;</span><br><span class="line">  <span class="attribute">right</span>: -<span class="number">190px</span>;</span><br><span class="line">  <span class="attribute">background</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-圣杯布局-flex"><a href="#2-圣杯布局-flex" class="headerlink" title="2. 圣杯布局(flex)"></a>2. 圣杯布局(flex)</h2><blockquote><p>利用flex的order属性调整位置</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.g-container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: nowrap;</span><br><span class="line"></span><br><span class="line">  &amp; &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">30px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-main</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">flex</span>: auto <span class="number">1</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#cc6630</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-left</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">200px</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ffcc00</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-right</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">200px</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="/2020/10/30/Css/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E3%80%81%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/image-20201030180215043.png" alt="image-20201030180215043"></p><p>这种写法更加简洁，但是兼容性不太好</p><h2 id="3-双飞翼布局-margin"><a href="#3-双飞翼布局-margin" class="headerlink" title="3.双飞翼布局(margin)"></a>3.双飞翼布局(margin)</h2><blockquote><p>利用<code>margin-left</code>属性将左右两列放置到准确的位置，通过控制 main列 的<code>margin</code>空出左右两列</p></blockquote><p>下面是淘宝的做法：</p><p>1、DOM结构的改变：在.col-main下再次添加一个 .main-wrap</p><p>2、利用CSS调整.main-wrap的位置。【这里很简单，就是把左右被挡住的部分，设置为main-wrap的左   右边界即可】</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;g-container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;g-main&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main-wrap&quot;</span>&gt;</span></span><br><span class="line">            我是主列，出来吧！</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;g-left&quot;</span>&gt;</span>我是左列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;g-right&quot;</span>&gt;</span>我是右列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.g-container</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line"></span><br><span class="line">  &amp; &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">190px</span>;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">30px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-container</span> <span class="selector-class">.g-main</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#cc6630</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="selector-class">.main-wrap</span> &#123;</span><br><span class="line">      <span class="attribute">margin-left</span>: <span class="number">200px</span>; <span class="comment">/*与g-left产生10像素距离*/</span></span><br><span class="line">      <span class="attribute">margin-right</span>: <span class="number">200px</span>; <span class="comment">/*与g-right产生10像素距离*/</span></span><br><span class="line">      <span class="attribute">background</span>: <span class="number">#0f0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-left</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f00</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">190px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#00f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终效果</p><p><img src= "/img/loading.gif" data-src="/2020/10/30/Css/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E3%80%81%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/1565424018386.png" alt="1565424018386"></p><p><strong>优点</strong></p><ul><li>实现了内容与布局的分离，即Eric提到的Any-Order Columns.</li><li>main部分是自适应宽度的，很容易在定宽布局和流体布局中切换。</li><li>任何一栏都可以是最高栏，不会出问题。</li><li>需要的hack非常少（就一个针对ie6的清除浮动hack:_zoom: 1;）</li><li>在浏览器上的兼容性非常好，IE5.5以上都支持。</li></ul><p><strong>不足</strong></p><ul><li>main需要添加一个额外的包裹层。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-问题场景&quot;&gt;&lt;a href=&quot;#1-问题场景&quot; class=&quot;headerlink&quot; title=&quot;1. 问题场景&quot;&gt;&lt;/a&gt;1. 问题场景&lt;/h2&gt;&lt;p&gt;三列布局中，如果想要将主要内容main优先加载优化，则DOM如下所示&lt;/p&gt;
&lt;figure class
      
    
    </summary>
    
    
      <category term="前端" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS" scheme="https://liang5757.github.io/tags/CSS/"/>
    
      <category term="技巧" scheme="https://liang5757.github.io/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>css预处理器：Less</title>
    <link href="https://liang5757.github.io/2020/10/30/Css/css%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%9ALess/"/>
    <id>https://liang5757.github.io/2020/10/30/Css/css%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%9ALess/</id>
    <published>2020-10-30T12:30:48.000Z</published>
    <updated>2020-11-27T14:27:55.626Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-注释"><a href="#1-注释" class="headerlink" title="1.注释"></a>1.注释</h3><ul><li>以 // 开头的注释，不会被编译到css文件中</li><li>以 /**/ 包裹的注释会被编译到css文件中</li></ul><h3 id="2-变量"><a href="#2-变量" class="headerlink" title="2.变量"></a>2.变量</h3><h4 id="2-1普通变量"><a href="#2-1普通变量" class="headerlink" title="2.1普通变量"></a>2.1普通变量</h4><p>less中使用@定义一个变量，再以@开头调用</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@zero:</span> <span class="number">0</span>;</span><br><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="variable">@zero</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="variable">@zero</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2变量作为选择器、属性名或者url"><a href="#2-2变量作为选择器、属性名或者url" class="headerlink" title="2.2变量作为选择器、属性名或者url"></a>2.2变量作为选择器、属性名或者url</h4><p>使用@{selector/property/url}调用</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@selector:</span> wrap;</span><br><span class="line"><span class="variable">@url:</span> <span class="string">&quot;../img/1.jpg&quot;</span>;</span><br><span class="line"><span class="variable">@w:</span> width;</span><br><span class="line"></span><br><span class="line"><span class="variable">@&#123;selector&#125;</span>&#123;</span><br><span class="line">    <span class="attribute">@&#123;w&#125;</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">background</span>: url(<span class="string">&quot;@&#123;url&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3变量的延迟加载"><a href="#2-3变量的延迟加载" class="headerlink" title="2.3变量的延迟加载"></a>2.3变量的延迟加载</h4><ul><li>less中的加载是有延迟的</li><li>它会在当前作用域样式未加载之前先加载变量，而且是由内而外，先寻找作用域内的变量，如果没有再寻找作用域外的变量</li><li>less机制是先加载完声明变量再赋值到样式中去</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@var:</span> <span class="number">0</span>;</span><br><span class="line"><span class="selector-class">.class</span> &#123;</span><br><span class="line"><span class="variable">@var:</span> <span class="number">1</span>;</span><br><span class="line">    <span class="selector-class">.brass</span> &#123;</span><br><span class="line">      <span class="variable">@var:</span> <span class="number">2</span>;</span><br><span class="line">      <span class="attribute">three</span>: <span class="variable">@var</span>;  <span class="comment">//3</span></span><br><span class="line">      <span class="variable">@var:</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="attribute">one</span>: <span class="variable">@var</span>;  <span class="comment">//1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-嵌套规则"><a href="#3-嵌套规则" class="headerlink" title="3.嵌套规则"></a>3.嵌套规则</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#list</span>&#123;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">    <span class="selector-tag">a</span>&#123;</span><br><span class="line">        <span class="attribute">float</span>: left;</span><br><span class="line">        <span class="comment">/*&amp;代表父级*/</span></span><br><span class="line">        <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span>&#123;<span class="attribute">color</span>: red;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">span</span>&#123;<span class="attribute">float</span>: right;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&amp;的使用（&amp;代表父级）<br>如果想写串联选择器，而不是写后代选择器，就可以用到&amp;了.<br>这点对伪类尤其有用如 :hover 和 :focus</p><h3 id="4-混合"><a href="#4-混合" class="headerlink" title="4.混合"></a>4.混合</h3><p> 混合就是一种将一系列属性从一个规则集引入（“混合”）到另一个规则集的方式。 </p><h4 id="4-1普通混合"><a href="#4-1普通混合" class="headerlink" title="4.1普通混合"></a>4.1普通混合</h4><p><strong>会将混合内容输出到css文件中</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.font_hn</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">font-family</span>: microsoft yahei, <span class="string">&quot;黑体&quot;</span>, Arial, Simsun, <span class="string">&quot;Arial Unicode MS&quot;</span>, Mingliu, Helvetica;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">28px</span>;</span><br><span class="line">  <span class="selector-class">.font_hn</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2不带输出的混合"><a href="#4-2不带输出的混合" class="headerlink" title="4.2不带输出的混合"></a>4.2不带输出的混合</h4><p> <strong>加()后就不会在css中输出混合内容了</strong> ，即输出的css文件中无font_hn</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.font_hn</span>()&#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">font-family</span>: microsoft yahei, <span class="string">&quot;黑体&quot;</span>, Arial, Simsun, <span class="string">&quot;Arial Unicode MS&quot;</span>, Mingliu, Helvetica;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">28px</span>;</span><br><span class="line">  <span class="selector-class">.font_hn</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3带参数的混合"><a href="#4-3带参数的混合" class="headerlink" title="4.3带参数的混合"></a>4.3带参数的混合</h4><p>类似函数的调用方式，参数名开头为@ </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.border</span>(<span class="variable">@color</span>)&#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="variable">@color</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="selector-class">.border</span>(green);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h2</span>&#123;</span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="selector-class">.border</span>(<span class="number">#000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">其<span class="selector-tag">css</span>文件为：</span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#008000</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">21px</span> <span class="number">#008000</span> <span class="number">#ff0000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">h2</span>:hover &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000000</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">21px</span> <span class="number">#000000</span> <span class="number">#ff0000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4带参数且有默认值的混合"><a href="#4-4带参数且有默认值的混合" class="headerlink" title="4.4带参数且有默认值的混合"></a>4.4带参数且有默认值的混合</h4><p>使用 : 为参数添加默认值， 有了默认值，我们可以不用设置属性值也能被调用 </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.border_you</span>(<span class="variable">@color</span>:red)&#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="variable">@color</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="selector-class">.border_you</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h2</span>&#123;</span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="selector-class">.border_you</span>(yellow);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">其编译后的<span class="selector-tag">css</span>文件如下：</span><br><span class="line"></span><br><span class="line"><span class="comment">/*带参数并且有默认值的混合*/</span></span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ff0000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">h2</span>:hover &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ffff00</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5命名参数（传实参时可以指定值给的是哪个参数）"><a href="#4-5命名参数（传实参时可以指定值给的是哪个参数）" class="headerlink" title="4.5命名参数（传实参时可以指定值给的是哪个参数）"></a>4.5命名参数（传实参时可以指定值给的是哪个参数）</h4><p> 引用mixin时可以通过参数名称而不是参数的位置来为mixin提供参数值。任何参数都以用过它的名称来使用，这样就不必按照任意特定的顺序来使用参数 </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.mixin</span>(<span class="variable">@color</span>: black; <span class="variable">@margin</span>: <span class="number">10px</span>; <span class="variable">@padding</span>: <span class="number">20px</span>) &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">@color</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="variable">@margin</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="variable">@padding</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.class1</span> &#123;</span><br><span class="line">  <span class="selector-class">.mixin</span>(<span class="variable">@margin</span>: <span class="number">20px</span>; <span class="variable">@color</span>: <span class="number">#33acfe</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.class2</span> &#123;</span><br><span class="line">  <span class="selector-class">.mixin</span>(<span class="number">#efca44</span>; <span class="variable">@padding</span>: <span class="number">40px</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">其编译后的<span class="selector-tag">css</span>文件如下:</span><br><span class="line"><span class="selector-class">.class1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#33acfe</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.class2</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#efca44</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-6匹配模式"><a href="#4-6匹配模式" class="headerlink" title="4.6匹配模式"></a>4.6匹配模式</h4><p> 根据传入的参数来改变混合的默认呈现</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.border</span>(all,<span class="variable">@w</span>: <span class="number">5px</span>)&#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="variable">@w</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.border</span>(t_l,<span class="variable">@w</span>:<span class="number">5px</span>)&#123;</span><br><span class="line">  <span class="attribute">border-top-left-radius</span>: <span class="variable">@w</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.border</span>(t_r,<span class="variable">@w</span>:<span class="number">5px</span>)&#123;</span><br><span class="line">  <span class="attribute">border-top-right-radius</span>: <span class="variable">@w</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.border</span>(b-l,<span class="variable">@w</span>:<span class="number">5px</span>)&#123;</span><br><span class="line">  <span class="attribute">border-bottom-left-radius</span>: <span class="variable">@w</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.border</span>(b-r,<span class="variable">@w</span>:<span class="number">5px</span>)&#123;</span><br><span class="line">  <span class="attribute">border-bottom-right-radius</span>: <span class="variable">@w</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">footer</span>&#123;</span><br><span class="line">  <span class="selector-class">.border</span>(t_l,<span class="number">10px</span>);</span><br><span class="line">  <span class="selector-class">.border</span>(b-r,<span class="number">10px</span>);</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#33acfe</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">其编译后的<span class="selector-tag">css</span>文件如下：</span><br><span class="line"><span class="selector-tag">footer</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">21px</span> t_l <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border-top-left-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">21px</span> b-r <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border-bottom-right-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#33acfe</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-7-arguments变量"><a href="#4-7-arguments变量" class="headerlink" title="4.7@arguments变量"></a>4.7@arguments变量</h4><p> @arguments代表所有的可变参数 </p><p><strong>注意事项：</strong></p><ol><li><p>@arguments代表所有可变参数，参数的先后顺序就是你的（）括号内的参数的先后顺序</p></li><li><p>在使用的赋值，值的位置和个数也是一一对应的，只有一个值，把值赋值给第一个，两个值，赋值给第一个和第二个，三个值赋值给第三个……以此类推，但是需要注意的是假如我想给第一个和第三个赋值，你不能写（值1，，值3），必须把原来的默认值写上去！</p></li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.border</span>(<span class="variable">@x</span>:solid,<span class="variable">@c</span>:red)&#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">21px</span> <span class="variable">@arguments</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.div1</span>&#123;</span><br><span class="line">  <span class="selector-class">.border</span>(solid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">其编译后的<span class="selector-tag">css</span>文件为：</span><br><span class="line"><span class="selector-class">.div1</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">21px</span> solid <span class="number">#ff0000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-8混合的返回值"><a href="#4-8混合的返回值" class="headerlink" title="4.8混合的返回值"></a>4.8混合的返回值</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.average</span>(<span class="variable">@x</span>, <span class="variable">@y</span>) &#123;</span><br><span class="line">  <span class="variable">@average:</span> ((<span class="variable">@x</span> + <span class="variable">@y</span>) / <span class="number">2</span>);</span><br><span class="line">  <span class="variable">@he:</span> (<span class="variable">@x</span> + <span class="variable">@y</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="selector-class">.average</span>(<span class="number">16px</span>, <span class="number">50px</span>);</span><br><span class="line">  <span class="attribute">padding</span>: <span class="variable">@average</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="variable">@he</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">其编译后的<span class="selector-tag">css</span>文件如下：</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">33px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">66px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-运算"><a href="#5-运算" class="headerlink" title="5.运算"></a>5.运算</h3><h4 id="5-1数值运算"><a href="#5-1数值运算" class="headerlink" title="5.1数值运算"></a>5.1数值运算</h4><p> 只需要在其中的一个数值上加上单位，其他单位由less自动加上 </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wp</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">450px</span> + <span class="number">450</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400</span> + <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2颜色运算"><a href="#5-2颜色运算" class="headerlink" title="5.2颜色运算"></a>5.2颜色运算</h4><p> Less在运算时，先将颜色值转换为rgb模式，然后再转换为16进制的颜色值并且返回 </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.content</span>&#123;   <span class="attribute">Background</span>:<span class="number">#000000</span> + <span class="number">21</span>;  &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">Css</span>文件编译结果</span><br><span class="line"><span class="selector-class">.content</span>&#123;  <span class="attribute">background</span>:<span class="number">#212121</span>;  &#125;</span><br></pre></td></tr></table></figure><h3 id="6-函数"><a href="#6-函数" class="headerlink" title="6.函数"></a>6.函数</h3><h4 id="6-1RGB函数"><a href="#6-1RGB函数" class="headerlink" title="6.1RGB函数"></a>6.1RGB函数</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.bgcolor</span>&#123; <span class="attribute">background</span>:rgb(<span class="number">0</span>,<span class="number">133</span>,<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">Css</span>结果：</span><br><span class="line"><span class="selector-class">.bgcolor</span>&#123; <span class="attribute">background</span>:<span class="number">#008500</span>; &#125;</span><br></pre></td></tr></table></figure><h4 id="6-2Convert函数"><a href="#6-2Convert函数" class="headerlink" title="6.2Convert函数"></a>6.2Convert函数</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123; <span class="attribute">width</span>:convert(<span class="number">20cm</span>,px); &#125;  </span><br><span class="line"></span><br><span class="line"><span class="selector-tag">Css</span>文件如下:</span><br><span class="line"><span class="selector-tag">body</span>&#123; <span class="attribute">width</span>:<span class="number">755.90551181px</span>; &#125;</span><br></pre></td></tr></table></figure><h3 id="7-命名空间"><a href="#7-命名空间" class="headerlink" title="7.命名空间"></a>7.命名空间</h3><p>多人协作时，避免选择器重名问题，引入命名空间的概念，以#开头代表命名空间，#namespace&gt;.selector即可调用</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#mynamespace</span>() &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ffffff</span>;</span><br><span class="line">  <span class="selector-class">.a</span>&#123;</span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">      <span class="attribute">color</span>: <span class="number">#ff6600</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.b</span>&#123;</span><br><span class="line">      <span class="attribute">background</span>: <span class="number">#ff0000</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.bgcolor</span>&#123;</span><br><span class="line">    <span class="selector-id">#mynamespace</span>&gt;<span class="selector-class">.a</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bgcolor2</span>&#123;</span><br><span class="line"><span class="selector-id">#mynamespace</span>&gt;<span class="selector-class">.a</span>&gt;<span class="selector-class">.b</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">编译后<span class="selector-tag">css</span>文件</span><br><span class="line"><span class="selector-class">.bgcolor</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#888888</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bgcolor</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ff6600</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bgcolor</span> <span class="selector-class">.b</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ff0000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bgcolor2</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ff0000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-避免编译"><a href="#8-避免编译" class="headerlink" title="8.避免编译"></a>8.避免编译</h3><p>将要避免编译的值用 “” 包裹起来，并在前面加~</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.class</span> &#123;</span><br><span class="line">    <span class="attribute">filter</span>: <span class="string">~&quot;ms:alwaysHasItsOwnSyntax.For.Stuff()&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">Css</span>文件如下:</span><br><span class="line"><span class="selector-class">.class</span> &#123;</span><br><span class="line">    <span class="attribute">filter</span>: <span class="attribute">ms</span>:alwaysHasItsOwnSyntax.For.Stuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-继承-extent"><a href="#9-继承-extent" class="headerlink" title="9.继承(extent)"></a>9.继承(extent)</h3><p>性能比混合高<br>继承不支持带参数，灵活度比混合低 </p><p>他将<strong>所放置它的选择器</strong>与<strong>匹配引用的选择器</strong>进行合并。 </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123; <span class="comment">// a 所放置它的选择器</span></span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:extend(.b)</span>; <span class="comment">// .b匹配引用的选择器</span></span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.b</span> &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">700</span>;</span><br><span class="line">    <span class="attribute">color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">编译后<span class="selector-tag">css</span>文件</span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.b</span>, <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">700</span>;</span><br><span class="line">  <span class="attribute">color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以在选择器后加 :extend(.selector, .selector 可选值all)表示继承，在<strong>括号内用逗号分隔多个继承元素</strong>，若有all可选值，hover等伪类也会继承</p><h3 id="10-条件表达式"><a href="#10-条件表达式" class="headerlink" title="10.条件表达式"></a>10.条件表达式</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">当我们想根据表达式进行匹配，而非根据值和参数匹配时，导引就显得非常有用。如果你对函数式编程非常熟悉，那么你很可能已经使用过导引。</span><br><span class="line"></span><br><span class="line">为了尽可能地保留<span class="selector-tag">CSS</span>的可声明性，<span class="selector-tag">LESS</span>通过导引混合而非<span class="selector-tag">if</span>/<span class="selector-tag">else</span>语句来实现条件判断，因为前者已在@<span class="selector-tag">media</span> <span class="selector-tag">query</span>特性中被定义。</span><br><span class="line"></span><br><span class="line">以此例做为开始：</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.mixin</span> (<span class="variable">@a</span>) <span class="keyword">when</span> (lightness(<span class="variable">@a</span>) &gt;= <span class="number">50%</span>) &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.mixin</span> (<span class="variable">@a</span>) <span class="keyword">when</span> (lightness(<span class="variable">@a</span>) &lt; <span class="number">50%</span>) &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.mixin</span> (<span class="variable">@a</span>) &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">@a</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">when</span>关键字用以定义一个导引序列(此例只有一个导引)。接下来我们运行下列代码：</span><br><span class="line"></span><br><span class="line">.class1 &#123; <span class="selector-class">.mixin</span>(<span class="number">#ddd</span>) &#125;</span><br><span class="line"><span class="selector-class">.class2</span> &#123; <span class="selector-class">.mixin</span>(<span class="number">#555</span>) &#125;</span><br><span class="line">就会得到：</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.class1</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: black;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ddd</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.class2</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: white;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#555</span>;</span><br><span class="line">&#125;</span><br><span class="line">导引中可用的全部比较运算有： &gt; &gt;= = =&lt; &lt;。此外，关键字true只表示布尔真值，下面两个混合是相同的：</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.truth</span> (<span class="variable">@a</span>) <span class="keyword">when</span> (<span class="variable">@a</span>) &#123; ... &#125;</span><br><span class="line"><span class="selector-class">.truth</span> (<span class="variable">@a</span>) <span class="keyword">when</span> (<span class="variable">@a</span> = true) &#123; ... &#125;</span><br><span class="line">除去关键字<span class="selector-tag">true</span>以外的值都被视示布尔假：</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.class</span> &#123;</span><br><span class="line">  <span class="selector-class">.truth</span>(<span class="number">40</span>); <span class="comment">// Will not match any of the above definitions.</span></span><br><span class="line">&#125;</span><br><span class="line">导引序列使用逗号‘,’—分割，当且仅当所有条件都符合时，才会被视为匹配成功。</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.mixin</span> (<span class="variable">@a</span>) <span class="keyword">when</span> (<span class="variable">@a</span> &gt; <span class="number">10</span>), (<span class="variable">@a</span> &lt; -<span class="number">10</span>) &#123; ... &#125;</span><br><span class="line">导引可以无参数，也可以对参数进行比较运算：</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span>: mobile;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.mixin</span> (<span class="variable">@a</span>) <span class="keyword">when</span> (<span class="variable">@media</span> = mobile) &#123; ... &#125;</span><br><span class="line"><span class="selector-class">.mixin</span> (<span class="variable">@a</span>) <span class="keyword">when</span> (<span class="variable">@media</span> = desktop) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.max</span> (<span class="variable">@a</span>, <span class="variable">@b</span>) <span class="keyword">when</span> (<span class="variable">@a</span> &gt; <span class="variable">@b</span>) &#123; <span class="attribute">width</span>: <span class="variable">@a</span> &#125;</span><br><span class="line"><span class="selector-class">.max</span> (<span class="variable">@a</span>, <span class="variable">@b</span>) <span class="keyword">when</span> (<span class="variable">@a</span> &lt; <span class="variable">@b</span>) &#123; <span class="attribute">width</span>: <span class="variable">@b</span> &#125;</span><br><span class="line">最后，如果想基于值的类型进行匹配，我们就可以使用<span class="selector-tag">is</span>*函式：</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.mixin</span> (<span class="variable">@a</span>, <span class="variable">@b</span>: <span class="number">0</span>) <span class="keyword">when</span> (isnumber(<span class="variable">@b</span>)) &#123; ... &#125;</span><br><span class="line"><span class="selector-class">.mixin</span> (<span class="variable">@a</span>, <span class="variable">@b</span>: black) <span class="keyword">when</span> (iscolor(<span class="variable">@b</span>)) &#123; ... &#125;</span><br><span class="line">下面就是常见的检测函式：</span><br><span class="line">    <span class="selector-tag">iscolor</span></span><br><span class="line">    <span class="selector-tag">isnumber</span></span><br><span class="line">    <span class="selector-tag">isstring</span></span><br><span class="line">    <span class="selector-tag">iskeyword</span></span><br><span class="line">    <span class="selector-tag">isurl</span></span><br><span class="line">如果你想判断一个值是纯数字，还是某个单位量，可以使用下列函式：</span><br><span class="line">    <span class="selector-tag">ispixel</span></span><br><span class="line">    <span class="selector-tag">ispercentage</span></span><br><span class="line">    <span class="selector-tag">isem</span></span><br><span class="line">最后再补充一点，在导引序列中可以使用<span class="selector-tag">and</span>关键字实现与条件：</span><br><span class="line"><span class="selector-class">.mixin</span> (<span class="variable">@a</span>) <span class="keyword">when</span> (isnumber(<span class="variable">@a</span>)) <span class="keyword">and</span> (<span class="variable">@a</span> &gt; <span class="number">0</span>) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">使用<span class="selector-tag">not</span>关键字实现或条件</span><br><span class="line"><span class="selector-class">.mixin</span> (<span class="variable">@b</span>) <span class="keyword">when</span> <span class="keyword">not</span> (<span class="variable">@b</span> &gt; <span class="number">0</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-注释&quot;&gt;&lt;a href=&quot;#1-注释&quot; class=&quot;headerlink&quot; title=&quot;1.注释&quot;&gt;&lt;/a&gt;1.注释&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;以 // 开头的注释，不会被编译到css文件中&lt;/li&gt;
&lt;li&gt;以 /**/ 包裹的注释会被编译到css文件中
      
    
    </summary>
    
    
      <category term="前端" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Less" scheme="https://liang5757.github.io/tags/Less/"/>
    
  </entry>
  
  <entry>
    <title>重绘与回流</title>
    <link href="https://liang5757.github.io/2020/10/04/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81/"/>
    <id>https://liang5757.github.io/2020/10/04/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81/</id>
    <published>2020-10-03T16:08:15.000Z</published>
    <updated>2020-11-27T14:43:41.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h2><blockquote><p>通过构造渲染树，将可见DOM节点以及它对应的样式结合起来，这时候需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流</p></blockquote><h2 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h2><blockquote><p>通过构造渲染树和回流阶段，我们确定了可见节点，以及可见节点的样式和具体的几何信息(位置、大小)，将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点</p></blockquote><h2 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="headerlink" title="浏览器的渲染过程"></a>浏览器的渲染过程</h2><p><img src= "/img/loading.gif" data-src="/2020/10/04/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81/Snipaste_2020-10-03_17-43-05.png" alt="Snipaste_2020-10-03_17-43-05"></p><p>在页面加载时，浏览器渲染过程如下：</p><ol><li>解析HTML，生成DOM树，解析CSS，生成CSSOM树</li><li>将DOM树和CSSOM树结合，生成渲染树(Render Tree)</li><li>Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）</li><li>Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素</li><li>Display:将像素发送给GPU，展示在页面上。（这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中。而css3硬件加速的原理则是新建合成层）</li></ol><p>为了构建渲染树，浏览器主要完成了以下工作：</p><ol><li>从DOM树的根节点开始遍历每个可见节点。</li><li>对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。</li><li>根据每个可见节点以及其对应的样式，组合生成渲染树。</li></ol><p>渲染树中只会包含可见节点。不可见节点包括：</p><ul><li>一些不会渲染输出的节点，比如script、meta、link等。</li><li>一些通过css进行隐藏的节点。如display:none。</li></ul><blockquote><p>注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。</p></blockquote><blockquote><p>由于浏览器使用流式布局，对<code>Render Tree</code>的计算通常只需要遍历一次就可以完成，但<code>table</code>及其内部元素除外，他们可能需要多次计算</p></blockquote><p>可见，<strong>如果触发回流那么必然会触发重绘</strong></p><h2 id="浏览器如何处理"><a href="#浏览器如何处理" class="headerlink" title="浏览器如何处理"></a>浏览器如何处理</h2><p>每句JS操作都去回流重绘的话，浏览器可能就会受不了。</p><p><strong>浏览器会维护1个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。</strong></p><p>虽然有了浏览器的优化，但有时候我们写的一些代码可能会强制浏览器提前flush队列，这样浏览器的优化可能就起不到作用了。当你请求向浏览器请求一些 style信息的时候，就会让浏览器flush队列：</p><ol><li>offsetTop, offsetLeft, offsetWidth, offsetHeight</li><li>scrollTop/Left/Width/Height</li><li>clientTop/Left/Width/Height</li><li>width,height</li><li>请求了getComputedStyle(), 或者 IE的 currentStyle</li></ol><p>当你请求上面的一些属性的时候，浏览器为了给你最精确的值，需要flush队列，因为队列中可能会有影响到这些值的操作。即使你获取元素的布局和样式信息跟最近发生或改变的布局信息无关，浏览器都会强行刷新渲染队列。引擎会重新渲染来确保获取的值 是实时的</p><h2 id="利用合成层性能优化：Composite"><a href="#利用合成层性能优化：Composite" class="headerlink" title="利用合成层性能优化：Composite"></a>利用合成层性能优化：Composite</h2><blockquote><p>可以利用chrome开发者工具的Layers查看合成层</p></blockquote><p>提升为合成层简单说来有以下几点好处：</p><ol><li>合成层的位图，会<strong>交由 GPU 合成</strong>，比 CPU 处理要快</li><li>当需要 repaint 时，只需要 repaint 本身，<strong>不会影响到其他的层</strong></li><li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li></ol><blockquote><p>提升合成层的最好方式是使用 CSS 的 will-change 属性。而 will-change 设置为 opacity、transform、top、left、bottom、right 可以将元素提升为合成层。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#target</span> &#123;</span><br><span class="line">    will-change: transform; //兼容性不好</span><br><span class="line">&#125;</span><br><span class="line">//对于那些目前还不支持 <span class="selector-tag">will-change</span> 属性的浏览器</span><br><span class="line">//目前常用的是使用一个 3<span class="selector-tag">D</span> <span class="selector-tag">transform</span> 属性来强制提升为合成层</span><br><span class="line"><span class="selector-id">#target</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>层合成的过程会产生内存消耗</strong>，所以不要盲目开启层合成</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/6844904161868251149">https://juejin.im/post/6844904161868251149</a><br><a href="https://juejin.im/post/6844903859719143437#heading-1">https://juejin.im/post/6844903859719143437#heading-1</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;回流&quot;&gt;&lt;a href=&quot;#回流&quot; class=&quot;headerlink&quot; title=&quot;回流&quot;&gt;&lt;/a&gt;回流&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;通过构造渲染树，将可见DOM节点以及它对应的样式结合起来，这时候需要计算它们在设备视口(viewport)内的确切
      
    
    </summary>
    
    
      <category term="前端" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端性能优化" scheme="https://liang5757.github.io/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>防抖和节流</title>
    <link href="https://liang5757.github.io/2020/09/29/Js/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"/>
    <id>https://liang5757.github.io/2020/09/29/Js/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</id>
    <published>2020-09-29T12:21:30.000Z</published>
    <updated>2020-11-27T14:44:36.156Z</updated>
    
    <content type="html"><![CDATA[<p><img src= "/img/loading.gif" data-src="/2020/09/29/Js/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/debounce.gif" alt="debounce"></p><p>上图是对鼠标进行监听，事件执行的很频繁，如果执行的事件是对接口的请求，那么会在短时间内发起大量重复请求，所以我们需要防抖或者节流进行解决。</p><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><blockquote><p>防抖即为事件触发n秒后才执行事件，如果在n秒内又触发事件则重新计时</p></blockquote><h3 id="1-手写版"><a href="#1-手写版" class="headerlink" title="1. 手写版"></a>1. 手写版</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">            func.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="/2020/09/29/Js/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/debounce-1.gif" alt="debounce-1"></p><p>移动完n秒后才执行事件</p><h3 id="2-可立即执行版"><a href="#2-可立即执行版" class="headerlink" title="2. 可立即执行版"></a>2. 可立即执行版</h3><p>触发事件立即执行，停止n秒后才可以重新触发</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, immediate = <span class="literal">true</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">            <span class="comment">// 如果已经执行过，不再执行</span></span><br><span class="line">            <span class="keyword">var</span> callNow = !timer;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                timer = <span class="literal">null</span>;</span><br><span class="line">            &#125;, wait)</span><br><span class="line">            <span class="keyword">if</span> (callNow) func.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                func.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="/2020/09/29/Js/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/debounce-4.gif" alt="debounce-4"></p><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><blockquote><p>节流即为连续触发事件但是在n秒中只执行一次函数</p></blockquote><h3 id="1-时间戳版"><a href="#1-时间戳版" class="headerlink" title="1. 时间戳版"></a>1. 时间戳版</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        <span class="keyword">if</span> (now - previous &gt; wait) &#123;</span><br><span class="line">            func.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">            previous = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当鼠标移入的时候，事件<strong>立刻执行</strong>，每过1s会执行一次，如果在2.2s停止触发，之后不会再执行事件。</p><p><img src= "/img/loading.gif" data-src="/2020/09/29/Js/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/throttle1.gif" alt="throttle1"></p><h3 id="2-定时器版"><a href="#2-定时器版" class="headerlink" title="2. 定时器版"></a>2. 定时器版</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout;</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">                func.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="/2020/09/29/Js/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/throttle2.gif" alt="throttle2"></p><p>可以看到使用定时器版本的节流函数，鼠标移入并<strong>不会立即执行</strong>，此后每移动1秒执行一次函数，在3.2秒左右移出鼠标，但是仍会在4秒时执行函数</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/mqyqingfeng/Blog/issues/22">https://github.com/mqyqingfeng/Blog/issues/22</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/26">https://github.com/mqyqingfeng/Blog/issues/26</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src= &quot;/img/loading.gif&quot; data-src=&quot;/2020/09/29/Js/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/debounce.gif&quot; alt=&quot;debounce&quot;&gt;&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="前端" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://liang5757.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Typescript语法篇</title>
    <link href="https://liang5757.github.io/2020/09/25/Ts/Typescript%E8%AF%AD%E6%B3%95%E7%AF%87/"/>
    <id>https://liang5757.github.io/2020/09/25/Ts/Typescript%E8%AF%AD%E6%B3%95%E7%AF%87/</id>
    <published>2020-09-25T09:14:10.000Z</published>
    <updated>2020-11-27T14:46:42.844Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-typescript的原始类型"><a href="#1-typescript的原始类型" class="headerlink" title="1.typescript的原始类型"></a>1.typescript的原始类型</h2><ol><li>boolean</li><li>number </li><li>string </li><li>void（只有<code>null</code>和<code>undefined</code>可以赋给<code>void</code>）</li><li>undefined 和 null（是所有类型的子类型，严格模式下只能赋值给对应的类型或者any）</li><li>symbol</li><li>bigint</li></ol><h2 id="2-Typescript-中其他常见类型"><a href="#2-Typescript-中其他常见类型" class="headerlink" title="2.Typescript 中其他常见类型"></a>2.Typescript 中其他常见类型</h2><ol><li>any（为任意类型）</li></ol><ul><li><strong>变量如果在声明的时候，未指定其类型或者初始化，那么它会被识别为any类型</strong></li></ul><ol start="2"><li><p>unknown</p><ul><li><p>较any类型更安全s</p></li><li><p>该类型变量被确定为某一类型前，不能进行任何操作</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: unknown;</span><br><span class="line">   </span><br><span class="line">value.foo.bar;  <span class="comment">// ERROR</span></span><br><span class="line">value();        <span class="comment">// ERROR</span></span><br><span class="line"><span class="keyword">new</span> value();    <span class="comment">// ERROR</span></span><br><span class="line">value[<span class="number">0</span>][<span class="number">1</span>];    <span class="comment">// ERROR</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>never</p><ul><li><p>永不存在值的类型</p></li><li><p>是任何类型的子类型，可以赋值给任何类型</p></li><li><p>没有类型是 never 的子类型，任意类型都不能赋值给never类型（包括any）</p></li><li><p>常用在 <strong>抛出异常的函数</strong> 和 <strong>空数组且永远为空数组</strong></p></li></ul></li><li><p>数组类型(array)</p> <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有两种定义方式</span></span><br><span class="line"><span class="keyword">const</span> list: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]<span class="comment">// 泛型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> list: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure></li><li><p>元组(tuple)</p><ul><li>已知元素数量及类型的数组<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: [<span class="built_in">string</span>, <span class="built_in">number</span>];<span class="comment">// 两个元素，类型顺序也不能变</span></span><br></pre></td></tr></table></figure></li><li>ts允许元组使用数组的push方法，但我们访问新加入的元素时会报错</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tuple: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>];</span><br><span class="line">tuple.push(<span class="number">2</span>); <span class="comment">// ok</span></span><br><span class="line"><span class="built_in">console</span>.log(tuple); <span class="comment">// [&quot;a&quot;, 1, 2] -&gt; 正常打印出来</span></span><br><span class="line"><span class="built_in">console</span>.log(tuple[<span class="number">2</span>]); <span class="comment">// Tuple type &#x27;[string, number]&#x27; of length &#x27;2&#x27; has no element at index &#x27;2&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>object</p></li></ol><h2 id="3-枚举类型"><a href="#3-枚举类型" class="headerlink" title="3.枚举类型"></a>3.枚举类型</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Direction &#123;</span><br><span class="line">    Up,<span class="comment">// 0</span></span><br><span class="line">    Down = <span class="number">2</span>,<span class="comment">// 2</span></span><br><span class="line">    Left,<span class="comment">// 3</span></span><br><span class="line">    Right,  <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不带初始化的枚举 要么放在第一个位置， 要么在被数字常量或其它常量初始化的枚举后面，否则会报错</p><h3 id="3-1-枚举的本质"><a href="#3-1-枚举的本质" class="headerlink" title="3.1 枚举的本质"></a>3.1 枚举的本质</h3><p>枚举类型被编译为 JavaScript的形式如下所示，是具有双向映射的特性（字符串类型除外）</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Direction;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Direction</span>) </span>&#123;</span><br><span class="line">    Direction[Direction[<span class="string">&quot;Up&quot;</span>] = <span class="number">0</span>] = <span class="string">&quot;Up&quot;</span>;</span><br><span class="line">    Direction[Direction[<span class="string">&quot;Down&quot;</span>] = <span class="number">2</span>] = <span class="string">&quot;Down&quot;</span>;</span><br><span class="line">    Direction[Direction[<span class="string">&quot;Left&quot;</span>] = <span class="number">3</span>] = <span class="string">&quot;Left&quot;</span>;</span><br><span class="line">    Direction[Direction[<span class="string">&quot;Right&quot;</span>] = <span class="number">4</span>] = <span class="string">&quot;Right&quot;</span>;</span><br><span class="line">&#125;)(Direction || (Direction = &#123;&#125;));</span><br></pre></td></tr></table></figure><h3 id="3-2-const声明的枚举"><a href="#3-2-const声明的枚举" class="headerlink" title="3.2 const声明的枚举"></a>3.2 const声明的枚举</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = Direction.Up;</span><br></pre></td></tr></table></figure><p>会被编译为</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="3-2-联合枚举与枚举成员的类型"><a href="#3-2-联合枚举与枚举成员的类型" class="headerlink" title="3.2 联合枚举与枚举成员的类型"></a>3.2 联合枚举与枚举成员的类型</h3><p><strong>如果枚举成员均有字面量类型组成，那么枚举的每个成员和枚举值本身都可以作为类型来使用</strong></p><ul><li>任何字符串字面量（例如： <code>&quot;foo&quot;</code>， <code>&quot;bar&quot;</code>， <code>&quot;baz&quot;</code>）</li><li>任何数字字面量（例如： <code>1</code>, <code>100</code>）</li><li>应用了一元 <code>-</code>符号的数字字面量（例如： <code>-1</code>, <code>-100</code>）</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> a: Direction</span><br><span class="line"></span><br><span class="line"><span class="built_in">enum</span> Animal &#123;</span><br><span class="line">    Dog,</span><br><span class="line">    Cat</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a = Direction.Up <span class="comment">// ok</span></span><br><span class="line">a = Animal.Dog <span class="comment">// 不能将类型“Animal.Dog”分配给类型“Direction”</span></span><br></pre></td></tr></table></figure><h3 id="3-3-枚举合并"><a href="#3-3-枚举合并" class="headerlink" title="3.3 枚举合并"></a>3.3 枚举合并</h3><p>如果基于之前的Direction再定义了一个枚举类型的Direction，会合并成一整个</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Direction &#123;</span><br><span class="line">    Center = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-接口-interface"><a href="#5-接口-interface" class="headerlink" title="5.接口(interface)"></a>5.接口(interface)</h2><h3 id="5-1-属性修饰符"><a href="#5-1-属性修饰符" class="headerlink" title="5.1 属性修饰符"></a>5.1 属性修饰符</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">    age?: <span class="built_in">number</span></span><br><span class="line">    <span class="keyword">readonly</span> isMale: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>?：<strong>可选</strong>属性</li><li>readonly：<strong>只读</strong>属性</li></ul><h3 id="5-2-属性检查"><a href="#5-2-属性检查" class="headerlink" title="5.2 属性检查"></a>5.2 属性检查</h3><p>下面这个程序已经正确地类型化了，因为<code>width</code>属性是兼容的，不存在<code>color</code>属性，而且额外的<code>colour</code>属性是无意义的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Config &#123;</span><br><span class="line">    color?: <span class="built_in">string</span>;</span><br><span class="line">    width?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span>(<span class="params">config: Config</span>): </span>&#123; color: <span class="built_in">string</span>; area: <span class="built_in">number</span> &#125; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error: &#x27;colour&#x27; not expected in type &#x27;Config&#x27;</span></span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(&#123; <span class="attr">colour</span>: <span class="string">&quot;red&quot;</span>, <span class="attr">width</span>: <span class="number">100</span> &#125;);</span><br></pre></td></tr></table></figure><p>注意我们传入的参数是 <code>colour</code>，并不是 <code>color</code></p><blockquote><p>官方文档给了三种方式绕过这种检查</p></blockquote><p>第一种使用类型断言：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySquare = createSquare(&#123; <span class="attr">colour</span>: <span class="string">&quot;red&quot;</span>, <span class="attr">width</span>: <span class="number">100</span> &#125; <span class="keyword">as</span> Config);</span><br></pre></td></tr></table></figure><p>第二种添加字符串索引签名：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Config &#123;</span><br><span class="line">    color?: <span class="built_in">string</span>;</span><br><span class="line">    width?: <span class="built_in">number</span>;</span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样Config可以有任意数量的属性，并且只要不是width或color，那么就无所谓他们的类型是什么了。</p><p>第三种将字面量赋值给另外一个变量：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> options: <span class="built_in">any</span> = &#123; <span class="attr">widdth</span>: <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> mySquare = CalculateAreas(options);</span><br></pre></td></tr></table></figure><h3 id="5-3-可索引类型"><a href="#5-3-可索引类型" class="headerlink" title="5.3 可索引类型"></a>5.3 可索引类型</h3><p>​    TypeScript支持两种索引签名：<strong>字符串</strong>和<strong>数字</strong>。 可以同时使用两种类型的索引，但是<strong>数字索引的返回值必须是字符串索引返回值类型的子类型</strong>。 这是因为当使用 <code>number</code>来索引时，JavaScript会将它转换成<code>string</code>然后再去索引对象。 也就是说用 <code>100</code>（一个<code>number</code>）去索引等同于使用<code>&quot;100&quot;</code>（一个<code>string</code>）去索引，因此两者需要保持一致。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    breed: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!</span></span><br><span class="line"><span class="keyword">interface</span> NotOkay &#123;</span><br><span class="line">    [x: <span class="built_in">number</span>]: Animal;</span><br><span class="line">    [x: <span class="built_in">string</span>]: Dog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="索引类型查询操作符"><a href="#索引类型查询操作符" class="headerlink" title="索引类型查询操作符"></a>索引类型查询操作符</h4><p><code>keyof</code>，即索引类型查询操作符，我们可以用 keyof 作用于泛型<code>T</code>上来获取泛型T上的所有 public 属性名构成联合类型。举个例子，有一个Images类，包含<code>src</code>和<code>alt</code>两个public属性，我们用<code>keyof</code>取属性名：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Images</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> src: <span class="built_in">string</span> = <span class="string">&#x27;https://www.google.com.hk/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png&#x27;</span></span><br><span class="line">    <span class="keyword">public</span> alt: <span class="built_in">string</span> = <span class="string">&#x27;谷歌&#x27;</span></span><br><span class="line">    <span class="keyword">public</span> width: <span class="built_in">number</span> = <span class="number">500</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> propsNames = keyof Images</span><br></pre></td></tr></table></figure><p>效果如下：<br>![2019-06-26-06-17-29](D:\OneDrive - mail2.gdut.edu.cn\typora_img\Typescript语法篇\16dbb13efd03fd86)<br><code>keyof</code> 正是赋予了开发者查询索引类型的能力。</p><h4 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h4><p>映射类型的语法是<code>[K in Keys]</code>如果我们要把所有的属性成员变为可选类型，那么需要<code>T[K]</code>取出相应的属性值，最后我们重新生成一个可选的新类型<code>&#123; [K in keyof T]?: T[K] &#125;</code>。</p><p>用类型别名表示就是：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> partial&lt;T&gt; = &#123; [K <span class="keyword">in</span> keyof T]?: T[K] &#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-继承接口"><a href="#5-4-继承接口" class="headerlink" title="5.4 继承接口"></a>5.4 继承接口</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> VIPUser <span class="keyword">extends</span> User &#123;</span><br><span class="line">    broadcast: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>VIPUser具有User所有的属性</p><h2 id="6-类-Class"><a href="#6-类-Class" class="headerlink" title="6.类(Class)"></a>6.类(Class)</h2><h3 id="6-1抽象类"><a href="#6-1抽象类" class="headerlink" title="6.1抽象类"></a>6.1抽象类</h3><blockquote><p>通常作为派生类的基类使用，与接口不同的是抽象类可以包含成员的实现</p></blockquote><p>下面定义了一个Animal抽象类</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> makeSound(): <span class="built_in">void</span>;</span><br><span class="line">    move(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;roaming the earch...&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果直接实例化Animal抽象类则会报错，我们可以创建子类继承基类，然后实例化子类</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">makeSound</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;miao miao&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> Cat()</span><br><span class="line"></span><br><span class="line">cat.makeSound() <span class="comment">// miao miao</span></span><br><span class="line">cat.move() <span class="comment">// roaming the earch...</span></span><br></pre></td></tr></table></figure><h3 id="6-2-访问限定符"><a href="#6-2-访问限定符" class="headerlink" title="6.2 访问限定符"></a>6.2 访问限定符</h3><ol><li>public<ul><li>类的成员默认为public</li><li>可被外部访问</li></ul></li><li>private<ul><li>只能类<strong>内部</strong>访问</li></ul></li><li>protected<ul><li>只能被类的<strong>内部</strong>以及类的<strong>子类</strong>访问</li></ul></li></ol><h3 id="6-3-存取器"><a href="#6-3-存取器" class="headerlink" title="6.3 存取器"></a>6.3 存取器</h3><p>属性具有get和set修饰符，<strong>只带有<code>get</code>不带有<code>set</code>的存取器自动被推断为<code>readonly</code></strong></p><h2 id="7-函数-Function"><a href="#7-函数-Function" class="headerlink" title="7. 函数(Function)"></a>7. 函数(Function)</h2><h3 id="7-1-函数类型"><a href="#7-1-函数类型" class="headerlink" title="7.1 函数类型"></a>7.1 函数类型</h3><p>在小括号后面声明返回值类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用接口定义函数的形状<br>我们也可以使用接口的方式来定义一个函数需要符合的形状：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc &#123;</span><br><span class="line">    (source: <span class="built_in">string</span>, <span class="attr">subString</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> source.search(subString) !== -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用函数表达式|接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变。</p><h3 id="7-2-可选参数"><a href="#7-2-可选参数" class="headerlink" title="7.2 可选参数"></a>7.2 可选参数</h3><p>利用<code>?</code>或则<code>默认值</code>设置可选参数，<strong>？可选参数必须放最后</strong>，<strong>默认值没必要放最后，但是不放最后必须使用undefined显式获取默认值</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>, y?: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-剩余参数"><a href="#7-3-剩余参数" class="headerlink" title="7.3 剩余参数"></a>7.3 剩余参数</h3><p>剩余参数与JavaScript种的语法类似，需要用<code>...</code>来表示剩余参数，而剩余参数<code>rest</code>则是一个由number组成的数组，在本函数中用 reduce 进行了累加求和。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const add &#x3D; (a: number, ...rest: number[]) &#x3D;&gt; rest.reduce(((a, b) &#x3D;&gt; a + b), a)</span><br></pre></td></tr></table></figure><h3 id="7-4-this参数"><a href="#7-4-this参数" class="headerlink" title="7.4 this参数"></a>7.4 this参数</h3><p>如果直接使用this进行一些操作,typescript会进行报错，可以提供一个显式的<code>this</code>参数,该参数是假的,但是可以使重用变得清晰</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Deck &#123;</span><br><span class="line">    suits: <span class="built_in">string</span>[];</span><br><span class="line">    createCardPicker(<span class="built_in">this</span>: Deck): <span class="function">() =&gt;</span> <span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> deck: Deck = &#123;</span><br><span class="line">    suits: [<span class="string">&quot;hearts&quot;</span>, <span class="string">&quot;spades&quot;</span>, <span class="string">&quot;clubs&quot;</span>, <span class="string">&quot;diamonds&quot;</span>],</span><br><span class="line">    <span class="comment">// 注意:这个函数现在显式地指定它的被调用者必须是Deck类型</span></span><br><span class="line">    createCardPicker: <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">this</span>: Deck</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.suits;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-5-重载-Overload"><a href="#7-5-重载-Overload" class="headerlink" title="7.5 重载(Overload)"></a>7.5 重载(Overload)</h3><p>函数根据传入不同的参数而返回不同类型的数据<br>查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个</p><p>下面的assigned只能传递1、2、4个参数,用重载可以很好的对不同的参数列表进行检测</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重载</span></span><br><span class="line"><span class="keyword">interface</span> Direction &#123;</span><br><span class="line">  top: <span class="built_in">number</span>,</span><br><span class="line">  bottom?: <span class="built_in">number</span>,</span><br><span class="line">  left?: <span class="built_in">number</span>,</span><br><span class="line">  right?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assigned</span>(<span class="params">all: <span class="built_in">number</span></span>): <span class="title">Direction</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">assigned</span>(<span class="params">topAndBottom: <span class="built_in">number</span>, leftAndRight: <span class="built_in">number</span></span>): <span class="title">Direction</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">assigned</span>(<span class="params">top: <span class="built_in">number</span>, right: <span class="built_in">number</span>, bottom: <span class="built_in">number</span>, left: <span class="built_in">number</span></span>): <span class="title">Direction</span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">assigned</span> (<span class="params">a: <span class="built_in">number</span>, b?: <span class="built_in">number</span>, c?: <span class="built_in">number</span>, d?: <span class="built_in">number</span></span>) </span>&#123;</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function">  <span class="title">if</span> (<span class="params">b === <span class="literal">undefined</span> &amp;&amp; c === <span class="literal">undefined</span> &amp;&amp; d === <span class="literal">undefined</span></span>) </span>&#123;</span></span></span><br><span class="line"><span class="function"><span class="function">    <span class="title">b</span> = <span class="title">c</span> = <span class="title">d</span> = <span class="title">a</span></span></span></span><br><span class="line"><span class="function"><span class="function">  &#125; <span class="title">else</span> <span class="title">if</span> (<span class="params">c === <span class="literal">undefined</span> &amp;&amp; d === <span class="literal">undefined</span></span>) </span>&#123;</span></span><br><span class="line"><span class="function">    <span class="title">c</span> = <span class="title">a</span></span></span><br><span class="line"><span class="function">    <span class="title">d</span> = <span class="title">b</span></span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">  <span class="title">return</span> </span>&#123;</span><br><span class="line">    top: a,</span><br><span class="line">    right: b,</span><br><span class="line">    bottom: c,</span><br><span class="line">    left: d</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assigned(<span class="number">1</span>)</span><br><span class="line">assigned(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">assigned(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)<span class="comment">// 报错</span></span><br><span class="line">assigned(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure><h2 id="8-泛型-generic"><a href="#8-泛型-generic" class="headerlink" title="8. 泛型(generic)"></a>8. 泛型(generic)</h2><p>下图<code>T</code>为一种类型变量，用于表示一种类型而不是值，我们给identity添加了类型变量<code>T</code>。 <code>T</code>帮助我们捕获用户传入的类型（比如：<code>number</code>）。之后我们再次使用了<code>T</code>当做返回值类型，现在我们知道identity的参数类型和放回置类型是相同的了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-1-泛型接口"><a href="#8-1-泛型接口" class="headerlink" title="8.1 泛型接口"></a>8.1 泛型接口</h3><p>下图的<code>T</code>为整个接口的一个参数，而再使用<code>GenericIdentityFn</code>时，还得传入一个类型参数来指定泛型类型（这里是：<code>number</code>）</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> GenericIdentityFn&lt;T&gt; &#123;</span><br><span class="line">    (arg: T): T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: GenericIdentityFn&lt;<span class="built_in">number</span>&gt; = identity;</span><br></pre></td></tr></table></figure><h3 id="8-2-泛型类"><a href="#8-2-泛型类" class="headerlink" title="8.2 泛型类"></a>8.2 泛型类</h3><p>与接口一样，直接把泛型类型放在类后面</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericNumber</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    zeroValue: T;</span><br><span class="line">    add: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGenericNumber = <span class="keyword">new</span> GenericNumber&lt;<span class="built_in">number</span>&gt;();</span><br></pre></td></tr></table></figure><h3 id="8-3-泛型约束"><a href="#8-3-泛型约束" class="headerlink" title="8.3 泛型约束"></a>8.3 泛型约束</h3><p>下面例子想要访问arg.length属性，但是是编译器并不能证明每种类型都有<code>length</code>属性，所以就报错了</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length);  <span class="comment">// Error: T doesn&#x27;t have .length</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以定义一个接口来描述约束条件，然后需要传入符合约束类型的值，必须包含必须的属性</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Lengthwise &#123;</span><br><span class="line">    length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Lengthwise</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length);  <span class="comment">// Now we know it has a .length property, so no more error</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loggingIdentity(<span class="number">3</span>);  <span class="comment">// Error, number doesn&#x27;t have a .length property</span></span><br><span class="line">loggingIdentity(&#123;<span class="attr">length</span>: <span class="number">10</span>, <span class="attr">value</span>: <span class="number">3</span>&#125;); <span class="comment">// right</span></span><br></pre></td></tr></table></figure><h3 id="8-4-多重类型进行泛型约束"><a href="#8-4-多重类型进行泛型约束" class="headerlink" title="8.4 多重类型进行泛型约束"></a>8.4 多重类型进行泛型约束</h3><p>用<strong>交叉类型</strong><code>&amp;</code>进行多重约束</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> FirstInterface &#123;</span><br><span class="line">  doSomething(): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> SecondInterface &#123;</span><br><span class="line">  doSomethingElse(): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">FirstInterface</span> &amp; <span class="title">SecondInterface</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> genericProperty: T</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">useT</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.genericProperty.doSomething() <span class="comment">// right</span></span><br><span class="line">    <span class="built_in">this</span>.genericProperty.doSomethingElse() <span class="comment">// right</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-5-泛型里使用类类型"><a href="#8-5-泛型里使用类类型" class="headerlink" title="8.5 泛型里使用类类型"></a>8.5 泛型里使用类类型</h3><p>我们假设需要声明一个泛型拥有构造函数，比如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">type</span>: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">type</span>() <span class="comment">// This expression is not constructable.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样会报错，因为我们没有声明<code>T</code>是构造函数，我们需要显式的用<code>new</code>来声明这个泛型<code>T</code>是构造函数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">type</span>: &#123;<span class="keyword">new</span>(): T&#125;</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">type</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数<code>type</code>的类型<code>&#123;new(): T&#125;</code>就表示此泛型<code>T</code>是可被构造的，在被实例化后的类型是泛型<code>T</code></p><p>一个更高级的例子，使用原型属性推断并约束构造函数与类实例的关系。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeeKeeper</span> </span>&#123;</span><br><span class="line">    hasMask: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZooKeeper</span> </span>&#123;</span><br><span class="line">    nametag: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    numLegs: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bee</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    keeper: BeeKeeper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lion</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    keeper: ZooKeeper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createInstance</span>&lt;<span class="title">A</span> <span class="title">extends</span> <span class="title">Animal</span>&gt;(<span class="params">c: <span class="keyword">new</span> () =&gt; A</span>): <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createInstance(Lion).keeper.nametag;  <span class="comment">// typechecks!</span></span><br><span class="line">createInstance(Bee).keeper.hasMask;   <span class="comment">// typechecks!</span></span><br></pre></td></tr></table></figure><h2 id="9-类型兼容性"><a href="#9-类型兼容性" class="headerlink" title="9. 类型兼容性"></a>9. 类型兼容性</h2><p>Ts结构化类型系统的基本规则是，如果<code>x</code>要兼容<code>y</code>，那么<code>y</code>至少具有与<code>x</code>相同的属性，编译器会检查<code>x</code>中的每个属性，看是否能在<code>y</code>中也找到对应属性</p><h2 id="10-高级类型"><a href="#10-高级类型" class="headerlink" title="10. 高级类型"></a>10. 高级类型</h2><h3 id="10-1-交叉类型"><a href="#10-1-交叉类型" class="headerlink" title="10.1 交叉类型"></a>10.1 交叉类型</h3><p>用<code>&amp;</code>可以将多个类型合并为一个类型</p><h3 id="10-2-联合类型"><a href="#10-2-联合类型" class="headerlink" title="10.2 联合类型"></a>10.2 联合类型</h3><p>用<code>|</code>表示一个值可为几种类型之一</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatCommandline</span>(<span class="params">command: <span class="built_in">string</span>[] | <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> line = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> command === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    line = command.trim();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    line = command.join(<span class="string">&#x27; &#x27;</span>).trim();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-3-类型别名"><a href="#10-3-类型别名" class="headerlink" title="10.3 类型别名"></a>10.3 类型别名</h3><p><code>type</code>虽然看起来和interface一样，但是可以用在原始类型、联合类型、元组等需要手写的类型，<strong>类型别名也可以是泛型</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> some = <span class="built_in">boolean</span> | <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b: some = <span class="literal">true</span> <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">const</span> c: some = <span class="string">&#x27;hello&#x27;</span> <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">const</span> d: some = <span class="number">123</span> <span class="comment">// 不能将类型“123”分配给类型“some”</span></span><br></pre></td></tr></table></figure><p>类型别名和接口的区别</p><ol><li>类型别名不能被<code>extends</code>和<code>implements</code>（自己也不能<code>extends</code>和<code>implements</code>其它类型）</li><li>interface 可以实现接口合并声明</li></ol><h3 id="10-4-条件类型"><a href="#10-4-条件类型" class="headerlink" title="10.4 条件类型"></a>10.4 条件类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T <span class="keyword">extends</span> U ? X : Y</span><br></pre></td></tr></table></figure><p>上面的代码可以理解为: 若 <code>T</code> 能够赋值给 <code>U</code>，那么类型是 <code>X</code>，否则为 <code>Y</code>,有点类似于JavaScript中的三元条件运算符</p><h2 id="11-类型保护和类型断言"><a href="#11-类型保护和类型断言" class="headerlink" title="11. 类型保护和类型断言"></a>11. 类型保护和类型断言</h2><h3 id="11-1-！"><a href="#11-1-！" class="headerlink" title="11.1 ！"></a>11.1 ！</h3><blockquote><p>类型检查器认为 <code>null</code>与 <code>undefined</code>可以赋值给任何类型</p></blockquote><p>可以使用<code>--strictNullChecks</code>来使变量不自动的包含<code>null</code>或 <code>undefined</code>，但是开启后可选参数会被自动地加上<code>| undefined</code>。</p><p>如果编译器不能够去除 <code>null</code>或 <code>undefined</code>，你可以使用<strong>类型断言</strong>手动去除。 语法是添加<code>!</code>后缀： <code>identifier!</code>从 <code>identifier</code>的类型里去除了 <code>null</code>和 <code>undefined</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">broken</span>(<span class="params">name: <span class="built_in">string</span> | <span class="literal">null</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">postfix</span>(<span class="params">epithet: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name.charAt(<span class="number">0</span>) + <span class="string">&#x27;.  the &#x27;</span> + epithet; <span class="comment">// error, &#x27;name&#x27; is possibly null</span></span><br><span class="line">  &#125;</span><br><span class="line">  name = name || <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> postfix(<span class="string">&quot;great&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fixed</span>(<span class="params">name: <span class="built_in">string</span> | <span class="literal">null</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">postfix</span>(<span class="params">epithet: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name!.charAt(<span class="number">0</span>) + <span class="string">&#x27;.  the &#x27;</span> + epithet; <span class="comment">// ok</span></span><br><span class="line">  &#125;</span><br><span class="line">  name = name || <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> postfix(<span class="string">&quot;great&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-2-is进行类型保护"><a href="#11-2-is进行类型保护" class="headerlink" title="11.2 is进行类型保护"></a>11.2 is进行类型保护</h3><p>is之后的类型必须是参数类型中的一个，在后续调用改参数时，ts会将变量缩减为那个具体的类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isString</span>(<span class="params">test: <span class="built_in">any</span></span>): <span class="title">test</span> <span class="title">is</span> <span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> test === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params">foo: <span class="built_in">number</span> | <span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isString(foo))&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;it is a string&#x27;</span> + foo);</span><br><span class="line">        <span class="comment">// 如果上面没写test is string，foo.length将会报错</span></span><br><span class="line">        <span class="built_in">console</span>.log(foo.length); <span class="comment">// string function</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">example(<span class="string">&#x27;hello world&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.tslang.cn/docs/handbook">https://www.tslang.cn/docs/handbook</a><br><a href="https://ts.xcatliu.com/basics/type-of-function.html">https://ts.xcatliu.com/basics/type-of-function.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-typescript的原始类型&quot;&gt;&lt;a href=&quot;#1-typescript的原始类型&quot; class=&quot;headerlink&quot; title=&quot;1.typescript的原始类型&quot;&gt;&lt;/a&gt;1.typescript的原始类型&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;bool
      
    
    </summary>
    
    
      <category term="前端" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="ts" scheme="https://liang5757.github.io/tags/ts/"/>
    
  </entry>
  
  <entry>
    <title>学习css的网站</title>
    <link href="https://liang5757.github.io/2020/09/20/Css/%E5%AD%A6%E4%B9%A0css%E7%9A%84%E7%BD%91%E7%AB%99/"/>
    <id>https://liang5757.github.io/2020/09/20/Css/%E5%AD%A6%E4%B9%A0css%E7%9A%84%E7%BD%91%E7%AB%99/</id>
    <published>2020-09-20T08:42:39.000Z</published>
    <updated>2020-11-27T14:41:18.049Z</updated>
    
    <content type="html"><![CDATA[<p>codepen：<a href="https://codepen.io/">https://codepen.io/</a><br>css常见布局：<a href="https://csslayout.io/patterns/">https://csslayout.io/patterns/</a><br>常见加载动画：<a href="https://tobiasahlin.com/spinkit/">https://tobiasahlin.com/spinkit/</a><br>常见css效果：<a href="https://emilkowalski.github.io/css-effects-snippets/">https://emilkowalski.github.io/css-effects-snippets/</a><br>css灵感：<a href="https://chokcoco.github.io/CSS-Inspiration/#/">https://chokcoco.github.io/CSS-Inspiration/#/</a><br>自定义css组件：<a href="https://animista.net/">https://animista.net/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;codepen：&lt;a href=&quot;https://codepen.io/&quot;&gt;https://codepen.io/&lt;/a&gt;&lt;br&gt;css常见布局：&lt;a href=&quot;https://csslayout.io/patterns/&quot;&gt;https://csslayout.io/pa
      
    
    </summary>
    
    
      <category term="前端" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS" scheme="https://liang5757.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>EventBus的一种使用场景</title>
    <link href="https://liang5757.github.io/2020/09/17/%E5%89%8D%E7%AB%AF%E5%AE%9E%E6%88%98%E6%8A%80%E5%B7%A7/EventBus%E7%9A%84%E4%B8%80%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>https://liang5757.github.io/2020/09/17/%E5%89%8D%E7%AB%AF%E5%AE%9E%E6%88%98%E6%8A%80%E5%B7%A7/EventBus%E7%9A%84%E4%B8%80%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</id>
    <published>2020-09-17T11:38:58.000Z</published>
    <updated>2020-11-27T14:45:45.937Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>所谓事件总线，就是实例化Vue对象，在该实例上通过<code>$on</code>绑定事件、<code>$emit</code>触发事件、<code>$off</code>解绑事件，进行组件通信。</p></blockquote><h2 id="一、使用"><a href="#一、使用" class="headerlink" title="一、使用"></a>一、使用</h2><p>实例化Vue对象，并挂载到Vue.prototype</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$bus = <span class="keyword">new</span> Vue();</span><br></pre></td></tr></table></figure><h2 id="二、场景"><a href="#二、场景" class="headerlink" title="二、场景"></a>二、场景</h2><blockquote><p>在多个页面复用一个组件时，每个页面需要有点击按钮后，触发不同的事件</p></blockquote><p>当然可以监听路由进行判断调用不同的函数，但是这样会在一个组件内写上很多其他组件应该触发的事件。</p><p><strong>我们利用EventBus可以做到组件间的解耦</strong></p><h2 id="三、使用方法"><a href="#三、使用方法" class="headerlink" title="三、使用方法"></a>三、使用方法</h2><p>1.我们在各个页面上写好事件触发后调用的函数，然后在mounted（如果用keep-alive则是在activated，否则只挂载一次）<code>this.$bus.$on</code>上绑定该事件，在beforeDestory（如果用keep-alive则是在deactived，否则无法解绑事件）上用<code>this.$bus.$off</code>解绑事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$bus.$on(<span class="string">&quot;save&quot;</span>, <span class="built_in">this</span>.save);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">beforeDestory</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$bus.$off(<span class="string">&quot;save&quot;</span>, <span class="built_in">this</span>.save);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">save</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我没有写在复用组件上哦！&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.然后在复用的组件上触发事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$bus.$emit(&#39;save&#39;);</span><br></pre></td></tr></table></figure><p>也算是第一次尝试使用EventBus把，很好的降低了组件间的耦合度</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;所谓事件总线，就是实例化Vue对象，在该实例上通过&lt;code&gt;$on&lt;/code&gt;绑定事件、&lt;code&gt;$emit&lt;/code&gt;触发事件、&lt;code&gt;$off&lt;/code&gt;解绑事件，进行组件通信。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=
      
    
    </summary>
    
    
      <category term="前端" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="技巧" scheme="https://liang5757.github.io/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="vue" scheme="https://liang5757.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>对于点歌台总结vuex持久化处理的补充</title>
    <link href="https://liang5757.github.io/2020/09/16/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%AF%B9%E4%BA%8E%E7%82%B9%E6%AD%8C%E5%8F%B0%E6%80%BB%E7%BB%93vuex%E6%8C%81%E4%B9%85%E5%8C%96%E5%A4%84%E7%90%86%E7%9A%84%E8%A1%A5%E5%85%85/"/>
    <id>https://liang5757.github.io/2020/09/16/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%AF%B9%E4%BA%8E%E7%82%B9%E6%AD%8C%E5%8F%B0%E6%80%BB%E7%BB%93vuex%E6%8C%81%E4%B9%85%E5%8C%96%E5%A4%84%E7%90%86%E7%9A%84%E8%A1%A5%E5%85%85/</id>
    <published>2020-09-16T12:25:18.000Z</published>
    <updated>2020-11-27T14:45:06.153Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>针对刷新时vuex数据丢失，使用了vuex-persistedstate对vuex进行持久化处理<br>官方github：<a href="https://github.com/robinvdvleuten/vuex-persistedstate">https://github.com/robinvdvleuten/vuex-persistedstate</a></p></blockquote><p>本文主要是对官网不够详细的案例进行补充，官网只讲了对vuex完全存储和对vuex模块的完全存储。<br>但是我想对某一模块内部一些变量进行存储，谷歌了好多都没找到写法，自己试出来了。</p><ol><li>首先引入vuex-persistedstate</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> createPersistedState <span class="keyword">from</span> <span class="string">&quot;vuex-persistedstate&quot;</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>利用官网给的reducer减少持久化的数据</li></ol><p><img src= "/img/loading.gif" data-src="/2020/09/16/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%AF%B9%E4%BA%8E%E7%82%B9%E6%AD%8C%E5%8F%B0%E6%80%BB%E7%BB%93vuex%E6%8C%81%E4%B9%85%E5%8C%96%E5%A4%84%E7%90%86%E7%9A%84%E8%A1%A5%E5%85%85/image-20200916201819305.png" alt="image-20200916201819305"></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state,</span><br><span class="line">    getters,</span><br><span class="line">    mutations,</span><br><span class="line">    actions,</span><br><span class="line">    modules: &#123;</span><br><span class="line">        projectDetail</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// @ts-ignore</span></span><br><span class="line">    plugins: [createPersistedState(&#123;</span><br><span class="line">        <span class="function"><span class="title">reducer</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                staffId: val.staffId,</span><br><span class="line">                projectDetail: &#123;</span><br><span class="line">                    curPjId: val.projectDetail.curPjId,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以看到该vuex结构具有projectDetail模块，我想对该模块内的curPjId进行<strong>单独</strong>存储，在reducer放回的对象的键设为模块名，里面写着想要持久化的变量，就可以了。</p><p>会在localstorage存储为如下所示</p><p><img src= "/img/loading.gif" data-src="/2020/09/16/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%AF%B9%E4%BA%8E%E7%82%B9%E6%AD%8C%E5%8F%B0%E6%80%BB%E7%BB%93vuex%E6%8C%81%E4%B9%85%E5%8C%96%E5%A4%84%E7%90%86%E7%9A%84%E8%A1%A5%E5%85%85/image-20200916202437681.png" alt="image-20200916202437681"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;针对刷新时vuex数据丢失，使用了vuex-persistedstate对vuex进行持久化处理&lt;br&gt;官方github：&lt;a href=&quot;https://github.com/robinvdvleuten/vuex-persistedstate&quot;
      
    
    </summary>
    
    
      <category term="前端" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="vue" scheme="https://liang5757.github.io/tags/vue/"/>
    
  </entry>
  
</feed>
