<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Liang的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liang5757.github.io/"/>
  <updated>2021-02-27T16:32:42.786Z</updated>
  <id>https://liang5757.github.io/</id>
  
  <author>
    <name>Liang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Koa洋葱原型源码解读</title>
    <link href="https://liang5757.github.io/2021/02/28/node.js/Koa%E6%B4%8B%E8%91%B1%E5%8E%9F%E5%9E%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>https://liang5757.github.io/2021/02/28/node.js/Koa%E6%B4%8B%E8%91%B1%E5%8E%9F%E5%9E%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</id>
    <published>2021-02-27T16:25:27.000Z</published>
    <updated>2021-02-27T16:32:42.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Koa洋葱原型源码解读"><a href="#Koa洋葱原型源码解读" class="headerlink" title="Koa洋葱原型源码解读"></a>Koa洋葱原型源码解读</h1><blockquote><p>版本：2.13.1</p></blockquote><h2 id="application-js"><a href="#application-js" class="headerlink" title="application.js"></a>application.js</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">this</span>.middleware = [];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>有一个<code>middleware</code>存函数</p></blockquote><h3 id="use方法"><a href="#use方法" class="headerlink" title="use方法"></a>use方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">use</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">this</span>.middleware.push(fn);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次使用app.use()就会吧回调函数push到<code>middleware</code>里</p><h3 id="listen方法"><a href="#listen方法" class="headerlink" title="listen方法"></a>listen方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">listen</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> server = http.createServer(<span class="built_in">this</span>.callback());</span><br><span class="line">    <span class="keyword">return</span> server.listen(...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个服务，执行callback方法</p><h3 id="callback和handleRequest方法"><a href="#callback和handleRequest方法" class="headerlink" title="callback和handleRequest方法"></a>callback和handleRequest方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">callback</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fn = compose(<span class="built_in">this</span>.middleware);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.listenerCount(<span class="string">&#x27;error&#x27;</span>)) <span class="built_in">this</span>.on(<span class="string">&#x27;error&#x27;</span>, <span class="built_in">this</span>.onerror);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleRequest = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> ctx = <span class="built_in">this</span>.createContext(req, res); <span class="comment">// node 原生的 req、res 对象把其中的属性挂载到 ctx 上</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.handleRequest(ctx, fn); <span class="comment">// 调用</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> handleRequest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">handleRequest</span>(<span class="params">ctx, fnMiddleware</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = ctx.res;</span><br><span class="line">    <span class="keyword">const</span> onerror = <span class="function"><span class="params">err</span> =&gt;</span> ctx.onerror(err);</span><br><span class="line">    <span class="comment">// 处理响应</span></span><br><span class="line">    <span class="keyword">const</span> handleResponse = <span class="function">() =&gt;</span> respond(ctx);</span><br><span class="line">    <span class="keyword">return</span> fnMiddleware(ctx).then(handleResponse).catch(onerror);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>compse函数返回一个中间件函数，在handleRequest执行中间件函数，如果全部 resolve 了就可以调用 handleResponse 发送给客户端</p><p>本片博客的重点就是compose是怎么实现koa的洋葱模型的</p><h2 id="koa-compose-js"><a href="#koa-compose-js" class="headerlink" title="koa-compose.js"></a>koa-compose.js</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="compose函数"><a href="#compose函数" class="headerlink" title="compose函数"></a>compose函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span> (<span class="params">middleware</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> <span class="variable">context</span></span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;Promise&#125;</span></span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@api <span class="variable">public</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">context, next</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// last called middleware #</span></span><br><span class="line">        <span class="keyword">let</span> index = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dispatch(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= index)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;next() called multiple times&#x27;</span>))</span><br><span class="line">            index = i</span><br><span class="line">            <span class="keyword">let</span> fn = middleware[i]</span><br><span class="line">            <span class="keyword">if</span> (i === middleware.length) fn = next</span><br><span class="line">            <span class="keyword">if</span> (!fn) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(fn(context, dispatch.bind(<span class="literal">null</span>, i + <span class="number">1</span>)));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>compose</code>函数接收<code>middleware</code>数组，<code>dispatch(0)</code>即开始分发一号中间件。</p></li><li><p><code>dispatch(0)</code>内部，此时 fn 为一号中间件，会走到 try/catch 块，尝试执行<code>Promise.resolve(fn(context, dispatch.bind(null, i + 1)))</code>，即一号中间件此时获得入参<code>context</code>、<code>dispatch(1)</code>。</p></li><li><p>一号中间件开始执行，遇到 next()（即dispatch(1)），控制权移交，执行 dispatch(1)，此时二号中间件获得入参<code>context</code>、<code>dispatch(2)</code>。</p></li><li><p>二号中间件开始执行，执行到<code>await next()</code>时，再重复上述逻辑，dispatch(2)，但是这一次会停在这里：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = middleware[i];</span><br><span class="line"><span class="keyword">if</span> (i === middleware.length) fn = next;</span><br><span class="line"><span class="keyword">if</span> (!fn) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br></pre></td></tr></table></figure><p>  fn = next，这里的 next 由于并没有值，所以会直接 return 一个立即 resolve 的 Promise。也就是说二号中间件内部的 await next()会立刻返回。</p></li><li><p>二号中间件做完自己的事后，相当于一号中间件内部的<code>await next()</code>返回了，因此控制权就归还给一号中间件。</p></li></ul><h2 id="如果中间件中的next-方法报错了怎么办。"><a href="#如果中间件中的next-方法报错了怎么办。" class="headerlink" title="如果中间件中的next()方法报错了怎么办。"></a>如果中间件中的<code>next()</code>方法报错了怎么办。</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ctx.onerror = <span class="function"><span class="keyword">function</span> </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.app.emit(<span class="string">&#x27;error&#x27;</span>, err, <span class="built_in">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">listen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span>  fnMiddleware = compose(<span class="built_in">this</span>.middleware);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.listenerCount(<span class="string">&#x27;error&#x27;</span>)) <span class="built_in">this</span>.on(<span class="string">&#x27;error&#x27;</span>, <span class="built_in">this</span>.onerror);</span><br><span class="line">    <span class="keyword">const</span> onerror = <span class="function"><span class="params">err</span> =&gt;</span> ctx.onerror(err);</span><br><span class="line">    fnMiddleware(ctx).then(handleResponse).catch(onerror);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">onerror</span>(<span class="params">err</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 代码省略</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：中间件链错误会由<code>ctx.onerror</code>捕获，该函数中会调用<code>this.app.emit(&#39;error&#39;, err, this)</code>（因为<code>koa</code>继承自<code>Emitter</code>，所以有<code>emit</code>和<code>on</code>等方法），可以使用<code>app.on(&#39;error&#39;, (err) =&gt; &#123;&#125;)</code>，或者<code>app.onerror = (err) =&gt; &#123;&#125;</code>进行捕获。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://juejin.cn/post/6844904088220467213#heading-16">https://juejin.cn/post/6844904088220467213#heading-16</a><br><a href="https://linbudu.top/posts/2020/02/25/koa%E6%BA%90%E7%A0%81%E7%B2%BE%E8%AF%BB.html#new-%E4%B8%80%E4%B8%AA-koa-%EF%BC%8C%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F">https://linbudu.top/posts/2020/02/25/koa%E6%BA%90%E7%A0%81%E7%B2%BE%E8%AF%BB.html#new-%E4%B8%80%E4%B8%AA-koa-%EF%BC%8C%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Koa洋葱原型源码解读&quot;&gt;&lt;a href=&quot;#Koa洋葱原型源码解读&quot; class=&quot;headerlink&quot; title=&quot;Koa洋葱原型源码解读&quot;&gt;&lt;/a&gt;Koa洋葱原型源码解读&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;版本：2.13.1&lt;/p&gt;
&lt;/block
      
    
    </summary>
    
    
      <category term="后端" scheme="https://liang5757.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="node.js" scheme="https://liang5757.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>尤雨溪frontend Master课程笔记</title>
    <link href="https://liang5757.github.io/2021/02/18/Vue/%E5%B0%A4%E9%9B%A8%E6%BA%AAfrontend%20Master%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <id>https://liang5757.github.io/2021/02/18/Vue/%E5%B0%A4%E9%9B%A8%E6%BA%AAfrontend%20Master%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</id>
    <published>2021-02-17T18:46:31.000Z</published>
    <updated>2021-02-17T18:47:34.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="尤雨溪Frontend-Master课程笔记"><a href="#尤雨溪Frontend-Master课程笔记" class="headerlink" title="尤雨溪Frontend Master课程笔记"></a>尤雨溪Frontend Master课程笔记</h1><h2 id="1-响应式"><a href="#1-响应式" class="headerlink" title="1.响应式"></a>1.响应式</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>实现一个神奇的函数auto，会在<code>state.count</code>改变后，自动运行里面的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">autoRun(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;app&quot;</span>).innerText = state.count;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">state.count++; <span class="comment">// 重新执行autoRun内的函数</span></span><br></pre></td></tr></table></figure><h3 id="第一步-getter和setter"><a href="#第一步-getter和setter" class="headerlink" title="第一步 getter和setter"></a>第一步 getter和setter</h3><p>需要能监听到对象内属性的改变</p><h4 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;</span><br><span class="line">observer(obj);</span><br><span class="line">obj.foo <span class="comment">// 需要打印: &#x27;getting key &quot;foo&quot;: 123&#x27;</span></span><br><span class="line">obj.foo = <span class="number">234</span> <span class="comment">// 需要打印: &#x27;setting key &quot;foo&quot; to 234&#x27;</span></span><br><span class="line">obj.foo <span class="comment">// 需要打印: &#x27;getting key &quot;foo&quot;: 234&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 保存属性初始值</span></span><br><span class="line">    <span class="keyword">let</span> internalValue = obj[key]</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">      get () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`getting key &quot;<span class="subst">$&#123;key&#125;</span>&quot;: <span class="subst">$&#123;internalValue&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">return</span> internalValue</span><br><span class="line">      &#125;,</span><br><span class="line">      set (newValue) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`setting key &quot;<span class="subst">$&#123;key&#125;</span>&quot; to: <span class="subst">$&#123;newValue&#125;</span>`</span>)</span><br><span class="line">        internalValue = newValue</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二步-依赖收集-Dep"><a href="#第二步-依赖收集-Dep" class="headerlink" title="第二步 依赖收集 Dep"></a>第二步 依赖收集 Dep</h3><h4 id="实现效果-1"><a href="#实现效果-1" class="headerlink" title="实现效果"></a>实现效果</h4><p>即一个发布订阅模式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line"></span><br><span class="line">autoRun(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  dep.depend()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;updated&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 打印: &quot;updated&quot;</span></span><br><span class="line"></span><br><span class="line">dep.notify()</span><br><span class="line"><span class="comment">// 打印: &quot;updated&quot;</span></span><br></pre></td></tr></table></figure><h4 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs = []</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">depend</span>(<span class="params"></span>)</span> &#123; <span class="comment">// 订阅函数</span></span><br><span class="line">    <span class="keyword">if</span> (activeUpdate) &#123;</span><br><span class="line">      <span class="built_in">this</span>.subs.push(activeUpdate); <span class="comment">// 把全局变量activeUpdate存的函数放入订阅者列表</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">notify</span>(<span class="params"></span>)</span> &#123; <span class="comment">// 发布函数</span></span><br><span class="line">    <span class="built_in">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> sub());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> activeUpdate = <span class="literal">null</span> <span class="comment">// 放置依赖函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">autoRun</span> (<span class="params">update</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> wrappedUpdate = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    activeUpdate = wrappedUpdate <span class="comment">// 把wrappedUpdate存起来</span></span><br><span class="line">    update() <span class="comment">// 在update内部调用dep.depend()收集依赖</span></span><br><span class="line">    activeUpdate = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  wrappedUpdate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三步-整合一、二"><a href="#第三步-整合一、二" class="headerlink" title="第三步 整合一、二"></a>第三步 整合一、二</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs = []</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">depend</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (activeUpdate) &#123;</span><br><span class="line">      <span class="built_in">this</span>.subs.push(activeUpdate);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">notify</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> sub());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">obj</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.dep = <span class="keyword">new</span> Dep();</span><br><span class="line">    <span class="built_in">this</span>.walk(obj);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">walk</span>(<span class="params">obj</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.defineReactive(obj, key);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">defineReactive</span>(<span class="params">obj, key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> internalValue = obj[key];</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">      enumerable: <span class="literal">false</span>,</span><br><span class="line">      configurable: <span class="literal">false</span>,</span><br><span class="line">      <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        that.dep.depend();</span><br><span class="line">        <span class="keyword">return</span> internalValue;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">set</span>(<span class="params">newVal</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> isChanged = internalValue !== newVal;</span><br><span class="line">        <span class="keyword">if</span> (isChanged) &#123;</span><br><span class="line">          internalValue = newVal;</span><br><span class="line">          that.dep.notify();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> activeUpdate = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">autoRun</span> (<span class="params">update</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> wrappedUpdate = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    activeUpdate = wrappedUpdate <span class="comment">// 把wrappedUpdate存起来</span></span><br><span class="line">    update() <span class="comment">// 在update内部调用dep.depend()收集依赖</span></span><br><span class="line">    activeUpdate = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  wrappedUpdate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-虚拟DOM"><a href="#2-虚拟DOM" class="headerlink" title="2. 虚拟DOM"></a>2. 虚拟DOM</h2><h3 id="2-1虚拟DOM和真实的DOM的差异"><a href="#2-1虚拟DOM和真实的DOM的差异" class="headerlink" title="2.1虚拟DOM和真实的DOM的差异"></a>2.1虚拟DOM和真实的DOM的差异</h3><p>1.资源消耗问题</p><p>使用javascript操作真实DOM是非常消耗资源的，虽然很多浏览器做了优化但是效果不大。你看到虚拟DOM是一个纯javascript对象。而DOM节点有70＋个属性，继承层级有6，7层（文本节点6层，元素节点7层）,访问一个属性，可能会追溯几重原型链。</p><p>2.执行效率问题</p><p>如果你要修改一个真实DOM，一般调用<code>innerHTML</code>方法，那浏览器会把旧的节点移除再添加新的节点，但是在虚拟DOM中，只需要修改一个对象的属性，再把虚拟DOM渲染到真实DOM上。很多人会误解虚拟DOM比真实DOM速度快，其实虚拟DOM只是把DOM变更的逻辑提取出来，使用javascript计算差异，减少了操作真实DOM的次数，只在最后一次才操作真实DOM，所以如果你的应用有复杂的DOM变更操作，虚拟DOM会比较快。</p><p>3.虚拟DOM还有其他好处</p><p>其实虚拟DOM还可以应用在其他地方，因为他们只是抽象节点，可以把它编译成其他平台，例如android、ios。市面上利用形同架构模式的应用有React Native，Weeks，Native script，就是利用虚拟DOM的特点实现的。</p><h3 id="2-2-虚拟DOM在线查看"><a href="#2-2-虚拟DOM在线查看" class="headerlink" title="2.2 虚拟DOM在线查看"></a>2.2 虚拟DOM在线查看</h3><p>使用Vue Template Explorer可以查看Vue是如何转换虚拟DOM的。</p><p><a href="https://template-explorer.vuejs.org/">访问地址</a></p><h2 id="3-template和jsx对比"><a href="#3-template和jsx对比" class="headerlink" title="3.template和jsx对比"></a>3.template和jsx对比</h2><p><strong>模版的优势</strong>：模版是一种更静态更具有约束的表现形态，它可以避免发明新语法，任何可以解析HTML的引擎都可以使用它，迁移成本更低；另外最重要的是<strong>静态模版可以在编译进行比较多的优化</strong>，而动态语言就没法实现了。</p><p><strong>jsx的优势</strong>：更灵活，任何的js代码都可以放在jsx中执行实现你想要的效果，但是也<strong>由于他的灵活性导致在编译阶段优化比较困难，只能通过开发者自己优化</strong>。</p><h2 id="4-函数组件"><a href="#4-函数组件" class="headerlink" title="4. 函数组件"></a>4. 函数组件</h2><p>函数组件就是不包含state和props的组件，就像它的名字一样，你可以理解为他就是一个函数，在Vue中声明一个函数组件代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">functional: <span class="literal">true</span>,</span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(<span class="string">&#x27;div&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>组件不支持实例化。</li><li>优化更优，因为在Vue中它的渲染函数比父级组件更早被调用，但是他并不会占用很多资源，因为它没有保存数据和属性，所以它常用于优化一个有很多节点的组件。</li><li>容易扩展，如果你的组件只是用来接收 prop然后显示数据，或者一个没有状态的按钮，建议使用函数组件。</li><li>函数组件没有this，获取prop可以通过render函数的第二参数得到<code>render(h, context)</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;example&#x27;</span>, &#123;</span><br><span class="line">    functional: <span class="literal">true</span>, <span class="comment">// 声明是函数组件</span></span><br><span class="line">    <span class="comment">// 因为函数组件没有this,可以通过render第二参数获取相关信息</span></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params">h, &#123; props: &#123; tags &#125; &#125;</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// context.slots() 通过slots方法获取子节点</span></span><br><span class="line">        <span class="comment">// context.children 获取子组件</span></span><br><span class="line">        <span class="comment">// context.parent 父组件，因为函数组件实挂载到根节点上，也就是&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span></span><br><span class="line">        <span class="comment">// context.props 组件属性，这里得到tags属性</span></span><br><span class="line">        <span class="comment">// return h(&#x27;div&#x27;, this.tags.map((tag, i) =&gt; h(tag, i)))</span></span><br><span class="line">        <span class="comment">// 通过函数组件实现标签动态渲染</span></span><br><span class="line">        <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, tags.map(<span class="function">(<span class="params">tag, i</span>) =&gt;</span> h(tag, i)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="5-HOC-高阶组件"><a href="#5-HOC-高阶组件" class="headerlink" title="5.HOC 高阶组件"></a>5.HOC 高阶组件</h2><blockquote><p>高阶组件是一个函数，接收一个组件，然后返回一个新的组件，类似装饰者模式</p></blockquote><p>这里不展开说了，大概列一下写法，下面模拟了一个图片骨架</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mock API</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchURL</span> (<span class="params">username, cb</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// hard coded, bonus: exercise: make it fetch from gravatar!</span></span><br><span class="line">    cb(<span class="string">&#x27;https://avatars3.githubusercontent.com/u/6128107?v=4&amp;s=200&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">500</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Avatar = &#123;</span><br><span class="line">  props: [<span class="string">&#x27;src&#x27;</span>],</span><br><span class="line">  template: <span class="string">`&lt;img :src=&quot;src&quot;&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withAvatarURL</span> (<span class="params">InnerComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      attrs: <span class="built_in">this</span>.$attrs, <span class="comment">// 2.4 only</span></span><br><span class="line">      username: <span class="built_in">String</span></span><br><span class="line">    &#125;,</span><br><span class="line">    data () &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        url: <span class="string">&#x27;http://via.placeholder.com/200x200&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created () &#123;</span><br><span class="line">      fetchURL(<span class="built_in">this</span>.username, <span class="function">(<span class="params">url</span>) =&gt;</span> &#123; <span class="built_in">this</span>.url = url &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    render (h) &#123;</span><br><span class="line">      <span class="keyword">return</span> h(InnerComponent, &#123; <span class="attr">props</span>: &#123; <span class="attr">src</span>: <span class="built_in">this</span>.url &#125; &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SmartAvatar = withAvatarURL(Avatar)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  components: &#123; SmartAvatar &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li><strong>重用性</strong>：因为minxin对原组件具有侵入性，这会导致原来组件的可重用性降低，而高阶组件不会，高阶组件对原组件只是一个调用关系，并没有修改原来组件任何内容。</li><li><strong>可测试性</strong>：因为高阶组件只是一个嵌套关系，在组件测试的时候，可以单独的测试原始组件和高阶组件。</li><li><strong>层级问题</strong>：高阶组件也有他的弊端，如果你高阶组件嵌套层级太深，会导致出错的时候调试困难的问题，所以到底使用高阶组件和minxin需要看实际场景。</li></ol><h2 id="6-路由"><a href="#6-路由" class="headerlink" title="6. 路由"></a>6. 路由</h2><p>实现根据路由匹配显示组件，并路由匹配参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件</span></span><br><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">    props: [<span class="string">&#x27;id&#x27;</span>],</span><br><span class="line">    template: <span class="string">`&lt;div&gt;foo with id: &#123;&#123; id &#125;&#125;&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Bar = &#123; <span class="attr">template</span>: <span class="string">`&lt;div&gt;bar&lt;/div&gt;`</span> &#125;</span><br><span class="line"><span class="keyword">const</span> NotFound = &#123; <span class="attr">template</span>: <span class="string">`&lt;div&gt;not found!&lt;/div&gt;`</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由表</span></span><br><span class="line"><span class="keyword">const</span> routeTable = &#123;</span><br><span class="line">    <span class="string">&#x27;/foo/:id&#x27;</span>: Foo,</span><br><span class="line">    <span class="string">&#x27;/bar&#x27;</span>: Bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将路由表的键通过 path-to-regexp库 进行正则封装</span></span><br><span class="line"><span class="comment">// 下面这个数组储存：组件、正则对象、匹配的name</span></span><br><span class="line"><span class="keyword">const</span> compiledRoutes = []</span><br><span class="line"><span class="built_in">Object</span>.keys(routeTable).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> dynamicSegments = []</span><br><span class="line">    <span class="keyword">const</span> regex = pathToRegexp(key, dynamicSegments)</span><br><span class="line">    <span class="keyword">const</span> component = routeTable[key]</span><br><span class="line">    compiledRoutes.push(&#123;</span><br><span class="line">        component,</span><br><span class="line">        regex,</span><br><span class="line">        dynamicSegments</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听hashchange，将改变的路由赋值给url</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;hashchange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    app.url = <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        url: <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    render (h) &#123;</span><br><span class="line">        <span class="keyword">const</span> path = <span class="string">&#x27;/&#x27;</span> + <span class="built_in">this</span>.url</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> componentToRender <span class="comment">// 要渲染的组件</span></span><br><span class="line">        <span class="keyword">let</span> props = &#123;&#125; <span class="comment">// 路由匹配到的值</span></span><br><span class="line"></span><br><span class="line">        compiledRoutes.some(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> match = route.regex.exec(path) <span class="comment">// 执行匹配</span></span><br><span class="line">            componentToRender = NotFound</span><br><span class="line">            <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                componentToRender = route.component</span><br><span class="line">                <span class="comment">// 设置参数</span></span><br><span class="line">                route.dynamicSegments.forEach(<span class="function">(<span class="params">segment, index</span>) =&gt;</span> &#123;</span><br><span class="line">                    props[segment.name] = match[index + <span class="number">1</span>]</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, [</span><br><span class="line">            h(componentToRender, &#123; props &#125;),</span><br><span class="line">            h(<span class="string">&#x27;a&#x27;</span>, &#123; <span class="attr">attrs</span>: &#123; <span class="attr">href</span>: <span class="string">&#x27;#foo/123&#x27;</span> &#125;&#125;, <span class="string">&#x27;foo 123&#x27;</span>),</span><br><span class="line">            <span class="string">&#x27; | &#x27;</span>,</span><br><span class="line">            h(<span class="string">&#x27;a&#x27;</span>, &#123; <span class="attr">attrs</span>: &#123; <span class="attr">href</span>: <span class="string">&#x27;#foo/234&#x27;</span> &#125;&#125;, <span class="string">&#x27;foo 234&#x27;</span>),</span><br><span class="line">            <span class="string">&#x27; | &#x27;</span>,</span><br><span class="line">            h(<span class="string">&#x27;a&#x27;</span>, &#123; <span class="attr">attrs</span>: &#123; <span class="attr">href</span>: <span class="string">&#x27;#bar&#x27;</span> &#125;&#125;, <span class="string">&#x27;bar&#x27;</span>),</span><br><span class="line">            <span class="string">&#x27; | &#x27;</span>,</span><br><span class="line">            h(<span class="string">&#x27;a&#x27;</span>, &#123; <span class="attr">attrs</span>: &#123; <span class="attr">href</span>: <span class="string">&#x27;#garbage&#x27;</span> &#125;&#125;, <span class="string">&#x27;garbage&#x27;</span>)</span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;尤雨溪Frontend-Master课程笔记&quot;&gt;&lt;a href=&quot;#尤雨溪Frontend-Master课程笔记&quot; class=&quot;headerlink&quot; title=&quot;尤雨溪Frontend Master课程笔记&quot;&gt;&lt;/a&gt;尤雨溪Frontend Master课程
      
    
    </summary>
    
    
      <category term="前端" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="vue" scheme="https://liang5757.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>MPA首屏加载速率优化实战</title>
    <link href="https://liang5757.github.io/2021/02/14/Webpack/MPA%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E7%8E%87%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/"/>
    <id>https://liang5757.github.io/2021/02/14/Webpack/MPA%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E7%8E%87%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/</id>
    <published>2021-02-14T07:45:27.000Z</published>
    <updated>2021-02-14T07:48:02.536Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MPA首屏加载速率优化实战"><a href="#MPA首屏加载速率优化实战" class="headerlink" title="MPA首屏加载速率优化实战"></a>MPA首屏加载速率优化实战</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    学校实验室的项目，因为学校只开放给我们一个端口，所以只能把后台管理和学生端合并成多页应用，我是做后台管理的，老师要求某个功能要加上代码高亮，在全局引入highlight.js后发现首屏加载速率不行了，记录一下发现更多问题并优化的过程。</p><h2 id="有用的优化"><a href="#有用的优化" class="headerlink" title="有用的优化"></a>有用的优化</h2><h3 id="1-HighLight-js被放在首屏加载了"><a href="#1-HighLight-js被放在首屏加载了" class="headerlink" title="1. HighLight.js被放在首屏加载了"></a>1. HighLight.js被放在首屏加载了</h3><p>首先用<code>webpack-bundle-analyer</code>进行构建分析</p><p><img src= "/img/loading.gif" data-lazy-src="/2021/02/14/Webpack/MPA%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E7%8E%87%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20210126203158808-1613288799701.png" alt="image-20210126203158808"></p><p>发现了两个巨大的包<code>chunk-vendors.44cd6d2c.js</code>有2.4MB，<code>chunk-94715762.bb0c42f0.js</code>有1.4MB，不幸的是c端需要在首屏同时下载两个大包（此处有误，后面讲解，正确的是左边这个包加入口）才开始渲染，而c端并没有用到<code>highlight.js</code>但是他也得等待下载。</p><p>然后把<code>highlight.js</code>放到封装的组件里引用，然后打包分析</p><p><img src= "/img/loading.gif" data-lazy-src="/2021/02/14/Webpack/MPA%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E7%8E%87%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20210126204428302.png" alt="image-20210126204428302"></p><p>发现就分离了，<strong>2.4MB的包变成了1.5MB</strong></p><h3 id="2-两个应用使用的element组件没有分离"><a href="#2-两个应用使用的element组件没有分离" class="headerlink" title="2. 两个应用使用的element组件没有分离"></a>2. 两个应用使用的element组件没有分离</h3><p>但是又发现了新的问题——<code>element-ui</code>两个应用使用的组件被打包到了一起，即时c端没有使用到诸如<code>el-upload</code>、<code>el-pagination</code>等组件，但是也要首屏也要下载，想了想<code>highlight.js</code>被放到b端入口文件引入就被打进这个包里。</p><p>是不是<strong>两个入口使用了同一个element按需引入文件的原因</strong>，然后我给<strong>两个应用各开了自己的按需引入文件</strong>。<strong>打包分析没啥变化</strong>。</p><p>问了大哥，大哥甩手就是一个连接<a href="https://www.cnblogs.com/HYZhou2018/p/10419703.html">https://www.cnblogs.com/HYZhou2018/p/10419703.html</a></p><p>大概就是<code>vue-cli3</code>的脚手架配置自动分包的时候是针对单页应用的，下面是<code>vue-cli3</code>的配置项</p><p><img src= "/img/loading.gif" data-lazy-src="/2021/02/14/Webpack/MPA%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E7%8E%87%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20210126205853873.png" alt="image-20210126205853873"></p><p><code>splitChunks</code>默认<code>minChunks</code>是1，但是我们是多页应用啊，所以两个应用使用的第三方库全被抽离到一个<code>chunk-vendor.js</code>了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">config.optimization.splitChunks(&#123;</span><br><span class="line">    cacheGroups: &#123;</span><br><span class="line">        vendors: &#123;</span><br><span class="line">            name: <span class="string">&#x27;chunk-vendors&#x27;</span>,</span><br><span class="line">            minChunks: <span class="number">2</span>, <span class="comment">// 设置为2，两个应用同时使用才抽离</span></span><br><span class="line">            test: <span class="regexp">/node_modules/</span>,</span><br><span class="line">            priority: -<span class="number">10</span>,</span><br><span class="line">            chunks: <span class="string">&#x27;initial&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        common: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>再次打包分析</p><p><img src= "/img/loading.gif" data-lazy-src="/2021/02/14/Webpack/MPA%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E7%8E%87%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20210126210625547.png" alt="image-20210126210625547"></p><p>不仅分离了一些组件，还把一些使用到的第三方库给分离了，这个2.4MB的打包到此为止就变成了<strong>1.2MB</strong>的包。</p><h2 id="走过的坑"><a href="#走过的坑" class="headerlink" title="走过的坑"></a>走过的坑</h2><h3 id="1-怎么coding包还是在首屏下载了"><a href="#1-怎么coding包还是在首屏下载了" class="headerlink" title="1.怎么coding包还是在首屏下载了"></a>1.怎么coding包还是在首屏下载了</h3><p>已经使用了路由懒加载，为什么coding包还是在首屏下载了，我曾一度以为是没有<a href="https://babeljs.io/docs/plugins/syntax-dynamic-import/"><code>syntax-dynamic-import</code></a>这个插件的原因，还装过了试了下，但是并没有什么用，而且webpack已经使用动态import来做到懒加载了。</p><p>查阅<a href="https://blog.csdn.net/sinat_35538827/article/details/87969834">文章</a>发现</p><p>原来 vue-cli3 默认会把所有通过<code>import()</code>按需加载的javascript文件加上 prefetch 。</p><p><strong>prefetch是什么？</strong>在打包后的文件中，查看index.html我们会发现类似这个 <link href="/js/chunk-118075e7.5725ab1a.js" rel="prefetch">。<link rel="prefetch">会在页面加载完成后，利用空闲时间提前加载获取用户未来可能会访问的内容。</p><p><strong>prefetch链接会消耗宽带，如果是在移动端，而且存在大量的chunk，那么可以关掉 prefetch 链接，手动选择要提前获取的代码区块。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//手动选定要提前获取的代码</span></span><br><span class="line"><span class="keyword">import</span>(webpackPrefetch: <span class="literal">true</span>, <span class="string">&#x27;./someAsyncComponent.vue&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>关闭prefetch:</strong> (官网示例)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 移除 prefetch 插件</span></span><br><span class="line">    config.plugins.delete(<span class="string">&#x27;prefetch&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 或者</span></span><br><span class="line">    <span class="comment">// 修改它的选项：</span></span><br><span class="line">    config.plugin(<span class="string">&#x27;prefetch&#x27;</span>).tap(<span class="function"><span class="params">options</span> =&gt;</span> &#123;</span><br><span class="line">      options[<span class="number">0</span>].fileBlacklist = options[<span class="number">0</span>].fileBlacklist || []</span><br><span class="line">      options[<span class="number">0</span>].fileBlacklist.push(<span class="regexp">/myasyncRoute(.)+?\.js$/</span>)</span><br><span class="line">      <span class="keyword">return</span> options</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-第三方库怎么这么多重复的bn-js"><a href="#2-第三方库怎么这么多重复的bn-js" class="headerlink" title="2. 第三方库怎么这么多重复的bn.js"></a>2. 第三方库怎么这么多重复的bn.js</h3><p><img src= "/img/loading.gif" data-lazy-src="/2021/02/14/Webpack/MPA%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E7%8E%87%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20210126212734717.png" alt="image-20210126212734717"></p><p>可以看到有8个重复的<code>bn.js</code>，一个40KB，gzip后10KB，离谱。</p><p>但是大小是不一样的，可能<strong>用的版本不同</strong>，目前没有好的方法抽离。。</p><p>其实可以用cdn来搞，但是第三方的cdn不稳定，就没搞。</p><h3 id="3-打包后mini-css-extract-plugin警告Conflicting-order"><a href="#3-打包后mini-css-extract-plugin警告Conflicting-order" class="headerlink" title="3. 打包后mini-css-extract-plugin警告Conflicting order"></a>3. 打包后mini-css-extract-plugin警告Conflicting order</h3><p>对应的issus：<a href="https://github.com/webpack-contrib/mini-css-extract-plugin/issues/250">https://github.com/webpack-contrib/mini-css-extract-plugin/issues/250</a></p><p>是由于组件使用顺序不一致导致的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MPA首屏加载速率优化实战&quot;&gt;&lt;a href=&quot;#MPA首屏加载速率优化实战&quot; class=&quot;headerlink&quot; title=&quot;MPA首屏加载速率优化实战&quot;&gt;&lt;/a&gt;MPA首屏加载速率优化实战&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; cla
      
    
    </summary>
    
    
      <category term="前端" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Webpack" scheme="https://liang5757.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>适配器模式</title>
    <link href="https://liang5757.github.io/2021/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://liang5757.github.io/2021/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-02-11T07:38:26.000Z</published>
    <updated>2021-02-14T07:38:43.171Z</updated>
    
    <content type="html"><![CDATA[<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><blockquote><p>适配器模式的作用是解决两个软件实体间的接口不兼容的问题。使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体可以一起工作。 适配器的别名是包装器(wrapper)，这是一个相对简单的模式</p></blockquote><p>在程序开发中有许多这样的场景：当我们试图调用模块或者对象的某个接口时，却发现这个接口的格式并不符合目前的需求。 这时候有两种解决办法，第一种是修改原来的接口实现，但如果原来的模块很复杂，或者我们拿到的模块是一段别人编写的经过压缩的代码，修改原接口就显得不太现实了。第二种办法是创建一个适配器，将原接口转换为客户希望的另一个接口，客户只需要和适配器打交道。</p><h2 id="故事背景"><a href="#故事背景" class="headerlink" title="故事背景"></a>故事背景</h2><p>现在使用 谷歌地图 和 百度地图 在页面展现地图</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> googleMap = &#123;</span><br><span class="line">  show: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;开始渲染谷歌地图&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> baiduMap = &#123;</span><br><span class="line">  show: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;开始渲染百度地图&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> renderMap = <span class="function"><span class="keyword">function</span> (<span class="params">map</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (map.show <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">    map.show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">renderMap(googleMap); <span class="comment">// 输出:开始渲染谷歌地图</span></span><br><span class="line">renderMap(baiduMap); <span class="comment">// 输出:开始渲染百度地图</span></span><br></pre></td></tr></table></figure><p>上面的代码能够运行成功是因为两个第三方均为show方法，如果两个接口提供调用的方式不一样，那么就不能运行了</p><h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> googleMap = &#123;</span><br><span class="line">  show: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;开始渲染谷歌地图&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> baiduMap = &#123;</span><br><span class="line">  display: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;开始渲染百度地图&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> baiduMapAdapter = &#123;</span><br><span class="line">  show: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> baiduMap.display();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> renderMap = <span class="function"><span class="keyword">function</span> (<span class="params">map</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (map.show <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">    map.show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">renderMap(googleMap); <span class="comment">// 输出:开始渲染谷歌地图</span></span><br><span class="line">renderMap(baiduMapAdapter); <span class="comment">// 输出:开始渲染百度地图</span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>适配器模式主要用来解决两个已有接口之间不匹配的问题，它不考虑这些接口是怎样实现的，也不考虑它们将来可能会如何演化。适配器模式不需要改变已有的接口，就能够使它们协同作用。</li><li>装饰者模式和代理模式也不会改变原有对象的接口，但装饰者模式的作用是为了给对象增加功能。装饰者模式常常形成一条长的装饰链，而适配器模式通常只包装一次。代理模式是为了控制对对象的访问，通常也只包装一次。</li><li>外观模式的作用倒是和适配器比较相似，有人把外观模式看成一组对象的适配器，但外观模式最显著的特点是定义了一个新的接口。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《javascript设计模式与开发实践》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;适配器模式&quot;&gt;&lt;a href=&quot;#适配器模式&quot; class=&quot;headerlink&quot; title=&quot;适配器模式&quot;&gt;&lt;/a&gt;适配器模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;适配器模式的作用是解决两个软件实体间的接口不兼容的问题。使用适配器模式之后，原本由于接口不
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://liang5757.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="js" scheme="https://liang5757.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>状态模式</title>
    <link href="https://liang5757.github.io/2021/02/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <id>https://liang5757.github.io/2021/02/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-02-10T07:38:03.000Z</published>
    <updated>2021-02-14T07:38:46.902Z</updated>
    
    <content type="html"><![CDATA[<h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><blockquote><p>允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类</p><p>状态模式的关键是区分事物内部的状态，事物内部状态的改变往往会带来事物的行为改变</p></blockquote><h2 id="故事背景"><a href="#故事背景" class="headerlink" title="故事背景"></a>故事背景</h2><p>我们来想象这样一个场景：有一个电灯，电灯上面只有一个开关。当电灯开着的时候，此时 按下开关，电灯会切换到关闭状态;再按一次开关，电灯又将被打开。同一个开关按钮，在不同 的状态下，表现出来的行为是不一样的 </p><h2 id="未使用状态模式"><a href="#未使用状态模式" class="headerlink" title="未使用状态模式"></a>未使用状态模式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Light = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.state = <span class="string">&quot;off&quot;</span>; <span class="comment">// 给电灯设置初始状态 off</span></span><br><span class="line">  <span class="built_in">this</span>.button = <span class="literal">null</span>;<span class="comment">// 电灯开关按钮</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Light.prototype.init = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> button = <span class="built_in">document</span>.createElement(<span class="string">&quot;button&quot;</span>),</span><br><span class="line">    self = <span class="built_in">this</span>;</span><br><span class="line">  button.innerHTML = <span class="string">&quot;开关&quot;</span>;</span><br><span class="line">  <span class="built_in">this</span>.button = <span class="built_in">document</span>.body.appendChild(button);</span><br><span class="line">  <span class="built_in">this</span>.button.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    self.buttonWasPressed();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Light.prototype.buttonWasPressed = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.state === <span class="string">&quot;off&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;开灯&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.state = <span class="string">&quot;on&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.state === <span class="string">&quot;on&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;关灯&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.state = <span class="string">&quot;off&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> light = <span class="keyword">new</span> Light();</span><br><span class="line">light.init();</span><br></pre></td></tr></table></figure><p>但是如果需要在新增状态，那么就得直接在buttonWasPressed里修改，不符合开闭原则。</p><h2 id="状态模式重构"><a href="#状态模式重构" class="headerlink" title="状态模式重构"></a>状态模式重构</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> OffLightState = <span class="function"><span class="keyword">function</span> (<span class="params">light</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.light = light;</span><br><span class="line">&#125;;</span><br><span class="line">OffLightState.prototype.buttonWasPressed = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;弱光&quot;</span>); <span class="comment">// offLightState 对应的行为</span></span><br><span class="line">  <span class="built_in">this</span>.light.setState(<span class="built_in">this</span>.light.weakLightState);<span class="comment">// 切换状态到 weakLightState</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> WeakLightState = <span class="function"><span class="keyword">function</span> (<span class="params">light</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.light = light;</span><br><span class="line">&#125;;</span><br><span class="line">WeakLightState.prototype.buttonWasPressed = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;强光&quot;</span>); <span class="comment">// weakLightState 对应的行为</span></span><br><span class="line">  <span class="built_in">this</span>.light.setState(<span class="built_in">this</span>.light.strongLightState); <span class="comment">//切换状态到 strongLightState</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> StrongLightState = <span class="function"><span class="keyword">function</span> (<span class="params">light</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.light = light;</span><br><span class="line">&#125;;</span><br><span class="line">StrongLightState.prototype.buttonWasPressed = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;关灯&quot;</span>); <span class="comment">// strongLightState 对应的行为</span></span><br><span class="line">  <span class="built_in">this</span>.light.setState(<span class="built_in">this</span>.light.offLightState); <span class="comment">// 切换状态到 offLightState</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改写 Light 类，使用状态对象记录当前的状态</span></span><br><span class="line"><span class="keyword">let</span> Light = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.offLightState = <span class="keyword">new</span> OffLightState(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">this</span>.weakLightState = <span class="keyword">new</span> WeakLightState(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">this</span>.strongLightState = <span class="keyword">new</span> StrongLightState(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">this</span>.button = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供一个 方法来切换 light 对象的状态</span></span><br><span class="line">Light.prototype.init = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> button = <span class="built_in">document</span>.createElement(<span class="string">&quot;button&quot;</span>),</span><br><span class="line">    self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="built_in">this</span>.button = <span class="built_in">document</span>.body.appendChild(button);</span><br><span class="line">  <span class="built_in">this</span>.button.innerHTML = <span class="string">&quot;开关&quot;</span>;</span><br><span class="line">  <span class="built_in">this</span>.currState = <span class="built_in">this</span>.offLightState;</span><br><span class="line">  <span class="built_in">this</span>.button.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    self.currState.buttonWasPressed();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">Light.prototype.setState = <span class="function"><span class="keyword">function</span> (<span class="params">newState</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.currState = newState;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> light = <span class="keyword">new</span> Light();</span><br><span class="line">light.init();</span><br></pre></td></tr></table></figure><p>它可以使每一种状态和它对应的行为之间的关系局部化，这些行为被分散和封装在各自对应的状态类之中，便于阅读和管理代码。</p><p>状态之间的切换都被分布在状态类内部，这使得我们无需编写过多的 if、else 条件 分支语言来控制状态之间的转换</p><p>用对象代替字符串来记录当前状态，使得状态的切换更加一目了然。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《javascript设计模式与开发实践》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;状态模式&quot;&gt;&lt;a href=&quot;#状态模式&quot; class=&quot;headerlink&quot; title=&quot;状态模式&quot;&gt;&lt;/a&gt;状态模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类&lt;/p&gt;
&lt;p&gt;状态模式的关
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://liang5757.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="js" scheme="https://liang5757.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>装饰者模式</title>
    <link href="https://liang5757.github.io/2021/02/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://liang5757.github.io/2021/02/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-02-09T07:37:36.000Z</published>
    <updated>2021-02-14T07:38:45.476Z</updated>
    
    <content type="html"><![CDATA[<h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><blockquote><p>在传统的面向对象语言中，给对象添加功能常常使用继承的方式，但是继承的方式并不灵活， 还会带来许多问题：一方面会导致超类和子类之间存在强耦合性，当超类改变时，子类也会随之改变；另一方面，继承这种功能复用方式通常被称为“白箱复用”，“白箱”是相对可见性而言的， 在继承方式中，超类的内部细节是对子类可见的，继承常常被认为破坏了封装性。装饰者模式能够在不改变对象自身的基础上，在程序运行期间给对象动态地添加职责。跟继承相比，装饰者是一种更轻便灵活的做法，这是一种“即用即付”的方式</p></blockquote><h2 id="故事背景"><a href="#故事背景" class="headerlink" title="故事背景"></a>故事背景</h2><p>假设我们在编写一个飞机大战的游戏，随着经验值的增加，我们操作的飞机对象可以升级成更厉害的飞机，一开始这些飞机只能发射普通的子弹，升到第二级时可以发射导弹，升到第三级时可以发射原子弹。</p><h2 id="传统面向对象实现"><a href="#传统面向对象实现" class="headerlink" title="传统面向对象实现"></a>传统面向对象实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Plane = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Plane.prototype.fire = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;发射普通子弹&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导弹类</span></span><br><span class="line"><span class="keyword">let</span> MissileDecorator = <span class="function"><span class="keyword">function</span> (<span class="params">plane</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.plane = plane;</span><br><span class="line">&#125;;</span><br><span class="line">MissileDecorator.prototype.fire = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.plane.fire();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;发射导弹&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子弹类</span></span><br><span class="line"><span class="keyword">let</span> AtomDecorator = <span class="function"><span class="keyword">function</span> (<span class="params">plane</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.plane = plane;</span><br><span class="line">&#125;;</span><br><span class="line">AtomDecorator.prototype.fire = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.plane.fire();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;发射原子弹&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> plane = <span class="keyword">new</span> Plane();</span><br><span class="line">plane = <span class="keyword">new</span> MissileDecorator(plane);</span><br><span class="line">plane = <span class="keyword">new</span> AtomDecorator(plane);</span><br><span class="line">plane.fire();</span><br></pre></td></tr></table></figure><p>装饰者对象和它所装饰的对象拥有一致的接口，通过传入被装饰对象，调用其对应方法，并添加职责形成聚合对象。</p><h2 id="动态语言实现"><a href="#动态语言实现" class="headerlink" title="动态语言实现"></a>动态语言实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> plane = &#123;</span><br><span class="line">  fire: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;发射普通子弹&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> missileDecorator = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;发射导弹&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> atomDecorator = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;发射原子弹&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fire1 = plane.fire;</span><br><span class="line">plane.fire = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  fire1();</span><br><span class="line">  missileDecorator();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fire2 = plane.fire;</span><br><span class="line">plane.fire = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  fire2();</span><br><span class="line">  atomDecorator();</span><br><span class="line">&#125;;</span><br><span class="line">plane.fire();</span><br></pre></td></tr></table></figure><p>因为js可以直接修改对象或者对象的某个方法，那么可以通过一个变量<code>a</code>暂存被装饰函数，然后替换旧方法，在新方法内通过<code>a</code>调用旧方法。</p><p>但是<strong>直接替换有this指向问题</strong>。</p><h2 id="AOP实现"><a href="#AOP实现" class="headerlink" title="AOP实现"></a>AOP实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span> (<span class="params">beforefn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _self = <span class="built_in">this</span>; <span class="comment">// 保存原函数的引用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 返回包含了原函数和新函数的&quot;代理&quot;函数</span></span><br><span class="line">    beforefn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 执行新函数，且保证 this 不被劫持，新函数接受的参数 </span></span><br><span class="line">                                     <span class="comment">// 也会被原封不动地传入原函数，新函数在原函数之前执行</span></span><br><span class="line">    <span class="keyword">return</span> _self.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 执行原函数并返回原函数的执行结果，  // 并且保证 this 不被劫持</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span> (<span class="params">afterfn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ret = _self.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    afterfn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>通过AOP实际上放回的是新函数，在原函数上保存的属性则会丢失</li><li>叠加了作用域，如果装饰的链条过长，性能上会受到影响</li></ul><h2 id="与代理模式的区别"><a href="#与代理模式的区别" class="headerlink" title="与代理模式的区别"></a>与代理模式的区别</h2><p>代理模式的目的：当直接访问本体不方便或者不符合需要时，为这个本体提供一个替代者。本体定义了关键功能，而代理提供或拒绝对它的访问，或者在访问本体之前做一些额外的事情。</p><p>装饰者模式的作用：为对象动态的加入行为。</p><p>换句话说，代理模式的关系一开始就可以被确定，而装饰者模式用于一开始不能确定对象的全部功能时</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《javascript设计模式与开发实践》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;装饰者模式&quot;&gt;&lt;a href=&quot;#装饰者模式&quot; class=&quot;headerlink&quot; title=&quot;装饰者模式&quot;&gt;&lt;/a&gt;装饰者模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;在传统的面向对象语言中，给对象添加功能常常使用继承的方式，但是继承的方式并不灵活， 还会带
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://liang5757.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="js" scheme="https://liang5757.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>中介者模式</title>
    <link href="https://liang5757.github.io/2021/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://liang5757.github.io/2021/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-02-08T07:37:14.000Z</published>
    <updated>2021-02-14T07:38:44.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><blockquote><p>中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。中介者模式使网状的多对多关系变成了相对简单的一对多关系</p></blockquote><h2 id="故事背景"><a href="#故事背景" class="headerlink" title="故事背景"></a>故事背景</h2><p>假如在玩泡泡堂的游戏，使用泡泡击败对方所有玩家才能获得胜利。现在将队伍分成两个组进行游戏</p><h2 id="代码实现-未使用中介者模式"><a href="#代码实现-未使用中介者模式" class="headerlink" title="代码实现(未使用中介者模式)"></a>代码实现(未使用中介者模式)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 玩家</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Player</span>(<span class="params">name, teamColor</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.partners = []; <span class="comment">// 队友列表</span></span><br><span class="line">  <span class="built_in">this</span>.enemies = []; <span class="comment">// 敌人列表</span></span><br><span class="line">  <span class="built_in">this</span>.state = <span class="string">&quot;live&quot;</span>; <span class="comment">// 玩家状态</span></span><br><span class="line">  <span class="built_in">this</span>.name = name; <span class="comment">// 角色名字</span></span><br><span class="line">  <span class="built_in">this</span>.teamColor = teamColor; <span class="comment">// 队伍颜色</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Player.prototype.win = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 玩家团队胜利</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;winner: &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line">Player.prototype.lose = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 玩家团队失败</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;loser: &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 玩家死亡的方法</span></span><br><span class="line">Player.prototype.die = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 玩家死亡</span></span><br><span class="line">  <span class="keyword">let</span> all_dead = <span class="literal">true</span>;</span><br><span class="line">  <span class="built_in">this</span>.state = <span class="string">&quot;dead&quot;</span>; <span class="comment">// 设置玩家状态为死亡</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, partner; partner = <span class="built_in">this</span>.partners[i++];) &#123; <span class="comment">// 遍历队友列表</span></span><br><span class="line">    <span class="keyword">if</span> (partner.state !== <span class="string">&quot;dead&quot;</span>) &#123; <span class="comment">// 如果还有一个队友没有死亡，则游戏还未失败</span></span><br><span class="line">      all_dead = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (all_dead === <span class="literal">true</span>) &#123; <span class="comment">// 如果队友全部死亡</span></span><br><span class="line">    <span class="built_in">this</span>.lose(); <span class="comment">// 通知自己游戏失败</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, partner; partner = <span class="built_in">this</span>.partners[i++];) &#123;</span><br><span class="line">      partner.lose();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, enemy; enemy = <span class="built_in">this</span>.enemies[i++];) &#123;</span><br><span class="line">      enemy.win();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个工厂来创建玩家</span></span><br><span class="line"><span class="keyword">let</span> playerFactory = <span class="function"><span class="keyword">function</span> (<span class="params">name, teamColor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newPlayer = <span class="keyword">new</span> Player(name, teamColor);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, player; player = players[i++];) &#123; <span class="comment">// 通知所有的玩家，有新角色加入</span></span><br><span class="line">    <span class="keyword">if</span> (player.teamColor === newPlayer.teamColor) &#123; <span class="comment">// 如果是同一队的玩家</span></span><br><span class="line">      player.partners.push(newPlayer); <span class="comment">// 相互添加到队友列表</span></span><br><span class="line">      newPlayer.partners.push(player);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      player.enemies.push(newPlayer); <span class="comment">// 相互添加到敌人列表</span></span><br><span class="line">      newPlayer.enemies.push(player);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  players.push(newPlayer);</span><br><span class="line">  <span class="keyword">return</span> newPlayer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> players = [];</span><br><span class="line"><span class="comment">//红队:</span></span><br><span class="line"><span class="keyword">let</span> player1 = playerFactory(<span class="string">&quot;皮蛋&quot;</span>, <span class="string">&quot;red&quot;</span>),</span><br><span class="line">  player2 = playerFactory(<span class="string">&quot;小乖&quot;</span>, <span class="string">&quot;red&quot;</span>),</span><br><span class="line">  player3 = playerFactory(<span class="string">&quot;宝宝&quot;</span>, <span class="string">&quot;red&quot;</span>),</span><br><span class="line">  player4 = playerFactory(<span class="string">&quot;小强&quot;</span>, <span class="string">&quot;red&quot;</span>);</span><br><span class="line"><span class="comment">//蓝队:</span></span><br><span class="line"><span class="keyword">let</span> player5 = playerFactory(<span class="string">&quot;黑妞&quot;</span>, <span class="string">&quot;blue&quot;</span>),</span><br><span class="line">  player6 = playerFactory(<span class="string">&quot;葱头&quot;</span>, <span class="string">&quot;blue&quot;</span>),</span><br><span class="line">  player7 = playerFactory(<span class="string">&quot;胖墩&quot;</span>, <span class="string">&quot;blue&quot;</span>),</span><br><span class="line">  player8 = playerFactory(<span class="string">&quot;海盗&quot;</span>, <span class="string">&quot;blue&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让红队玩家全部死亡:</span></span><br><span class="line">player1.die();</span><br><span class="line">player2.die();</span><br><span class="line">player4.die();</span><br><span class="line">player3.die();</span><br></pre></td></tr></table></figure><p>每个玩家添加或者死亡，都必须修改所有其他玩家内部的队友列表和敌人列表。耦合度很高。</p><h2 id="代码重构-使用中介者模式"><a href="#代码重构-使用中介者模式" class="headerlink" title="代码重构(使用中介者模式)"></a>代码重构(使用中介者模式)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 玩家</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Player</span>(<span class="params">name, teamColor</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.state = <span class="string">&quot;live&quot;</span>; <span class="comment">// 玩家状态</span></span><br><span class="line">  <span class="built_in">this</span>.name = name; <span class="comment">// 角色名字</span></span><br><span class="line">  <span class="built_in">this</span>.teamColor = teamColor; <span class="comment">// 队伍颜色</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Player.prototype.win = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="built_in">this</span>.name + <span class="string">&#x27; won &#x27;</span> );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Player.prototype.lose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="built_in">this</span>.name +<span class="string">&#x27; lost&#x27;</span> );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************玩家死亡*****************/</span></span><br><span class="line">Player.prototype.die = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.state = <span class="string">&quot;dead&quot;</span>;</span><br><span class="line">  playerDirector.receiveMessage(<span class="string">&quot;playerDead&quot;</span>, <span class="built_in">this</span>);<span class="comment">// 给中介者发送消息，玩家死亡</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************移除玩家*****************/</span></span><br><span class="line">Player.prototype.remove = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 给中介者发送消息，移除一个玩家</span></span><br><span class="line">  playerDirector.receiveMessage(<span class="string">&quot;removePlayer&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************玩家换队*****************/</span></span><br><span class="line">Player.prototype.changeTeam = <span class="function"><span class="keyword">function</span> (<span class="params">color</span>) </span>&#123;</span><br><span class="line">  playerDirector.receiveMessage(<span class="string">&quot;changeTeam&quot;</span>, <span class="built_in">this</span>, color); <span class="comment">// 给中介者发送消息，玩家换队</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************定义中介者对象*****************/</span></span><br><span class="line"><span class="keyword">let</span> playerDirector = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> players = &#123;&#125;, <span class="comment">// 保存所有玩家</span></span><br><span class="line">    operations = &#123;&#125;; <span class="comment">// 中介者可以执行的操作</span></span><br><span class="line">  <span class="comment">/****************新增一个玩家***************************/</span></span><br><span class="line">  operations.addPlayer = <span class="function"><span class="keyword">function</span> (<span class="params">player</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> teamColor = player.teamColor; <span class="comment">// 玩家的队伍颜色</span></span><br><span class="line">    players[teamColor] = players[teamColor] || []; <span class="comment">// 如果该颜色的玩家还没有成立队伍，则新成立一个队伍</span></span><br><span class="line">    players[teamColor].push(player); <span class="comment">// 添加玩家进队伍</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">/****************移除一个玩家***************************/</span></span><br><span class="line">  operations.removePlayer = <span class="function"><span class="keyword">function</span> (<span class="params">player</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> teamColor = player.teamColor, <span class="comment">// 玩家的队伍颜色</span></span><br><span class="line">      teamPlayers = players[teamColor] || []; <span class="comment">// 该队伍所有成员</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = teamPlayers.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 遍历删除</span></span><br><span class="line">      <span class="keyword">if</span> (teamPlayers[i] === player) &#123;</span><br><span class="line">        teamPlayers.splice(i, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">/****************玩家换队***************************/</span></span><br><span class="line">  operations.changeTeam = <span class="function"><span class="keyword">function</span> (<span class="params">player, newTeamColor</span>) </span>&#123; <span class="comment">// 玩家换队</span></span><br><span class="line">    operations.removePlayer(player); <span class="comment">// 从原队伍中删除</span></span><br><span class="line">    player.teamColor = newTeamColor; <span class="comment">// 改变队伍颜色</span></span><br><span class="line">    operations.addPlayer(player);<span class="comment">// 增加到新队伍中</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">/****************玩家死亡***************************/</span></span><br><span class="line">  operations.playerDead = <span class="function"><span class="keyword">function</span> (<span class="params">player</span>) </span>&#123; <span class="comment">// 玩家死亡</span></span><br><span class="line">    <span class="keyword">let</span> teamColor = player.teamColor,</span><br><span class="line">      teamPlayers = players[teamColor]; <span class="comment">// 玩家所在队伍</span></span><br><span class="line">    <span class="keyword">let</span> all_dead = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, player; player = teamPlayers[i++];) &#123;</span><br><span class="line">      <span class="keyword">if</span> (player.state !== <span class="string">&quot;dead&quot;</span>) &#123;</span><br><span class="line">        all_dead = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (all_dead === <span class="literal">true</span>) &#123;<span class="comment">// 全部死亡</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, player; player = teamPlayers[i++];) &#123;</span><br><span class="line">        player.lose(); <span class="comment">// 本队所有玩家 lose</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> color <span class="keyword">in</span> players) &#123;</span><br><span class="line">        <span class="keyword">if</span> (color !== teamColor) &#123;</span><br><span class="line">          <span class="keyword">let</span> teamPlayers = players[color];  <span class="comment">// 其他队伍的玩家</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, player; player = teamPlayers[i++];) &#123;</span><br><span class="line">            player.win(); <span class="comment">// 其他队伍所有玩家 win</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> receiveMessage = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> message = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    operations[message].apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    receiveMessage: receiveMessage,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************设置工厂函数*****************/</span></span><br><span class="line"><span class="keyword">let</span> playerFactory = <span class="function"><span class="keyword">function</span> (<span class="params">name, teamColor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newPlayer = <span class="keyword">new</span> Player(name, teamColor); <span class="comment">// 创造一个新的玩家对象</span></span><br><span class="line">  playerDirector.receiveMessage(<span class="string">&quot;addPlayer&quot;</span>, newPlayer); <span class="comment">// 给中介者发送消息，新增玩家</span></span><br><span class="line">  <span class="keyword">return</span> newPlayer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//红队</span></span><br><span class="line"><span class="keyword">let</span> player1 = playerFactory(<span class="string">&quot;皮蛋&quot;</span>, <span class="string">&quot;red&quot;</span>),</span><br><span class="line">  player2 = playerFactory(<span class="string">&quot;小乖&quot;</span>, <span class="string">&quot;red&quot;</span>),</span><br><span class="line">  player3 = playerFactory(<span class="string">&quot;宝宝&quot;</span>, <span class="string">&quot;red&quot;</span>),</span><br><span class="line">  player4 = playerFactory(<span class="string">&quot;小强&quot;</span>, <span class="string">&quot;red&quot;</span>);</span><br><span class="line"><span class="comment">// 蓝队:</span></span><br><span class="line"><span class="keyword">let</span> player5 = playerFactory(<span class="string">&quot;黑妞&quot;</span>, <span class="string">&quot;blue&quot;</span>),</span><br><span class="line">  player6 = playerFactory(<span class="string">&quot;葱头&quot;</span>, <span class="string">&quot;blue&quot;</span>),</span><br><span class="line">  player7 = playerFactory(<span class="string">&quot;胖墩&quot;</span>, <span class="string">&quot;blue&quot;</span>),</span><br><span class="line">  player8 = playerFactory(<span class="string">&quot;海盗&quot;</span>, <span class="string">&quot;blue&quot;</span>);</span><br><span class="line"></span><br><span class="line">player1.die();</span><br><span class="line">player2.die();</span><br><span class="line">player3.die();</span><br><span class="line">player4.die();</span><br></pre></td></tr></table></figure><p>现在玩家与玩家之间的耦合消除了，所有操作逻辑在中介者对象中实现，玩家只需要向中介者发生消息，中介者会把处理结果反馈给其他玩家对象。</p><h2 id="使用时机"><a href="#使用时机" class="headerlink" title="使用时机"></a>使用时机</h2><p>中介者模式可以非常方便地对模块或者对象进行解耦，但对象之间并非一定需要解耦。在实际项目中，模块或对象之间有一些依赖关系是很正常的。毕竟我们写程序是为了快速完成项目交付生产，而不是堆砌模式和过度设计。关键就在于如何去衡量对象之间的耦合程度。一般来说， 如果对象之间的复杂耦合确实导致调用和维护出现了困难，而且这些耦合度随项目的变化呈指数增长曲线，那我们就可以考虑用中介者模式来重构代码。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>中介者模式是迎合迪米特法则的一种实现。迪米特法则也叫最少知识原则，是指一个对象应该尽可能少地了解另外的对象。如果对象之间的耦合性太高，一个对象发生改变之后，难免会影响到其他的对象，而在中介者模式里，对象之间几乎不知道彼此的存在，它们只能通过中介者对象来互相影响对方。</p><p>中介者模式也存在一些缺点。其中最大的缺点是系统中会新增一个中介者对象，因 为对象之间交互的复杂性，转移成了中介者对象的复杂性，使得中介者对象经常是巨大的。中介者对象自身往往就是一个难以维护的对象。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《javascript设计模式与开发实践》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;中介者模式&quot;&gt;&lt;a href=&quot;#中介者模式&quot; class=&quot;headerlink&quot; title=&quot;中介者模式&quot;&gt;&lt;/a&gt;中介者模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://liang5757.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="js" scheme="https://liang5757.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>职责链模式</title>
    <link href="https://liang5757.github.io/2021/02/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>https://liang5757.github.io/2021/02/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-02-07T07:36:10.000Z</published>
    <updated>2021-02-14T07:36:32.671Z</updated>
    
    <content type="html"><![CDATA[<h1 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h1><blockquote><p>职责链模式的定义是：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p><p>职责链模式的名字非常形象，一系列可能会处理请求的对象被连接成一条链，请求在这些对 象之间依次传递，直到遇到一个可以处理它的对象，我们把这些对象称为链中的节点</p></blockquote><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>​    假设我们负责一个售卖手机的电商网站，经过分别交纳 500 元定金和 200 元定金的两轮预定后(订单已在此时生成)，现在已经到了正式购买的阶段。</p><p>​    在正式购买后，已经支付过 500 元定金的用户会收到 100 元的商城优惠券，200 元定金的用户可以收到 50 元的优惠券，而之前没有支付定金的用户只能进入普通购买模式，也就是没有优惠券，且在库存有限的情况下不一定保证能买到。</p><ul><li>orderType：订单类型</li><li>pay：用户是否已经支付定金</li><li>stock：用于普通用户，普通购买的手机库存数量</li></ul><h2 id="代码实现（未使用职责链模式）"><a href="#代码实现（未使用职责链模式）" class="headerlink" title="代码实现（未使用职责链模式）"></a>代码实现（未使用职责链模式）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> order = <span class="function"><span class="keyword">function</span> (<span class="params">orderType, pay, stock</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (orderType === <span class="number">1</span>) &#123; <span class="comment">// 500 元定金购买模式</span></span><br><span class="line">    <span class="keyword">if</span> (pay === <span class="literal">true</span>) &#123; <span class="comment">// 已支付定金</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;500 元定金预购, 得到 100 优惠券&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 未支付定金，降级到普通购买模式</span></span><br><span class="line">      <span class="keyword">if</span> (stock &gt; <span class="number">0</span>) &#123; <span class="comment">// 用于普通购买的手机还有库存</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;普通购买, 无优惠券&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;手机库存不足&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pay === <span class="literal">true</span>) &#123; <span class="comment">// 200 元定金购买模式</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;200 元定金预购, 得到 50 优惠券&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (stock &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;普通购买, 无优惠券&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;手机库存不足&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType === <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (stock &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;普通购买, 无优惠券&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;手机库存不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">order(<span class="number">1</span>, <span class="literal">true</span>, <span class="number">500</span>); <span class="comment">// 输出: 500 元定金预购, 得到 100 优惠券</span></span><br></pre></td></tr></table></figure><h2 id="用职责链模式重构代码"><a href="#用职责链模式重构代码" class="headerlink" title="用职责链模式重构代码"></a>用职责链模式重构代码</h2><p>​    先把 500 元订单、200 元订单以及普通购买分成 3 个函数。</p><p>​    接下来把 orderType、pay、stock 这 3 个字段当作参数传递给 500 元订单函数，如果该函数不符合处理条件，则把这个请求传递给后面的 200 元订单函数，如果 200 元订单函数依然不能处理该请求，则继续传递请求给普通购买函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> order500 = <span class="function"><span class="keyword">function</span> (<span class="params">orderType, pay, stock</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (orderType === <span class="number">1</span> &amp;&amp; pay === <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;500 元定金预购，得到 100 优惠券&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;nextSuccessor&quot;</span>; <span class="comment">// 我不知道下一个节点是谁，反正把请求往后面传递</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> order200 = <span class="function"><span class="keyword">function</span> (<span class="params">orderType, pay, stock</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (orderType === <span class="number">2</span> &amp;&amp; pay === <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;200 元定金预购，得到 50 优惠券&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;nextSuccessor&quot;</span>; <span class="comment">// 我不知道下一个节点是谁，反正把请求往后面传递</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> orderNormal = <span class="function"><span class="keyword">function</span> (<span class="params">orderType, pay, stock</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (stock &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;普通购买，无优惠券&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;手机库存不足&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Chain.prototype.setNextSuccessor 指定在链中的下一个节点</span></span><br><span class="line"><span class="comment">// Chain.prototype.passRequest 传递请求给某个节点</span></span><br><span class="line"><span class="keyword">let</span> Chain = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.fn = fn;</span><br><span class="line">  <span class="built_in">this</span>.successor = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Chain.prototype.setNextSuccessor = <span class="function"><span class="keyword">function</span> (<span class="params">successor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.successor = successor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Chain.prototype.passRequest = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ret = <span class="built_in">this</span>.fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">if</span> (ret === <span class="string">&quot;nextSuccessor&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.successor &amp;&amp; <span class="built_in">this</span>.successor.passRequest.apply(<span class="built_in">this</span>.successor, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> chainOrder500 = <span class="keyword">new</span> Chain(order500);</span><br><span class="line"><span class="keyword">let</span> chainOrder200 = <span class="keyword">new</span> Chain(order200);</span><br><span class="line"><span class="keyword">let</span> chainOrderNormal = <span class="keyword">new</span> Chain(orderNormal);</span><br><span class="line"></span><br><span class="line">chainOrder500.setNextSuccessor(chainOrder200);</span><br><span class="line">chainOrder200.setNextSuccessor(chainOrderNormal);</span><br><span class="line"></span><br><span class="line">chainOrder500.passRequest(<span class="number">1</span>, <span class="literal">true</span>, <span class="number">500</span>);   <span class="comment">// 输出:500 元定金预购，得到 100 优惠券</span></span><br><span class="line">chainOrder500.passRequest(<span class="number">2</span>, <span class="literal">true</span>, <span class="number">500</span>);   <span class="comment">// 输出:200 元定金预购，得到 50 优惠券</span></span><br><span class="line">chainOrder500.passRequest(<span class="number">3</span>, <span class="literal">true</span>, <span class="number">500</span>);   <span class="comment">// 输出:普通购买，无优惠券</span></span><br><span class="line">chainOrder500.passRequest(<span class="number">1</span>, <span class="literal">false</span>, <span class="number">0</span>);    <span class="comment">// 输出:手机库存不足</span></span><br></pre></td></tr></table></figure><h2 id="异步的职责链"><a href="#异步的职责链" class="headerlink" title="异步的职责链"></a>异步的职责链</h2><p>​    在现实开发中，我们经常会遇到一些异步的问题，比如我们要在节点函数中发起一个 ajax 异步请求，异步请求返回的结果才能决定是否继续在职责链中 passRequest。 这时候让节点函数同步返回 “nextSuccessor” 已经没有意义了，所以要给 Chain 类再增加一个原型方法 Chain.prototype.next，表示手动传递请求给职责链中的下一个节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Chain.prototype.next = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.successor &amp;&amp; <span class="built_in">this</span>.successor.passRequest.apply(<span class="built_in">this</span>.successor, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步职责链</span></span><br><span class="line"><span class="keyword">let</span> fn1 = <span class="keyword">new</span> Chain(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;nextSuccessor&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn2 = <span class="keyword">new</span> Chain(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">let</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    self.next();</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn3 = <span class="keyword">new</span> Chain(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;);</span><br><span class="line">fn1.setNextSuccessor(fn2).setNextSuccessor(fn3);</span><br><span class="line">fn1.passRequest();</span><br></pre></td></tr></table></figure><p>现在我们得到了一个特殊的链条，请求在链中的节点里传递，但节点有权利决定什么时候把 请求交给下一个节点。可以想象，异步的职责链加上命令模式(把 ajax 请求封装成命令对象)，我们可以很方便地创建一个异步 ajax 队列库。</p><h2 id="AOP实现职责链"><a href="#AOP实现职责链" class="headerlink" title="AOP实现职责链"></a>AOP实现职责链</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ret = self.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret === <span class="string">&quot;nextSuccessor&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> order = order500.after(order200).after(orderNormal);</span><br><span class="line">order(<span class="number">1</span>, <span class="literal">true</span>, <span class="number">500</span>);    <span class="comment">// 输出:500 元定金预购，得到 100 优惠券</span></span><br><span class="line">order(<span class="number">2</span>, <span class="literal">true</span>, <span class="number">500</span>);    <span class="comment">// 输出:200 元定金预购，得到 50 优惠券</span></span><br><span class="line">order(<span class="number">1</span>, <span class="literal">false</span>, <span class="number">500</span>);   <span class="comment">// 输出:普通购买，无优惠券</span></span><br></pre></td></tr></table></figure><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>但是职责链模式并不能保证某个请求一定会被链中的节点处理，而是径直的从链尾离开，这种情况下，我们可以在链尾<strong>增加一个保底的接受者节点来处理这种即将离开链尾的请求</strong>。</p><p>并且职责链模式使得程序中多了一些节点对象，可能在某一次的请求传递过程中，并没有起到实质性的作用，它们的作用仅仅是让请求传递下去，从性能方面考虑，我们要<strong>避免过长的职责链</strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《javascript设计模式与开发实践》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;职责链模式&quot;&gt;&lt;a href=&quot;#职责链模式&quot; class=&quot;headerlink&quot; title=&quot;职责链模式&quot;&gt;&lt;/a&gt;职责链模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;职责链模式的定义是：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://liang5757.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="js" scheme="https://liang5757.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>享元模式</title>
    <link href="https://liang5757.github.io/2021/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <id>https://liang5757.github.io/2021/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-02-06T07:35:23.000Z</published>
    <updated>2021-02-14T07:36:30.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><blockquote><p>享元(flyweight)模式是一种用于性能优化的模式，“fly”在这里是苍蝇的意思，意为“蝇量级”。享元模式的核心是运用共享技术来有效支持大量细粒度的对象。</p><p>如果系统中因为创建了大量类似的对象而导致内存占用过高，享元模式就非常有用了。在 JavaScript 中，浏览器特别是移动端的浏览器分配的内存并不算多，如何节省内存就成了一件非常有意义的事情。</p></blockquote><h2 id="故事背景"><a href="#故事背景" class="headerlink" title="故事背景"></a>故事背景</h2><p>​    假设有个内衣工厂，目前的产品有 50 种男式内衣和 50 种女士内衣，为了推销产品，工厂决定生产一些塑料模特来穿上他们的内衣拍成广告照片。 正常情况下需要 50个男模特和50个女模特，然后让他们每人分别穿上一件内衣来拍照。</p><h2 id="代码实现-未使用享元模式"><a href="#代码实现-未使用享元模式" class="headerlink" title="代码实现(未使用享元模式)"></a>代码实现(未使用享元模式)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">sex, underwear</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    <span class="built_in">this</span>.underwear = underwear;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">takePhoto</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;sex= &#x27;</span> + <span class="built_in">this</span>.sex + <span class="string">&#x27; underwear=&#x27;</span> + <span class="built_in">this</span>.underwear);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> maleModel = <span class="keyword">new</span> Model(<span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;underwear&#x27;</span> + i);</span><br><span class="line">  maleModel.takePhoto();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= <span class="number">50</span>; j++) &#123;</span><br><span class="line">  <span class="keyword">let</span> femaleModel = <span class="keyword">new</span> Model(<span class="string">&#x27;female&#x27;</span>, <span class="string">&#x27;underwear&#x27;</span> + j);</span><br><span class="line">  femaleModel.takePhoto();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考：真的需要如此多数量的对象吗？"><a href="#思考：真的需要如此多数量的对象吗？" class="headerlink" title="思考：真的需要如此多数量的对象吗？"></a>思考：真的需要如此多数量的对象吗？</h2><p>​    如上所述，现在一共有 50 种男内 衣和 50 种女内衣，所以一共会产生 100 个对象。如果将来生产了 10000 种内衣，那这个程序可能会因为存在如此多的对象已经提前崩溃。 下面我们来考虑一下如何优化这个场景。虽然有 100 种内衣，但很显然并不需要 50 个男模特和 50 个女模特。其实男模特和女模特各自有一个就足够了，他们可以分别穿上不同的内衣来拍照。</p><h2 id="代码重构-享元模式"><a href="#代码重构-享元模式" class="headerlink" title="代码重构(享元模式)"></a>代码重构(享元模式)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只需要区别男女模特</span></span><br><span class="line"><span class="comment">//  那我们先把 underwear 参数从构造函数中 移除，构造函数只接收 sex 参数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">sex</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.sex = sex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">takePhoto</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;sex= &#x27;</span> + <span class="built_in">this</span>.sex + <span class="string">&#x27; underwear=&#x27;</span> + <span class="built_in">this</span>.underwear);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分别创建一个男模特对象和一个女模特对象</span></span><br><span class="line"><span class="keyword">let</span> maleModel = <span class="keyword">new</span> Model(<span class="string">&#x27;male&#x27;</span>),</span><br><span class="line">  femaleModel = <span class="keyword">new</span> Model(<span class="string">&#x27;female&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给男模特依次穿上所有的男装，并进行拍照</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">  maleModel.underwear = <span class="string">&#x27;underwear&#x27;</span> + i; <span class="comment">// 设置外部状态</span></span><br><span class="line">  maleModel.takePhoto();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给女模特依次穿上所有的女装，并进行拍照</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= <span class="number">50</span>; j++) &#123;</span><br><span class="line">  femaleModel.underwear = <span class="string">&#x27;underwear&#x27;</span> + j; <span class="comment">// 设置外部状态</span></span><br><span class="line">  femaleModel.takePhoto();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要两个对象便完成了同样的功能</p><h2 id="如何使用享元模式"><a href="#如何使用享元模式" class="headerlink" title="如何使用享元模式"></a>如何使用享元模式</h2><p>享元模式要求将对象的属性划分为<strong>内部状态</strong>与<strong>外部状态</strong>(状态在这里通常指属性)。享元模式的目标是尽量减少共享对象的数量，关于如何划分内部状态和外部状态，下面的几条经验提供了一些指引</p><ul><li>内部状态可以被一些对象共享</li><li>内部状态独立于具体的场景，通常不会改变</li><li>外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享</li></ul><p>在上面的例子中，<strong>性别是内部状态，内衣是外部状态</strong>，通过区分这两种状态，大大减少了系统中的对象数量。通常来讲，内部状态有多少种组合，系统中便最多存在多少个对象，因为性别通常只有男女两种，所以该内衣厂商最多只需要 2 个对象。</p><h2 id="享元模式的通用结构"><a href="#享元模式的通用结构" class="headerlink" title="享元模式的通用结构"></a>享元模式的通用结构</h2><h3 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h3><ol><li>我们通过构造函数显示<code>new</code>出了男女两个model对象，在其他系统中，<strong>也许并不是一开始就需要所有的共享对象</strong></li><li>给<code>model</code>对象手动设置了<code>underwear</code>外部状态，在更复杂的系统中，这不是一个最好的方式，因为<strong>外部状态可能相当复杂，它们与共享对象的联系会变得困难</strong></li></ol><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>第一个问题可以用<strong>工厂模式</strong>解决，如果某种内部状态对应的共享对象已经被创建过，那么直接返回这个对象</p><p>第二个问题可以<strong>用一个管理器记录对象相关的外部状态</strong>，使这些外部状态通过某个钩子和共享对象联系起来</p><h2 id="享元模式的替代方案-——-对象池"><a href="#享元模式的替代方案-——-对象池" class="headerlink" title="享元模式的替代方案 —— 对象池"></a>享元模式的替代方案 —— 对象池</h2><p>​    对象池是另外一种性能优化方案，它跟享元模式有一些相似之处，但没有分离内部状态和外部状态这个过程。对象池维护一个装载空闲对象的池子，如果需要对象的时候，不是直接 new，而是转从对象池里获取。如果对象池里没有空闲对象，则创建一个新的对象，当获取出的对象完成它的职责之后， 再进入池子等待被下次获取。</p><h3 id="通用的对象池实现"><a href="#通用的对象池实现" class="headerlink" title="通用的对象池实现"></a>通用的对象池实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用的对象池</span></span><br><span class="line"><span class="keyword">let</span> objectPoolFactory = <span class="function"><span class="keyword">function</span> (<span class="params">createObjFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> objectPool = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    create: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> objectPool.length === <span class="number">0</span> ?</span><br><span class="line">        createObjFn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>) : objectPool.shift();</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    recover: <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">      objectPool.push(obj);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在利用<code>objectPoolFactory</code>来创建一个装载一些 iframe 的对象池</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iframeFactory = objectPoolFactory(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">&quot;iframe&quot;</span>);</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line">  iframe.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    iframe.onload = <span class="literal">null</span>; <span class="comment">// 防止 iframe 重复加载的 bug</span></span><br><span class="line">    iframeFactory.recover(iframe);<span class="comment">// iframe 加载完成之后回收节点</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> iframe;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iframe1 = iframeFactory.create();</span><br><span class="line">iframe1.src = <span class="string">&quot;http:// baidu.com&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iframe2 = iframeFactory.create();</span><br><span class="line">iframe2.src = <span class="string">&quot;http:// QQ.com&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> iframe3 = iframeFactory.create();</span><br><span class="line">  iframe3.src = <span class="string">&quot;http:// 163.com&quot;</span>;</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>对象池的应用非常广泛，HTTP连接池和数据库连接池都是其代表应用，也可以用在dom的重复利用上。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《javascript设计模式与开发实践》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;享元模式&quot;&gt;&lt;a href=&quot;#享元模式&quot; class=&quot;headerlink&quot; title=&quot;享元模式&quot;&gt;&lt;/a&gt;享元模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;享元(flyweight)模式是一种用于性能优化的模式，“fly”在这里是苍蝇的意思，意为“蝇量级
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://liang5757.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="js" scheme="https://liang5757.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>模板方法模式</title>
    <link href="https://liang5757.github.io/2021/02/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>https://liang5757.github.io/2021/02/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-02-05T07:34:10.000Z</published>
    <updated>2021-02-14T07:35:30.306Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><blockquote><p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行</p></blockquote><h2 id="Coffee-or-Tea"><a href="#Coffee-or-Tea" class="headerlink" title="Coffee or Tea"></a>Coffee or Tea</h2><p>我们现在需要冲泡一杯咖啡和一壶茶，它们的操作步骤基本上是一样的，如下所示</p><table><thead><tr><th>泡咖啡</th><th>泡茶</th></tr></thead><tbody><tr><td>把水煮沸</td><td>把水煮沸</td></tr><tr><td>用沸水冲泡<strong>咖啡</strong></td><td>用沸水浸泡<strong>茶叶</strong></td></tr><tr><td>把<strong>咖啡</strong>倒进杯子</td><td>把<strong>茶水</strong>倒进杯子</td></tr><tr><td><strong>加糖和牛奶</strong></td><td><strong>加柠檬</strong></td></tr></tbody></table><p> 基本的步骤是一样的，我们可以使用抽象类的形式，把步骤框架抽象出来，Coffee类和Tea类继承这个抽象类，再各自实现抽象父类上的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个抽象父类来表示泡一杯饮料的整个过程。</span></span><br><span class="line"><span class="comment">// 不论是 Coffee,还是 Tea,都被我们用Beverage来表示</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">boilWater</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;把水煮沸&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">brew</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;子类必须重写 brew 方法&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">pourInCup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;子类必须重写 pourInCup 方法&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">addCondiments</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;子类必须重写 addCondiments 方法&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123; <span class="comment">// 模板方法</span></span><br><span class="line">    <span class="built_in">this</span>.boilWater();</span><br><span class="line">    <span class="built_in">this</span>.brew();</span><br><span class="line">    <span class="built_in">this</span>.pourInCup();</span><br><span class="line">    <span class="built_in">this</span>.addCondiments();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Coffee类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> <span class="keyword">extends</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">brew</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;用沸水冲泡咖啡&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">pourInCup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;把咖啡倒进杯子&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">addCondiments</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;加糖和牛奶&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> coffee = <span class="keyword">new</span> Coffee();</span><br><span class="line">coffee.init();</span><br><span class="line"><span class="comment">// 把水煮沸</span></span><br><span class="line"><span class="comment">// 用沸水冲泡咖啡</span></span><br><span class="line"><span class="comment">// 把咖啡倒进杯子</span></span><br><span class="line"><span class="comment">// 加糖和牛奶</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Tea类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tea</span> <span class="keyword">extends</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">brew</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;用沸水浸泡茶叶&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">pourInCup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;把茶倒进杯子&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">addCondiments</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;加柠檬&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tea = <span class="keyword">new</span> Tea();</span><br><span class="line">tea.init();</span><br><span class="line"><span class="comment">// 把水煮沸</span></span><br><span class="line"><span class="comment">// 用沸水浸泡茶叶</span></span><br><span class="line"><span class="comment">// 把茶倒进杯子</span></span><br><span class="line"><span class="comment">// 加柠檬</span></span><br></pre></td></tr></table></figure><p>上面代码中，Beverage父类里的<code>init</code>方法即为<strong>模板方法</strong>，init封装了子类的算法框架，作为算法的模板，指导子类以何种顺序去执行哪些方法。</p><h2 id="好莱坞原则"><a href="#好莱坞原则" class="headerlink" title="好莱坞原则"></a>好莱坞原则</h2><p>​    好莱坞无疑是演员的天堂，但好莱坞也有很多找不到工作的新人演员，许多新人演员在好莱坞把简历递给演艺公司之后就只有回家等待电话。有时候该演员等得不耐烦了，给演艺公司打电话询问情况，演艺公司往往这样回答：“不要来找我，我会给你打电话。” 在设计中，这样的规则就称为好莱坞原则。在这一原则的指导下，我们允许底层组件将自己挂钩到高层组件中，而高层组件会决定什么时候、以何种方式去使用这些底层组件，高层组件对 待底层组件的方式，跟演艺公司对待新人演员一样，都是“别调用我们，我们会调用你”。<br>​    比如发布订阅模式和回调函数</p><h2 id="是否真的需要继承"><a href="#是否真的需要继承" class="headerlink" title="是否真的需要继承"></a>是否真的需要继承</h2><p>在JavaScript这种灵活的语言中，我们是否真的需要使用继承这种重武器呢。在好莱坞原则的指导下，我们可以重构上面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Beverage = <span class="function"><span class="keyword">function</span> (<span class="params">param</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> boilWater = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;把水煮沸&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> brew = param.brew || <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;必须传递 brew 方法&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> pourInCup = param.pourInCup || <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;必须传递 pourInCup 方法&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> addCondiments = param.addCondiments || <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;必须传递 addCondiments 方法&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  F.prototype.init = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    boilWater();</span><br><span class="line">    brew();</span><br><span class="line">    pourInCup();</span><br><span class="line">    addCondiments();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Coffee = Beverage(&#123;</span><br><span class="line">  <span class="function"><span class="title">brew</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;用沸水冲泡咖啡&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">pourInCup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;把咖啡倒进杯子&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">addCondiments</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;加糖和牛奶&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Tea = Beverage(&#123;</span><br><span class="line">  <span class="function"><span class="title">brew</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;用沸水浸泡茶叶&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">pourInCup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;把茶倒进杯子&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">addCondiments</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;加柠檬&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    模板方法模式是一种典型的通过封装变化提高系统扩展性的设计模式。在传统的面向对象语言中，一个运用了模板方法模式的程序中，子类的方法种类和执行顺序都是不变的，所以我们把这部分逻辑抽象到父类的模板方法里面。而子类的方法具体怎么实现则是可变的，于是我们把这部分变化的逻辑封装到子类中。通过增加新的子类，我们便能给系统增加新的功能，并不需要改动抽象父类以及其他子类，这也是符合开放-封闭原则的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《javascript设计模式与开发实践》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;模板方法模式&quot;&gt;&lt;a href=&quot;#模板方法模式&quot; class=&quot;headerlink&quot; title=&quot;模板方法模式&quot;&gt;&lt;/a&gt;模板方法模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://liang5757.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="js" scheme="https://liang5757.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>组合模式</title>
    <link href="https://liang5757.github.io/2021/02/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <id>https://liang5757.github.io/2021/02/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-02-04T07:32:50.000Z</published>
    <updated>2021-02-14T07:35:01.304Z</updated>
    
    <content type="html"><![CDATA[<h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><blockquote><p>组合模式将对象组合成树形结构，以表示“部分-整体”的层次结构。 除了用来表示树形结构之外，组合模式的另一个好处是通过对象的多态性表现，使得用户对单个对象和组合对象的使用具有一致性</p></blockquote><p>​    在组合模式中，请求在树中传递的过程总是遵循一种逻辑。请求从树最顶端的对象往下传递，如果当前处理请求的对象是叶对象(普通子命令)，叶对象自身会对请求作出相应的处理，如果当前处理请求的对象是组合对象(宏命令)， 组合对象则会遍历它属下的子节点，将请求继续传递给这些子节点。</p><p><img src= "/img/loading.gif" data-lazy-src="/2021/02/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/167b6de69881f746" alt="组合模式请求传递方式"></p><h2 id="组合模式下更为强大的宏命令"><a href="#组合模式下更为强大的宏命令" class="headerlink" title="组合模式下更为强大的宏命令"></a>组合模式下更为强大的宏命令</h2><p>​    目前的万能遥控器，包含了关门、开电脑、登录 QQ 这 3 个命令。现在我们需要一个“超级万能遥控器”，可以控制家里所有的电器，这个遥控器拥有以下功能</p><ul><li>打开空调</li><li>打开电视和音响</li><li>关门、开电脑、登录 QQ</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> MacroCommand = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    commandsList: [],</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span> (<span class="params">command</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.commandsList.push(command);</span><br><span class="line">    &#125;,</span><br><span class="line">    execute: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, command; command = <span class="built_in">this</span>.commandsList[i++];) &#123;</span><br><span class="line">        command.execute();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> openAcCommand = &#123;</span><br><span class="line">  execute: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;打开空调&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 家里的电视和音响是连接在一起的，所以可以用一个宏命令来组合打开电视和打开音响的命令</span></span><br><span class="line"><span class="keyword">let</span> openTvCommand = &#123;</span><br><span class="line">  execute: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;打开电视&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> openSoundCommand = &#123;</span><br><span class="line">  execute: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;打开音响&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> macroCommand1 = MacroCommand();</span><br><span class="line">macroCommand1.add(openTvCommand);</span><br><span class="line">macroCommand1.add(openSoundCommand);</span><br><span class="line"><span class="comment">// 关门、打开电脑和打登录 QQ 的命令</span></span><br><span class="line"><span class="keyword">let</span> closeDoorCommand = &#123;</span><br><span class="line">  execute: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;关门&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> openPcCommand = &#123;</span><br><span class="line">  execute: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;开电脑&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> openQQCommand = &#123;</span><br><span class="line">  execute: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;登录 QQ&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> macroCommand2 = MacroCommand();</span><br><span class="line">macroCommand2.add(closeDoorCommand);</span><br><span class="line">macroCommand2.add(openPcCommand);</span><br><span class="line">macroCommand2.add(openQQCommand);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在把所有的命令组合成一个“超级命令”</span></span><br><span class="line"><span class="keyword">let</span> macroCommand = MacroCommand();</span><br><span class="line">macroCommand.add(openAcCommand);</span><br><span class="line">macroCommand.add(macroCommand1);</span><br><span class="line">macroCommand.add(macroCommand2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后给遥控器绑定“超级命令”</span></span><br><span class="line"><span class="keyword">let</span> setCommand = (<span class="function"><span class="keyword">function</span> (<span class="params">command</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;button&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    command.execute();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(macroCommand);</span><br></pre></td></tr></table></figure><p>​    <strong>不管是宏命令对象，还是子命令对象，都有一个execute方法负责执行命令</strong>。<br>​    这在静态类型语言中实现显的尤为便利，比如在JAVA中，<code>Composite</code>类和<code>Leaf</code>类都必须继承自一个<code>Compenent</code>抽象类，这个Compenent抽象即表示组合对象，又代表叶对象，它也能保证两者均有<code>execute</code>方法，从而做出反馈。</p><p>​    但是在JavaScript这种动态语言中实现组合模式，由于鸭子类型，我们并不需要有一个<code>Compenent</code>抽象类，但是这也导致了一定的严谨性。</p><h2 id="透明性带来的安全问题"><a href="#透明性带来的安全问题" class="headerlink" title="透明性带来的安全问题"></a>透明性带来的安全问题</h2><p>我们可以给叶子节点也增加<code>add</code>方法，并在调用的时候，抛出一个异常来提醒客户。比如上面的打开电视的命令对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> openTvCommand = &#123;</span><br><span class="line">  execute: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;打开电视&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  add: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 同样的添加add方法</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;叶对象不能添加子节点&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="应用场景-—-扫描文件夹"><a href="#应用场景-—-扫描文件夹" class="headerlink" title="应用场景 — 扫描文件夹"></a>应用场景 — 扫描文件夹</h2><p>​    文件夹和文件之间的关系，非常适合用组合模式来描述。文件夹里既可以包含文件，又可以包含其他文件夹，最终可能组合成一棵树 当使用用杀毒软件扫描该文件夹时，往往不会关心里面有多少文件和子文件夹，组合模式使得我们只需要操作最外层的文件夹进行扫描。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><h3 id="组合模式不是父子关系"><a href="#组合模式不是父子关系" class="headerlink" title="组合模式不是父子关系"></a>组合模式不是父子关系</h3><p>​    组合模式是一种HAS-A（聚合）的关系，而不是IS-A；Leaf并不是Composite的子类。</p><h3 id="对叶对象操作的一致性"><a href="#对叶对象操作的一致性" class="headerlink" title="对叶对象操作的一致性"></a>对叶对象操作的一致性</h3><p>​    组合模式除了要求组合对象和叶子对象拥有相同的接口之外，还有一个必要条件，就是对一组叶对象的操作的一致性。</p><p>​    比如公司要给全体员工发元旦的过节费1000元，这个场景可以运用组合模式，但如果公司要给今天过生日的员工发送一封生日祝福的邮件，组合模式就做不到了，除非先把今天过生日的员工挑选出来。只有用一致的方式对待列表中的每一个叶子对象的时候，才适合使用组合模式。</p><h3 id="双向映射关系"><a href="#双向映射关系" class="headerlink" title="双向映射关系"></a>双向映射关系</h3><p>​    发放过节费的通知步骤是从公司到各个部门，再到各个小组，最后到每个员工的邮箱里。这本身是一个组合模式的好例子，但某些员工可能隶属于多个组织，对象之间的关系并不是严格意义上的层次结构，在这种情况下，是不适合使用组合模式的，该员工可能收到多份过节费。</p><p>​    这种复合情况下我们必须给父节点和子节点建立双向映射关系，一个简单的方法是给小组和员工对象都增加集合来保存对方的引用。<br>但是这种相互间的引用相当复杂，而且对象之间产生了过多的耦合性，修改或者删除一个对象都变得困难，此时我们可以引入中介者模式来管理这些对象。</p><h3 id="用职责链模式提高组合模式性能"><a href="#用职责链模式提高组合模式性能" class="headerlink" title="用职责链模式提高组合模式性能"></a>用职责链模式提高组合模式性能</h3><p>​    在组合模式中，如果树的结构比较复杂，节点数量很多，在遍历树的过程中，性能方面也许表现的不够理想，我们可以借助职责链模式避免遍历整棵树。职责链模式一般需要我们手动去设置链条，但在组合模式中，父对象和子对象之间实际形成了天然的职责链。让请求顺着链条从父对象往子对象传递，或者是反过来从子对象往父对象传递，直到遇到可以处理该请求的对象位置。</p><h2 id="引用父对象"><a href="#引用父对象" class="headerlink" title="引用父对象"></a>引用父对象</h2><p>在组合模式中使用职责链时，有可能需要让请求从子节点往父节点上冒泡传递</p><p>在文件系统中，当我们删除某个文件夹的时候，实际上是从这个文件夹所在的上层文件夹中删除改文件的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Folder</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.parent = <span class="literal">null</span>; <span class="comment">// 增加 this.parent 属性</span></span><br><span class="line">    <span class="built_in">this</span>.files = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params">file</span>)</span> &#123;</span><br><span class="line">    file.parent = <span class="built_in">this</span>; <span class="comment">// 设置父对象</span></span><br><span class="line">    <span class="built_in">this</span>.files.push(file);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">scan</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;开始扫描文件夹: &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, file, files = <span class="built_in">this</span>.files; file = files[i++];) &#123;</span><br><span class="line">      file.scan();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.parent) &#123; <span class="comment">// 根节点或者树外的游离节点</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> files = <span class="built_in">this</span>.parent.files, l = files.length - <span class="number">1</span>; l &gt;= <span class="number">0</span>; l--) &#123; <span class="comment">// 从父目录下搜索删除当前文件或文件夹</span></span><br><span class="line">      <span class="keyword">let</span> file = files[l];</span><br><span class="line">      <span class="keyword">if</span> (file === <span class="built_in">this</span>) &#123;</span><br><span class="line">        files.splice(l, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.parent = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;不能添加在文件下面&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">scan</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;开始扫描文件: &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.parent) &#123; <span class="comment">//根节点或者树外的游离节点</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> files = <span class="built_in">this</span>.parent.files, l = files.length - <span class="number">1</span>; l &gt;= <span class="number">0</span>; l--) &#123;</span><br><span class="line">      <span class="keyword">let</span> file = files[l];</span><br><span class="line">      <span class="keyword">if</span> (file === <span class="built_in">this</span>) &#123;</span><br><span class="line">        files.splice(l, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="何时使用组合模式"><a href="#何时使用组合模式" class="headerlink" title="何时使用组合模式"></a>何时使用组合模式</h2><ul><li>表示对象的部分-整体层次结构。组合模式可以方便的构造一棵树来表示对象的部分-整体结构。<strong>特别是我们不确定该树到底存在多少层次的时候</strong></li><li>用户希望以统一的方式对待树中的所有对象</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>​    组合模式并不是完美的，它可能会产生一个这样的系统:系统中的每个对象看起来都与其他对象差不多。它们的区别只有在运行的时候会才会显现出来，这会使代码难以理解。此外,如果通过组合模式创建了太多的对象，那么这些对象可能会让系统负担不起。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《javascript设计模式与开发实践》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;组合模式&quot;&gt;&lt;a href=&quot;#组合模式&quot; class=&quot;headerlink&quot; title=&quot;组合模式&quot;&gt;&lt;/a&gt;组合模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;组合模式将对象组合成树形结构，以表示“部分-整体”的层次结构。 除了用来表示树形结构之外，组合模式
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://liang5757.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="js" scheme="https://liang5757.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>命令模式</title>
    <link href="https://liang5757.github.io/2021/02/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>https://liang5757.github.io/2021/02/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-02-03T07:32:07.000Z</published>
    <updated>2021-02-14T07:32:36.083Z</updated>
    
    <content type="html"><![CDATA[<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><blockquote><p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作</p></blockquote><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>​    有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。此时希望用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。</p><h3 id="菜单案例"><a href="#菜单案例" class="headerlink" title="菜单案例"></a>菜单案例</h3><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>  假设我们正在编写一个用户界面程序，该用户界面上至少有数十个 Button 按钮。因为项目比较复杂，所以我们决定让某个程序员负责绘制这些按钮，而另外一些程序员则负责编写点击按钮后的具体行为，这些行为都将被封装在对象里。</p><p>  在大型项目开发中，这是很正常的分工。对于绘制按钮的程序员来说，他完全不知道某个按钮未来将用来做什么，可能用来刷新菜单界面，也可能用来增加一些子菜单，他只知道点击这个 按钮会发生某些事情。那么当完成这个按钮的绘制之后，应该如何给它绑定<code>onclick</code> 事件呢?</p><p>  我们很快可以找到在这里运用命令模式的理由:点击了按钮之后，必须向某些负责具体行为的对象发送请求，这些对象就是请求的接收者。但是目前并不知道接收者是什么对象，也不知道接收者究竟会做什么。此时我们需要借助命令对象的帮助，以便解开按钮和负责具体行为对象之间的耦合。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> RefreshMenuBarCommand = <span class="function"><span class="keyword">function</span> (<span class="params">receiver</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        execute: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            receiver.refresh();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> setCommand = <span class="function"><span class="keyword">function</span> (<span class="params">button, command</span>) </span>&#123;</span><br><span class="line">    button.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> refreshMenuBarCommand = RefreshMenuBarCommand(MenuBar);</span><br><span class="line">setCommand(button1, refreshMenuBarCommand);</span><br></pre></td></tr></table></figure><h3 id="撤销和重做命令"><a href="#撤销和重做命令" class="headerlink" title="撤销和重做命令"></a>撤销和重做命令</h3><h4 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h4><p>  命令模式的作用不仅是封装运算块，而且可以很方便地给命令对象增加撤销操作。现在页面上有游戏需要对已经进行的操作进行<strong>回放</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Ryu = &#123;</span><br><span class="line">    <span class="function"><span class="title">attack</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;攻击&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">defense</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;防御&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">jump</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;跳跃&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">crouch</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;蹲下&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> makeCommand = <span class="function"><span class="keyword">function</span> (<span class="params">receiver, state</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> receiver[state];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> commands = &#123;</span><br><span class="line">    <span class="string">&quot;119&quot;</span>: <span class="string">&quot;jump&quot;</span>, <span class="comment">// w</span></span><br><span class="line">    <span class="string">&quot;115&quot;</span>: <span class="string">&quot;crouch&quot;</span>, <span class="comment">// s</span></span><br><span class="line">    <span class="string">&quot;97&quot;</span>: <span class="string">&quot;defense&quot;</span>, <span class="comment">// a</span></span><br><span class="line">    <span class="string">&quot;100&quot;</span>: <span class="string">&quot;attack&quot;</span>, <span class="comment">// d</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> commandStack = []; <span class="comment">// 保存命令的堆栈</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.onkeypress = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> keyCode = e.keyCode;</span><br><span class="line">    <span class="keyword">let</span> command = makeCommand(Ryu, commands[keyCode]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (command) &#123;</span><br><span class="line">        command();</span><br><span class="line">        commandStack.push(command);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;replay&quot;</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 点击播放录像</span></span><br><span class="line">    <span class="keyword">let</span> command;</span><br><span class="line">    <span class="keyword">while</span> (command = commandStack.shift()) &#123; <span class="comment">// 从堆栈获取此前的命令并执行</span></span><br><span class="line">        command();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>《javascript设计模式与开发实践》书上的这个例子写的更像是策略模式，书上为了和策略模式区分还把<code>receiver[state]()</code>用一个匿名函数给包起来，被我给删了，不要为了用设计模式而用设计模式。其实<strong>策略模式是对一系列算法的封装，使他们互相可替换</strong>，但<strong>命令模式是对一系列命令对象的封装，使接受者和发送者解耦</strong>。</p><h3 id="宏命令"><a href="#宏命令" class="headerlink" title="宏命令"></a>宏命令</h3><p>​    宏命令是一组命令的集合，通过执行宏命令的方式，可以一次执行一批命令。想象一下，家里有一个万能遥控器，每天回家的时候，只要按一个特别的按钮，它就会帮我们关上房间门，顺便打开电脑并登录 QQ。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> closeDoorCommand = &#123;</span><br><span class="line">  execute: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;关门&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> openPcCommand = &#123;</span><br><span class="line">  execute: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;开电脑&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> openQQCommand = &#123;</span><br><span class="line">  execute: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;登录 QQ&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> MacroCommand = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    commandsList: [],</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span> (<span class="params">command</span>) </span>&#123; <span class="comment">// 给宏命令添加指令</span></span><br><span class="line">      <span class="built_in">this</span>.commandsList.push(command);</span><br><span class="line">    &#125;,</span><br><span class="line">    execute: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 执行宏命令</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, command; command = <span class="built_in">this</span>.commandsList[i++];) &#123;</span><br><span class="line">        command.execute();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> macroCommand = MacroCommand();</span><br><span class="line"></span><br><span class="line">macroCommand.add(closeDoorCommand); </span><br><span class="line">macroCommand.add(openPcCommand);</span><br><span class="line">macroCommand.add(openQQCommand);</span><br><span class="line"></span><br><span class="line">macroCommand.execute();</span><br></pre></td></tr></table></figure><h3 id="智能命令与傻瓜命令"><a href="#智能命令与傻瓜命令" class="headerlink" title="智能命令与傻瓜命令"></a>智能命令与傻瓜命令</h3><p>​    上一个例子的命令没用包含任何<code>receiver</code>的信息，它本身就包揽了执行请求的行为，这跟我们之前看到的命令对象都包含了一个<code>receiver</code>是矛盾的。</p><p>​    一般来说，命令模式都会在command对象中保存一个接受者来负责真正执行客户的请求，这种情况下命令对象是“<strong>傻瓜式</strong>”的，它只负责把客户的请求转交给接受者来执行，这种模式的好处是请求的发起者和请求的接受者之间尽可能的解耦。</p><p>​    “聪明”的命令对象可以直接实现请求，这样一来就不需要接收者的存在，和策略模式非常接近，但命令模式解决的问题更具发散性。</p><p>​    命令模式还可以完成撤销、排队等功能</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《javascript设计模式与开发实践》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;命令模式&quot;&gt;&lt;a href=&quot;#命令模式&quot; class=&quot;headerlink&quot; title=&quot;命令模式&quot;&gt;&lt;/a&gt;命令模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://liang5757.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="js" scheme="https://liang5757.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>发布-订阅模式</title>
    <link href="https://liang5757.github.io/2021/02/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://liang5757.github.io/2021/02/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-02-02T07:31:09.000Z</published>
    <updated>2021-02-14T07:31:34.120Z</updated>
    
    <content type="html"><![CDATA[<h1 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h1><blockquote><p>又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知</p></blockquote><p>在js中，有一种很简单发布订阅模式，也就是DOM事件，<code>addEventListener</code>就可以实现订阅dom节点上的事件，触发事件后就执行回调</p><h2 id="1-自定义事件"><a href="#1-自定义事件" class="headerlink" title="1. 自定义事件"></a>1. 自定义事件</h2><p><strong>实现发布订阅的步骤</strong></p><ol><li>指定好发布者</li><li>为发布者添加一个缓存列表，用以存放回调函数以通知订阅者</li><li>发布消息的时候，发布者会遍历这个缓存列表，依次触发订阅者回调函数。</li></ol><p>下面用代码实现一下发布-订阅模式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订阅者回调函数</span></span><br><span class="line"><span class="keyword">interface</span> Observers &#123;</span><br><span class="line">  [event: <span class="built_in">string</span>]: <span class="built_in">Array</span>&lt;<span class="built_in">Function</span>&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布者</span></span><br><span class="line"><span class="keyword">let</span> publisher = &#123;</span><br><span class="line">  observers: &lt;Observers&gt;&#123;&#125;, <span class="comment">// 存放订阅者回调函数</span></span><br><span class="line">  <span class="comment">// 增加订阅者</span></span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params">event, fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.observers[event]) &#123;</span><br><span class="line">      <span class="built_in">this</span>.observers[event] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.observers[event].push(fn); <span class="comment">// 添加订阅者到缓存列表</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 移除订阅者</span></span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params">event, fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> fns = <span class="built_in">this</span>.observers[event];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fns) &#123; <span class="comment">// 如果该事件没有订阅者，则返回</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!fn) &#123; <span class="comment">// 如果没有传入订阅者回调函数，则表示取消该事件的所有订阅者</span></span><br><span class="line">      fns &amp;&amp; (fns.length = <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> l = fns.length - <span class="number">1</span>; l &gt;= <span class="number">0</span>; l--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fns[l] === fn) &#123;</span><br><span class="line">          fns.splice(l, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 发布消息，通知所有订阅者</span></span><br><span class="line">  <span class="function"><span class="title">trigger</span>(<span class="params">event, ...args</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> fns = <span class="built_in">this</span>.observers[event];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fns || fns.length === <span class="number">0</span>) &#123; <span class="comment">// 如果没有订阅者，返回false</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, fn; fn = fns[i++];) &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, args); <span class="comment">// 触发订阅者回调函数</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要实现一个通用的发布-订阅模式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> installEvent = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> publisher) &#123;</span><br><span class="line">    obj[i] = publisher[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们来尝试使用一下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> salesOffices: <span class="built_in">any</span> = &#123;&#125;;</span><br><span class="line">installEvent(salesOffices);</span><br><span class="line"></span><br><span class="line">salesOffices.add(<span class="string">&#x27;squareMeter88&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;小美&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;价格=&#x27;</span> + price);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">salesOffices.add(<span class="string">&#x27;squareMeter100&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">price</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;小明&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;价格=&#x27;</span> + price);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">salesOffices.trigger(<span class="string">&#x27;squareMeter88&#x27;</span>, <span class="number">20000</span>); <span class="comment">// 小明 20000</span></span><br><span class="line">salesOffices.trigger(<span class="string">&#x27;squareMeter100&#x27;</span>, <span class="number">30000</span>); <span class="comment">// 小美 30000</span></span><br></pre></td></tr></table></figure><p>但是这样<code>salesOffices</code>对象依旧具有耦合度，<strong>订阅者必须知道发布者的名字，才能订阅到事件</strong>，可以<strong>使用全局的发布者Event对象</strong>进行发布，就像vue中的<code>eventBus</code>，这样做虽然减少了耦合度，但是<strong>消息来自哪个模块，以及会流向哪个模块都是不直观的</strong>，容易带来维护性上的问题，并且通过全局的来订阅发布消息，容易造成<strong>命名冲突</strong>。</p><h2 id="2-发布-订阅模式的两种模型"><a href="#2-发布-订阅模式的两种模型" class="headerlink" title="2.发布-订阅模式的两种模型"></a>2.发布-订阅模式的两种模型</h2><ol><li>推模型：当一个事件发生后将通知所有订阅者，并把所有的新数据传给他们</li><li>拉模型：当一个事件发生后将通知所有订阅者，每个订阅者将拉取自己需要的数据<ul><li>可以让订阅者按需获取</li><li>但有可能让发布者变成一个“门户大开”的对象，同时增加代码量和复杂度</li></ul></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《javascript设计模式与开发实践》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;发布-订阅模式&quot;&gt;&lt;a href=&quot;#发布-订阅模式&quot; class=&quot;headerlink&quot; title=&quot;发布-订阅模式&quot;&gt;&lt;/a&gt;发布-订阅模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://liang5757.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="js" scheme="https://liang5757.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>迭代器模式</title>
    <link href="https://liang5757.github.io/2021/02/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://liang5757.github.io/2021/02/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-02-01T07:29:36.000Z</published>
    <updated>2021-02-14T07:30:42.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><blockquote><p>是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</p></blockquote><p>js有许多迭代器模式实现，比如说forEach，es6的yield</p><h2 id="1-内部迭代器和外部迭代器"><a href="#1-内部迭代器和外部迭代器" class="headerlink" title="1. 内部迭代器和外部迭代器"></a>1. 内部迭代器和外部迭代器</h2><h3 id="1-1-内部迭代器"><a href="#1-1-内部迭代器" class="headerlink" title="1.1 内部迭代器"></a>1.1 内部迭代器</h3><blockquote><p>内部定义好迭代规则，外部只需要一次初始调用</p></blockquote><p>比如说jquery的<code>$.each</code>，以及js的<code>for...of</code></p><h3 id="1-2-外部迭代器"><a href="#1-2-外部迭代器" class="headerlink" title="1.2 外部迭代器"></a>1.2 外部迭代器</h3><blockquote><p>显示的请求迭代下一个元素，迭代流程由外部控制</p></blockquote><p>比如说es6的迭代器<code>yield</code></p><h2 id="2-实现一个-each的迭代器"><a href="#2-实现一个-each的迭代器" class="headerlink" title="2. 实现一个$.each的迭代器"></a>2. 实现一个$.each的迭代器</h2><p>可以遍历类数组对象以及字面量对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">each</span>(<span class="params">obj, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> length, i = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 判断是否为类数组对象</span></span><br><span class="line">  <span class="keyword">if</span> (isArrayLike(obj)) &#123;</span><br><span class="line">    length = obj.length;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="comment">// 如果回调函数放回false，中断迭代器</span></span><br><span class="line">      <span class="keyword">if</span> (callback.call(obj[i], i, obj[i]) === <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span> (callback.call(obj[i], i, obj[i]) === <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = &#123; <span class="number">0</span>: <span class="string">&quot;a&quot;</span>, <span class="number">1</span>: <span class="string">&quot;b&quot;</span>, <span class="attr">length</span>: <span class="number">2</span> &#125;</span><br><span class="line">each(data, <span class="function">(<span class="params">key, val</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, val); </span><br><span class="line">  <span class="comment">// 0 a</span></span><br><span class="line">  <span class="comment">// 1 b</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-手动实现es6的简易迭代器"><a href="#3-手动实现es6的简易迭代器" class="headerlink" title="3. 手动实现es6的简易迭代器"></a>3. 手动实现es6的简易迭代器</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义生成器函数，入参是任意集合</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iteratorGenerator</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// idx记录当前访问的索引</span></span><br><span class="line">  <span class="keyword">let</span> idx = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// len记录传入集合的长度</span></span><br><span class="line">  <span class="keyword">const</span> len = list.length;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 自定义next方法</span></span><br><span class="line">    next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 如果索引还没有超出集合长度，done 为 false</span></span><br><span class="line">      <span class="keyword">const</span> done = idx &gt;= len;</span><br><span class="line">      <span class="comment">// 如果done为false，则可以继续取值</span></span><br><span class="line">      <span class="keyword">const</span> value = !done ? list[idx++] : <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将当前值与遍历是否完毕（done）返回</span></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        done: done,</span><br><span class="line">        value: value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《javascript设计模式与开发实践》<br>《<a href="https://juejin.cn/book/6844733790204461070/section">JavaScript 设计模式核⼼原理与应⽤实践</a>》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;迭代器模式&quot;&gt;&lt;a href=&quot;#迭代器模式&quot; class=&quot;headerlink&quot; title=&quot;迭代器模式&quot;&gt;&lt;/a&gt;迭代器模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://liang5757.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="js" scheme="https://liang5757.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>代理模式</title>
    <link href="https://liang5757.github.io/2021/01/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>https://liang5757.github.io/2021/01/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-01-30T18:14:43.000Z</published>
    <updated>2021-02-14T07:22:40.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><blockquote><p>为其他对象提供一种代理以控制对这个对象的访问</p></blockquote><p><strong>特点如下</strong></p><ol><li>代理对象可预先处理请求，再决定是否转交给本体；</li><li>代理和本体对外显示接口保持一致性</li><li>代理对象仅对本体做一次包装</li></ol><h2 id="1-模式细分"><a href="#1-模式细分" class="headerlink" title="1. 模式细分"></a>1. 模式细分</h2><ol><li>虚拟代理（将开销大的运算交给代理，延迟到需要时执行）</li><li>缓存代理（为开销大的运算结果提供缓存）</li><li>保护代理（用于对象应该有不同的访问权限）</li><li>防火墙代理（控制网络资源的访问）</li><li>远程代理（为一个对象在不同的地址控件提供局部代表）</li><li>智能引用代理（访问对象执行一些附加操作）</li><li>写时复制代理（延迟对象复制过程，对象需要真正修改时才进行）</li></ol><h2 id="2-虚拟代理实现图片预加载"><a href="#2-虚拟代理实现图片预加载" class="headerlink" title="2. 虚拟代理实现图片预加载"></a>2. 虚拟代理实现图片预加载</h2><p>在所需图片未加载前，用loading图片占位，然后用异步的方式加载图片，等图片加载好了，替换掉loading，下面先不用代理模式实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> MyImage = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> imgNode = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(imgNode);</span><br><span class="line">  <span class="keyword">let</span> img = <span class="keyword">new</span> Image;</span><br><span class="line">  </span><br><span class="line">  img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    imgNode.src = img.src; <span class="comment">// 图片加载完成后替换loading</span></span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    setSrc: <span class="function"><span class="keyword">function</span> (<span class="params">src</span>) </span>&#123;</span><br><span class="line">      imgNode.src = <span class="string">&quot;file://loading.gif&quot;</span>; <span class="comment">// 先显示loading图片</span></span><br><span class="line">      img.src = src; <span class="comment">// 虚拟dom结构加载图片</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>违背了单一职责原则，在这种高耦合的情况下，如果不需要loading效果，那么只能在<code>MyImage</code>下动刀。</p><p>接下来我们用虚拟代理重构一下这段代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载图片</span></span><br><span class="line"><span class="keyword">let</span> myImage = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> imgNode = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(imgNode);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    setSrc: <span class="function"><span class="keyword">function</span> (<span class="params">src</span>) </span>&#123;</span><br><span class="line">      imgNode.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 虚拟代理</span></span><br><span class="line"><span class="keyword">let</span> proxyImage = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> img = <span class="keyword">new</span> Image;</span><br><span class="line">  </span><br><span class="line">  img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    myImage.setSrc(<span class="built_in">this</span>.src); </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    setSrc: <span class="function"><span class="keyword">function</span> (<span class="params">src</span>) </span>&#123;</span><br><span class="line">      myImage.setSrc(<span class="string">&quot;file://loading.gif&quot;</span>);</span><br><span class="line">      img.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">proxyImage.setSrc( <span class="string">&#x27;http://www.lll.com/photo/true.jpg&#x27;</span> );</span><br></pre></td></tr></table></figure><p>这样就解耦了</p><h2 id="3-虚拟代理在惰性加载中的应用"><a href="#3-虚拟代理在惰性加载中的应用" class="headerlink" title="3. 虚拟代理在惰性加载中的应用"></a>3. 虚拟代理在惰性加载中的应用</h2><p>实现一个等用户按<code>F2</code>唤出控制台的时候，再开始加载miniConsole.js代码，并在加载完成后执行<code>cache</code>中的log函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> miniConsole = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> cache = [];</span><br><span class="line">  <span class="keyword">let</span> handler = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e.keyCode === <span class="number">113</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">      script.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, fn; fn = cache[i++];) &#123;</span><br><span class="line">          fn();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      script.src = <span class="string">&quot;miniConsole.js&quot;</span>;</span><br><span class="line">      <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>].appendChild(script);</span><br><span class="line">      <span class="built_in">document</span>.body.removeEventListener(<span class="string">&quot;keydown&quot;</span>, handler); <span class="comment">// 只加载一次miniConsole.js</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">document</span>.body.addEventListener(<span class="string">&quot;keydown&quot;</span>, handler, <span class="literal">false</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    log: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">      cache.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> miniConsole().log.apply(miniConsole().args);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">miniConsole.log(<span class="number">11</span>);</span><br></pre></td></tr></table></figure><h2 id="4-缓存代理计算乘积"><a href="#4-缓存代理计算乘积" class="headerlink" title="4. 缓存代理计算乘积"></a>4. 缓存代理计算乘积</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mult = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    a *= <span class="built_in">arguments</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxyMult = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> cache = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">Array</span>.prototype.join.call(<span class="built_in">arguments</span>, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (args <span class="keyword">in</span> cache) &#123;</span><br><span class="line">      <span class="keyword">return</span> cache[args];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache[args] = mult.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">proxyMult(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 6</span></span><br><span class="line">proxyMult(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 不会重复计算</span></span><br></pre></td></tr></table></figure><h2 id="5-ES6中的Proxy"><a href="#5-ES6中的Proxy" class="headerlink" title="5. ES6中的Proxy"></a>5. ES6中的Proxy</h2><blockquote><p>ES6 的 Proxy语法：let proxyObj = new Proxy(target, handler);</p></blockquote><ul><li>target: 本体，要代理的对象</li><li>handler: 自定义操作方法集合</li><li>proxyObj: 返回的代理对象，拥有本体的方法，不过会被 <code>handler</code> 预处理</li></ul><p>可以拦截并控制对对象的访问，下面是用Proxy实现的代理工厂</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getCacheProxy = <span class="function">(<span class="params">fn, cache = <span class="keyword">new</span> <span class="built_in">Map</span>()</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(fn, &#123;</span><br><span class="line">    <span class="function"><span class="title">apply</span>(<span class="params">target, context, args</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> argsString = args.join(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">      <span class="keyword">if</span> (cache.has(argsString)) &#123;</span><br><span class="line">        <span class="comment">// 如果有缓存，直接返回缓存数据        console.log(`输出$&#123;args&#125;的缓存结果: $&#123;cache.get(argsString)&#125;`);</span></span><br><span class="line">        <span class="keyword">return</span> cache.get(argsString);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> result = fn(...args);</span><br><span class="line">      cache.set(argsString, result);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《javascript设计模式与开发实践》<br><a href="https://segmentfault.com/a/1190000019574843">https://segmentfault.com/a/1190000019574843</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;headerlink&quot; title=&quot;代理模式&quot;&gt;&lt;/a&gt;代理模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;为其他对象提供一种代理以控制对这个对象的访问&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;stro
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://liang5757.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="js" scheme="https://liang5757.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>策略模式</title>
    <link href="https://liang5757.github.io/2021/01/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://liang5757.github.io/2021/01/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-01-30T14:21:59.000Z</published>
    <updated>2021-02-14T07:22:37.154Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>定义一系列算法，把他们一个个封装起来，并且使它们互相可替换</p></blockquote><h2 id="1-创建"><a href="#1-创建" class="headerlink" title="1. 创建"></a>1. 创建</h2><h3 id="1-1-利用对象封装实现"><a href="#1-1-利用对象封装实现" class="headerlink" title="1.1 利用对象封装实现"></a>1.1 利用对象封装实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将算法的实现与算法的使用分离，strategies是一个策略类</span></span><br><span class="line"><span class="keyword">let</span> strategies = &#123;</span><br><span class="line">  <span class="string">&quot;boss&quot;</span>: <span class="function"><span class="keyword">function</span> (<span class="params">salary</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">4</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;rookie&quot;</span>: <span class="function"><span class="keyword">function</span> (<span class="params">salary</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">3</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;liang&quot;</span>: <span class="function"><span class="keyword">function</span> (<span class="params">salary</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要调用计算类，只需要提供名字，解决了if else的问题</span></span><br><span class="line"><span class="keyword">let</span> calculateBonus = <span class="function"><span class="keyword">function</span> (<span class="params">level, salary</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> strategies[level](salary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-利用传递函数实现"><a href="#1-2-利用传递函数实现" class="headerlink" title="1.2 利用传递函数实现"></a>1.2 利用传递函数实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">boss</span>(<span class="params">salary</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> salary * <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rookie</span>(<span class="params">salary</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> salary * <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">liang</span> (<span class="params">salary</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> salary * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> calculateBonus2 = <span class="function"><span class="keyword">function</span> (<span class="params">func, salary</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> func(salary);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(calculateBonus2(rookie, <span class="number">10000</span>)); <span class="comment">// 30000</span></span><br></pre></td></tr></table></figure><h2 id="2-优点"><a href="#2-优点" class="headerlink" title="2. 优点"></a>2. 优点</h2><ul><li>有效避免多重条件选择语句</li><li>契合了开放封闭原则，易于扩展</li><li>策略类封装的算法可复用</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《javascript设计模式与开发实践》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;定义一系列算法，把他们一个个封装起来，并且使它们互相可替换&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-创建&quot;&gt;&lt;a href=&quot;#1-创建&quot; class=&quot;headerlink&quot; title=&quot;1. 创建&quot;&gt;&lt;/a&gt;1. 创建&lt;/h2
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://liang5757.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="js" scheme="https://liang5757.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="https://liang5757.github.io/2021/01/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://liang5757.github.io/2021/01/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-01-28T12:29:28.000Z</published>
    <updated>2021-02-14T07:22:31.467Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点<br>比如vuex、window对象、线程池</p></blockquote><h2 id="1-实现单例模式"><a href="#1-实现单例模式" class="headerlink" title="1. 实现单例模式"></a>1. 实现单例模式</h2><h3 id="1-1-基于闭包实现"><a href="#1-1-基于闭包实现" class="headerlink" title="1.1 基于闭包实现"></a>1.1 基于闭包实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Singleton</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton.getInstance = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> Singleton(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = Singleton.getInstance(<span class="string">&#x27;liang1&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> b = Singleton.getInstance(<span class="string">&#x27;liang2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a === b); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="1-2-利用代理模式"><a href="#1-2-利用代理模式" class="headerlink" title="1.2 利用代理模式"></a>1.2 利用代理模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ProxySingleton = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> Singleton(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> ProxySingleton(<span class="string">&#x27;liang1&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> ProxySingleton(<span class="string">&#x27;liang2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(c === d); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>利用代理模式来解耦管理单例的逻辑</p><h3 id="1-3-通用的惰性单例"><a href="#1-3-通用的惰性单例" class="headerlink" title="1.3 通用的惰性单例"></a>1.3 通用的惰性单例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSingle</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result || (result = fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要给<code>getSingle</code>传递一个创建实例的<code>fn</code>就能创建单例模式</p><h2 id="2-弹窗实例"><a href="#2-弹窗实例" class="headerlink" title="2. 弹窗实例"></a>2. 弹窗实例</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>打开弹窗<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 通用的创建惰性单例模式</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">getSingle</span>(<span class="params">fn</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> result;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> result || (result = fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>));</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 创建弹窗并添加到body下，并用getSingle创建单例模式</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> createDialog = getSingle(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    div.className = <span class="string">&quot;message-box&quot;</span>;</span></span><br><span class="line">    div.innerHTML = `</span><br><span class="line"><span class="javascript">      &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;mask&quot;</span>&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="javascript">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;dialog&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;dialog-bd&quot;</span>&gt;这是一个弹窗哦&lt;/div&gt;</span></span><br><span class="line"><span class="javascript">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;dialog-ft&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">          &lt;a href=<span class="string">&quot;javascript:&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;dialog-btn&quot;</span>&gt;确定&lt;/a&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">    `.trim();</span><br><span class="line"><span class="javascript">    div.style.display = <span class="string">&quot;none&quot;</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.appendChild(div);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> div;</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn&quot;</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> dialog = createDialog();</span></span><br><span class="line"><span class="javascript">    dialog.style.display = <span class="string">&quot;block&quot;</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 为弹窗按钮绑定关闭事件</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (event.target.className === <span class="string">&quot;dialog-btn&quot;</span>) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> dialog = createDialog();</span></span><br><span class="line"><span class="javascript">      dialog.style.display = <span class="string">&quot;none&quot;</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>getSingle函数通过变量<code>result</code>保存弹窗实例，如果已经存在则直接返回该实例，否则创建弹窗实例，保证了弹窗的唯一性</p><p><img src= "/img/loading.gif" data-lazy-src="/2021/01/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/4du1f-5c1xe-1607154327111.gif" alt="4du1f-5c1xe"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《JavaScript设计模式与开发实战》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;保证一个类仅有一个实例，并提供一个访问它的全局访问点&lt;br&gt;比如vuex、window对象、线程池&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-实现单例模式&quot;&gt;&lt;a href=&quot;#1-实现单例模式&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://liang5757.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="js" scheme="https://liang5757.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>惰性加载函数</title>
    <link href="https://liang5757.github.io/2021/01/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%83%B0%E6%80%A7%E5%8A%A0%E8%BD%BD%E5%87%BD%E6%95%B0/"/>
    <id>https://liang5757.github.io/2021/01/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%83%B0%E6%80%A7%E5%8A%A0%E8%BD%BD%E5%87%BD%E6%95%B0/</id>
    <published>2021-01-27T06:33:02.000Z</published>
    <updated>2021-02-14T07:22:28.657Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>写一个各浏览器兼容事件绑定函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> addEvent = <span class="function"><span class="keyword">function</span> (<span class="params">elem, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">        <span class="keyword">return</span> elem.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.attachEvent) &#123;</span><br><span class="line">        <span class="keyword">return</span> elem.attachEvent(<span class="string">&#x27;on&#x27;</span> + type, handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：每一次调用都必须执行一次if判断</p><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>在该代码被加载时，利用立即执行函数做一次判断，然后返回给<code>addEvent</code>正确的事件绑定函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> addEvent = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">elem, type, handler</span>) </span>&#123;</span><br><span class="line">            elem.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.attachEvent) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">elem, type, handler</span>) </span>&#123;</span><br><span class="line">            elem.attachEvent(<span class="string">&#x27;on&#x27;</span> + type, handler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>缺点：如果<code>addEvent</code>绑定事件函数一直都没有被调用，那么就白白做了一次浏览器嗅探</p><h2 id="方案二：惰性载入函数"><a href="#方案二：惰性载入函数" class="headerlink" title="方案二：惰性载入函数"></a>方案二：惰性载入函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> addEvent = <span class="function"><span class="keyword">function</span>(<span class="params">elem, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">        addEvent = <span class="function"><span class="keyword">function</span> (<span class="params">elem, type, handler</span>) </span>&#123;</span><br><span class="line">            elem.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.attachEvent) &#123;</span><br><span class="line">        addEvent = <span class="function"><span class="keyword">function</span> (<span class="params">elem, type, handler</span>) </span>&#123;</span><br><span class="line">            elem.attachEvent(<span class="string">&#x27;on&#x27;</span> + type, handler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    addEvent(elem, type, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：首次调用较慢</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Javascript设计模式与开发实践》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h2&gt;&lt;p&gt;写一个各浏览器兼容事件绑定函数&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://liang5757.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="js" scheme="https://liang5757.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode459. 重复的子字符串</title>
    <link href="https://liang5757.github.io/2021/01/23/Leetcode/Leetcode459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://liang5757.github.io/2021/01/23/Leetcode/Leetcode459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2021-01-23T14:35:12.000Z</published>
    <updated>2021-01-23T14:39:10.280Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接: <a href="https://leetcode-cn.com/problems/repeated-substring-pattern/">https://leetcode-cn.com/problems/repeated-substring-pattern/</a></p></blockquote><p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p><h2 id="俺愚蠢的暴力解法"><a href="#俺愚蠢的暴力解法" class="headerlink" title="俺愚蠢的暴力解法"></a>俺愚蠢的暴力解法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> repeatedSubstringPattern = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= s.length / <span class="number">2</span> &amp;&amp; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> str = s.slice(<span class="number">0</span>, i);</span><br><span class="line">        <span class="keyword">let</span> repeatNum = s.length / str.length;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Number</span>.isInteger(repeatNum) &amp;&amp; str.repeat(repeatNum) === s) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2021/01/23/Leetcode/Leetcode459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20210123215828920.png" alt="image-20210123215828920"></p><h2 id="方法二：字符串匹配"><a href="#方法二：字符串匹配" class="headerlink" title="方法二：字符串匹配"></a>方法二：字符串匹配</h2><blockquote><p>牛啊，官方题解的证明方式没看懂，之后有时间回来看看</p></blockquote><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ol><li>用两个<code>s</code>首尾相连得到一个新的字符串<code>ss</code>;</li><li>去掉<code>ss</code>的首尾两个字符；</li><li>如果在剩下来的字符串中能找到<code>s</code>那么返回True，否则False</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> repeatedSubstringPattern = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (s+s).slice(<span class="number">1</span>, -<span class="number">1</span>).indexOf(s) !== -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2021/01/23/Leetcode/Leetcode459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20210123223744746.png" alt="image-20210123223744746"></p><h3 id="证明方式"><a href="#证明方式" class="headerlink" title="证明方式"></a>证明方式</h3><p><a href="https://blog.csdn.net/qq_23997101/article/details/78804826">https://blog.csdn.net/qq_23997101/article/details/78804826</a></p><h2 id="方法三：正则表达式"><a href="#方法三：正则表达式" class="headerlink" title="方法三：正则表达式"></a>方法三：正则表达式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> repeatedSubstringPattern = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^([a-z]+)\1+$/</span>.test(s)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2021/01/23/Leetcode/Leetcode459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20210123222502223.png" alt="image-20210123222502223"></p><p>不解释，草。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;题目链接: &lt;a href=&quot;https://leetcode-cn.com/problems/repeated-substring-pattern/&quot;&gt;https://leetcode-cn.com/problems/repeated-subst
      
    
    </summary>
    
    
      <category term="算法" scheme="https://liang5757.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="https://liang5757.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>减少使用setInterval</title>
    <link href="https://liang5757.github.io/2021/01/22/Js/%E5%87%8F%E5%B0%91%E4%BD%BF%E7%94%A8setInterval/"/>
    <id>https://liang5757.github.io/2021/01/22/Js/%E5%87%8F%E5%B0%91%E4%BD%BF%E7%94%A8setInterval/</id>
    <published>2021-01-22T14:25:34.000Z</published>
    <updated>2021-01-22T14:26:18.969Z</updated>
    
    <content type="html"><![CDATA[<p><code>setInterval</code>很少使用在生成环境下，因为有如下几个缺点</p><h2 id="缺点一：setInterval无视代码错误"><a href="#缺点一：setInterval无视代码错误" class="headerlink" title="缺点一：setInterval无视代码错误"></a>缺点一：setInterval无视代码错误</h2><p><code>setInterval</code>执行的代码即使代码报错，它还会持续不断（不管不顾）地调用该代码</p><h2 id="缺点二：setInterval无视网络延迟"><a href="#缺点二：setInterval无视网络延迟" class="headerlink" title="缺点二：setInterval无视网络延迟"></a>缺点二：setInterval无视网络延迟</h2><p>假设你每隔一段时间就通过Ajax轮询一次服务器，看看有没有新数据（注意：如果你真的这么做了，那恐怕你做错了；建议使用<a href="https://link.juejin.im/?target=http%3A%2F%2Fgithub.com%2Fblog%2F467-smart-js-polling">“补偿性轮询”（backoff polling）</a>）。而由于某些原因（服务器过载、临时断网、流量剧增、用户带宽受限，等等），你的请求要花的时间远比你想象的要长。但<code>setInterval</code>不在乎。它仍然会按定时持续不断地触发请求，最终你的客户端网络队列会塞满Ajax调用。</p><h2 id="缺点三：setInterval不保证按时执行"><a href="#缺点三：setInterval不保证按时执行" class="headerlink" title="缺点三：setInterval不保证按时执行"></a>缺点三：setInterval不保证按时执行</h2><h3 id="原因一：执行时间被前面任务阻塞"><a href="#原因一：执行时间被前面任务阻塞" class="headerlink" title="原因一：执行时间被前面任务阻塞"></a>原因一：执行时间被前面任务阻塞</h3><p><code>setInterval</code>只是按时把时间推送到任务队列，因为js是单线程，所以如果前面的任务耗时较久，那么定时器的执行时间和我们预定的时间不一致</p><h3 id="原因二：推送被忽略"><a href="#原因二：推送被忽略" class="headerlink" title="原因二：推送被忽略"></a>原因二：推送被忽略</h3><p><code>setInterval</code>在推送到任务队列前，<strong>会检查上一次的任务是否仍在队列中</strong>，如果<strong>有则不填加</strong>，<code>setTimeout</code>则会直接添加</p><h2 id="用setTimeout模拟setInterval"><a href="#用setTimeout模拟setInterval" class="headerlink" title="用setTimeout模拟setInterval"></a>用setTimeout模拟setInterval</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">interval</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">interfunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    func.call(<span class="literal">null</span>);</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(interfunc, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">  timer = <span class="built_in">setTimeout</span>(interfunc, wait);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> timer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;setInterval&lt;/code&gt;很少使用在生成环境下，因为有如下几个缺点&lt;/p&gt;
&lt;h2 id=&quot;缺点一：setInterval无视代码错误&quot;&gt;&lt;a href=&quot;#缺点一：setInterval无视代码错误&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
      <category term="前端" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://liang5757.github.io/tags/js/"/>
    
  </entry>
  
</feed>
