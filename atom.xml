<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Liang的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liang5757.github.io/"/>
  <updated>2021-07-18T15:28:43.434Z</updated>
  <id>https://liang5757.github.io/</id>
  
  <author>
    <name>Liang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>egg入门</title>
    <link href="https://liang5757.github.io/2021/07/18/node.js/egg%E5%85%A5%E9%97%A8/"/>
    <id>https://liang5757.github.io/2021/07/18/node.js/egg%E5%85%A5%E9%97%A8/</id>
    <published>2021-07-18T15:28:05.000Z</published>
    <updated>2021-07-18T15:28:43.434Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快速初始化"><a href="#快速初始化" class="headerlink" title="快速初始化"></a>快速初始化</h2><p>用npm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init egg --<span class="built_in">type</span>=simple</span><br></pre></td></tr></table></figure><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">egg-project</span><br><span class="line">├── package.json</span><br><span class="line">├── app.js (可选) # 用于自定义启动时的初始化工作</span><br><span class="line">├── agent.js (可选) # 用于自定义启动时的初始化工作</span><br><span class="line">├── app</span><br><span class="line">|   ├── router.js  # 用于配置 URL 路由规则</span><br><span class="line">│   ├── controller  # 用于解析用户的输入，处理后返回相应的结果</span><br><span class="line">│   |   └── home.js</span><br><span class="line">│   ├── service (可选) # 用于编写业务逻辑层</span><br><span class="line">│   |   └── user.js</span><br><span class="line">│   ├── middleware (可选) # 用于编写中间件</span><br><span class="line">│   |   └── response_time.js</span><br><span class="line">│   ├── schedule (可选)# 用于定时任务</span><br><span class="line">│   |   └── my_task.js</span><br><span class="line">│   ├── public (可选) # 用于放置静态资源</span><br><span class="line">│   |   └── reset.css</span><br><span class="line">│   ├── view (可选)# 用于放置模板文件</span><br><span class="line">│   |   └── home.tpl</span><br><span class="line">│   └── extend (可选) # 用于框架的扩展</span><br><span class="line">│       ├── helper.js (可选)</span><br><span class="line">│       ├── request.js (可选)</span><br><span class="line">│       ├── response.js (可选)</span><br><span class="line">│       ├── context.js (可选)</span><br><span class="line">│       ├── application.js (可选)</span><br><span class="line">│       └── agent.js (可选)</span><br><span class="line">├── config # 用于编写配置文件</span><br><span class="line">|   ├── plugin.js  # 用于配置需要加载的插件</span><br><span class="line">|   ├── config.default.js</span><br><span class="line">│   ├── config.prod.js</span><br><span class="line">|   ├── config.test.js (可选)</span><br><span class="line">|   ├── config.local.js (可选)</span><br><span class="line">|   └── config.unittest.js (可选)</span><br><span class="line">└── test # 用于单元测试</span><br><span class="line">    ├── middleware</span><br><span class="line">    |   └── response_time.test.js</span><br><span class="line">    └── controller</span><br><span class="line">        └── home.test.js</span><br></pre></td></tr></table></figure><h2 id="路由（Router）"><a href="#路由（Router）" class="headerlink" title="路由（Router）"></a>路由（Router）</h2><blockquote><p>将用户的请求基于 method 和 URL 分发到了对应的 Controller 上，感觉api和Koa差不多。</p></blockquote><h3 id="参数获取"><a href="#参数获取" class="headerlink" title="参数获取"></a>参数获取</h3><h4 id="query"><a href="#query" class="headerlink" title="query"></a>query</h4><p>就列一个query参数的获取，需要注意的是，app.controller.search与文件相对应（也就是app/controller/search.js）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// curl http://127.0.0.1:7001/search?name=egg</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// app/router.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">  app.router.get(<span class="string">&#x27;/search&#x27;</span>, app.controller.search.index);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app/controller/search.js</span></span><br><span class="line"><span class="built_in">exports</span>.index = <span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">`search: <span class="subst">$&#123;ctx.query.name&#125;</span>`</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>为了避免用户恶意传递重复key的query参数导致系统报错，ctx.query只取第一次出现的值，并且保证一定是字符串类型</strong></p><p>如果必须要重复的key，比如需要传递数组：id=1&amp;id=2&amp;id=3，可以用<code>ctx.queries</code>，其也保证了一定是数组类型</p><h4 id="body"><a href="#body" class="headerlink" title="body"></a>body</h4><p>框架内置了 <a href="https://github.com/koajs/bodyparser">bodyParser</a> 中间件来对JSON和Form-Data的请求 body 解析成 object 挂载到 <code>ctx.request.body</code> 上。</p><p>body 最大长度为 <code>100kb</code>，超出长度413状态码，可以在 <code>config/config.default.js</code> 中覆盖框架的默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  bodyParser: &#123;</span><br><span class="line">    jsonLimit: <span class="string">&#x27;1mb&#x27;</span>,</span><br><span class="line">    formLimit: <span class="string">&#x27;1mb&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ctx.body是ctx.response.body的简写</p><h4 id="header"><a href="#header" class="headerlink" title="header"></a>header</h4><p>可以通过<code>ctx.get(name)</code>获取，其会自动处理大小写</p><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>获取、设置方式和Koa一样，配置方式如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  cookies: &#123;</span><br><span class="line">    <span class="comment">// httpOnly: true | false,</span></span><br><span class="line">    <span class="comment">// sameSite: &#x27;none|lax|strict&#x27;,</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>框架内置 <a href="https://github.com/eggjs/egg-session">Session</a> 插件，可以通过<code>ctx.session</code>，具体配置可以看 <a href="https://eggjs.org/zh-cn/core/cookie-and-session.html#session">Cookie 与 Session</a></p><h3 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h3><p>借助 <a href="https://github.com/eggjs/egg-validate">Validate</a> 插件提供便捷的参数校验机制，配置方式如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config/plugin.js</span></span><br><span class="line"><span class="built_in">exports</span>.validate = &#123;</span><br><span class="line">  enable: <span class="literal">true</span>,</span><br><span class="line">  package: <span class="string">&#x27;egg-validate&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ctx上有一个validate方法，可以传入校验配置来对参数进行校验</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// curl -X POST http://127.0.0.1:7001/user --data &#x27;username=abc@abc.com&amp;password=111111&amp;re-password=111111&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// app/router.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">  app.router.post(<span class="string">&#x27;/user&#x27;</span>, app.controller.user);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app/controller/user.js</span></span><br><span class="line"><span class="keyword">const</span> createRule = &#123;</span><br><span class="line">  username: &#123;</span><br><span class="line">    type: <span class="string">&#x27;email&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  password: &#123;</span><br><span class="line">    type: <span class="string">&#x27;password&#x27;</span>,</span><br><span class="line">    compare: <span class="string">&#x27;re-password&#x27;</span>, <span class="comment">// 与re-password比较，是否一致</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.create = <span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  <span class="comment">// 如果校验报错，会抛出异常</span></span><br><span class="line">  ctx.validate(createRule);</span><br><span class="line">  ctx.body = ctx.request.body;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><h4 id="内部重定向"><a href="#内部重定向" class="headerlink" title="内部重定向"></a>内部重定向</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.router.redirect(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;/home/index&#x27;</span>, <span class="number">302</span>);</span><br></pre></td></tr></table></figure><h4 id="外部重定向"><a href="#外部重定向" class="headerlink" title="外部重定向"></a>外部重定向</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.redirect(<span class="string">`http://cn.bing.com`</span>);</span><br></pre></td></tr></table></figure><h3 id="resources生成CRUD路由结构"><a href="#resources生成CRUD路由结构" class="headerlink" title="resources生成CRUD路由结构"></a>resources生成CRUD路由结构</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app/router.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; router, controller &#125; = app;</span><br><span class="line">    router.resources(<span class="string">&#x27;posts&#x27;</span>, <span class="string">&#x27;/api/posts&#x27;</span>, controller.posts);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来在对应文件下实现对应函数就可以了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app/controller/posts.js</span></span><br><span class="line"><span class="built_in">exports</span>.index = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.new = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.create = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.show = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.edit = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.update = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.destroy = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><table><thead><tr><th>Method</th><th>Path</th><th>Route Name</th><th>Controller.Action</th></tr></thead><tbody><tr><td>GET</td><td>/posts</td><td>posts</td><td>app.controllers.posts.index</td></tr><tr><td>GET</td><td>/posts/new</td><td>new_post</td><td>app.controllers.posts.new</td></tr><tr><td>GET</td><td>/posts/:id</td><td>post</td><td>app.controllers.posts.show</td></tr><tr><td>GET</td><td>/posts/:id/edit</td><td>edit_post</td><td>app.controllers.posts.edit</td></tr><tr><td>POST</td><td>/posts</td><td>posts</td><td>app.controllers.posts.create</td></tr><tr><td>PUT</td><td>/posts/:id</td><td>post</td><td>app.controllers.posts.update</td></tr><tr><td>DELETE</td><td>/posts/:id</td><td>post</td><td>app.controllers.posts.destroy</td></tr></tbody></table><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app/router.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">&#x27;./router/news&#x27;</span>)(app);</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">&#x27;./router/admin&#x27;</span>)(app);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app/router/news.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">  app.router.get(<span class="string">&#x27;/news/list&#x27;</span>, app.controller.news.list);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app/router/admin.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">  app.router.get(<span class="string">&#x27;/admin/user&#x27;</span>, app.controller.admin.user);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="控制器（Controller）"><a href="#控制器（Controller）" class="headerlink" title="控制器（Controller）"></a>控制器（Controller）</h2><blockquote><p>解析用户的输入，处理后返回相应的结果，框架建议在 controller 对请求参数进行处理（校验、转换），然后调用对应的 service 方法处理业务</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app/controller/post.js</span></span><br><span class="line"><span class="keyword">const</span> Controller = <span class="built_in">require</span>(<span class="string">&#x27;egg&#x27;</span>).Controller;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostController</span> <span class="keyword">extends</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">create</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; ctx, service &#125; = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">const</span> createRule = &#123;</span><br><span class="line">      title: &#123; <span class="attr">type</span>: <span class="string">&#x27;string&#x27;</span> &#125;,</span><br><span class="line">      content: &#123; <span class="attr">type</span>: <span class="string">&#x27;string&#x27;</span> &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 校验参数</span></span><br><span class="line">    ctx.validate(createRule);</span><br><span class="line">    <span class="comment">// 组装参数</span></span><br><span class="line">    <span class="keyword">const</span> author = ctx.session.userId;</span><br><span class="line">    <span class="keyword">const</span> req = <span class="built_in">Object</span>.assign(ctx.request.body, &#123; author &#125;);</span><br><span class="line">    <span class="comment">// 调用 Service 进行业务处理</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> service.post.create(req);</span><br><span class="line">    <span class="comment">// 设置响应内容和响应状态码</span></span><br><span class="line">    ctx.body = &#123; <span class="attr">id</span>: res.id &#125;;</span><br><span class="line">    ctx.status = <span class="number">201</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = PostController;</span><br></pre></td></tr></table></figure><h3 id="获取上传的文件"><a href="#获取上传的文件" class="headerlink" title="获取上传的文件"></a>获取上传的文件</h3><h4 id="file模式"><a href="#file模式" class="headerlink" title="file模式"></a>file模式</h4><p>在config中配置file模式</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config/config.default.js</span></span><br><span class="line">exports.multipart = &#123;</span><br><span class="line">  mode: &#x27;file&#x27;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>controller层代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app/controller/upload.js</span></span><br><span class="line"><span class="keyword">const</span> Controller = <span class="built_in">require</span>(<span class="string">&#x27;egg&#x27;</span>).Controller;</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;mz/fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">upload</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; ctx &#125; = <span class="built_in">this</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(ctx.request.body);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;got %d files&#x27;</span>, ctx.request.files.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> file <span class="keyword">of</span> ctx.request.files) &#123; <span class="comment">// files获取上传的多文件</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;field: &#x27;</span> + file.fieldname);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;filename: &#x27;</span> + file.filename);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;encoding: &#x27;</span> + file.encoding);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;mime: &#x27;</span> + file.mime);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;tmp filepath: &#x27;</span> + file.filepath);</span><br><span class="line">      <span class="keyword">let</span> result;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 处理文件，比如上传到云端</span></span><br><span class="line">        result = <span class="keyword">await</span> ctx.oss.put(<span class="string">&#x27;egg-multipart-test/&#x27;</span> + file.filename, file.filepath);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 需要删除临时文件</span></span><br><span class="line">        <span class="keyword">await</span> fs.unlink(file.filepath);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="stream模式"><a href="#stream模式" class="headerlink" title="stream模式"></a>stream模式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> sendToWormhole = <span class="built_in">require</span>(<span class="string">&#x27;stream-wormhole&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> Controller = <span class="built_in">require</span>(<span class="string">&#x27;egg&#x27;</span>).Controller;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UploaderController</span> <span class="keyword">extends</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">upload</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> ctx = <span class="built_in">this</span>.ctx;</span><br><span class="line">    <span class="keyword">const</span> stream = <span class="keyword">await</span> ctx.getFileStream();</span><br><span class="line">    <span class="keyword">const</span> name = <span class="string">&#x27;egg-multipart-test/&#x27;</span> + path.basename(stream.filename);</span><br><span class="line">    <span class="comment">// 文件处理，上传到云存储等等</span></span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      result = <span class="keyword">await</span> ctx.oss.put(name, stream);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="comment">// 必须将上传的文件流消费掉，要不然浏览器响应会卡死</span></span><br><span class="line">      <span class="keyword">await</span> sendToWormhole(stream);</span><br><span class="line">      <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">      url: result.url,</span><br><span class="line">      <span class="comment">// 所有表单字段都能通过 `stream.fields` 获取到</span></span><br><span class="line">      fields: stream.fields,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = UploaderController;</span><br></pre></td></tr></table></figure><h2 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h2><p>其不是单例，在每次请求时访问<code>ctx.service.xx</code> 时延迟实例化，所以可以用<code>this.ctx</code>获取每一次请求的上下文</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app/service/user.js</span></span><br><span class="line"><span class="keyword">const</span> Service = <span class="built_in">require</span>(<span class="string">&#x27;egg&#x27;</span>).Service;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">find</span>(<span class="params">uid</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="built_in">this</span>.ctx.db.query(<span class="string">&#x27;select * from user where uid = ?&#x27;</span>, uid);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = UserService;</span><br></pre></td></tr></table></figure><p>函数return的值会返回给前端</p><h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p>所有的定时任务都统一存放在 <code>app/schedule</code> 目录下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Subscription = <span class="built_in">require</span>(<span class="string">&#x27;egg&#x27;</span>).Subscription;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpdateCache</span> <span class="keyword">extends</span> <span class="title">Subscription</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 通过 schedule 属性来设置定时任务的执行间隔等配置</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> <span class="title">schedule</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      interval: <span class="string">&#x27;1m&#x27;</span>, <span class="comment">// 1 分钟间隔</span></span><br><span class="line">      type: <span class="string">&#x27;all&#x27;</span>, <span class="comment">// 指定所有的 worker 都需要执行</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// subscribe 是真正定时任务执行时被运行的函数</span></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">subscribe</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="built_in">this</span>.ctx.curl(<span class="string">&#x27;http://www.api.com/cache&#x27;</span>, &#123;</span><br><span class="line">      dataType: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">this</span>.ctx.app.cache = res.data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = UpdateCache;</span><br></pre></td></tr></table></figure><p>还可以简写为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  schedule: &#123;</span><br><span class="line">    interval: <span class="string">&#x27;1m&#x27;</span>, <span class="comment">// 1 分钟间隔</span></span><br><span class="line">    type: <span class="string">&#x27;all&#x27;</span>, <span class="comment">// 指定所有的 worker 都需要执行</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">task</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> ctx.curl(<span class="string">&#x27;http://www.api.com/cache&#x27;</span>, &#123;</span><br><span class="line">      dataType: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    ctx.app.cache = res.data;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>没有用过，具体配置看官方文档 <a href="https://eggjs.org/zh-cn/basics/schedule.html">定时任务</a></p><h2 id="egg-mysql"><a href="#egg-mysql" class="headerlink" title="egg-mysql"></a>egg-mysql</h2><h3 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save egg-mysql</span><br></pre></td></tr></table></figure><p>开启插件</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config/plugin.js</span></span><br><span class="line">exports.mysql = &#123;</span><br><span class="line">  enable: true,</span><br><span class="line">  package: &#x27;egg-mysql&#x27;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>数据库配置</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config/config.$&#123;env&#125;.js</span></span><br><span class="line">exports.mysql = &#123;</span><br><span class="line">  <span class="comment">// 单数据库信息配置</span></span><br><span class="line">  clients: &#123;</span><br><span class="line">    <span class="comment">// clientId, 获取client实例，需要通过 app.mysql.get(&#x27;clientId&#x27;) 获取</span></span><br><span class="line">    db1: &#123;</span><br><span class="line">      host: &#x27;mysql.com&#x27;,</span><br><span class="line">      port: &#x27;3306&#x27;,</span><br><span class="line">      user: &#x27;test_user&#x27;,</span><br><span class="line">      password: &#x27;test_password&#x27;,</span><br><span class="line">      database: &#x27;test&#x27;,</span><br><span class="line">    &#125;,</span><br><span class="line">    db2: &#123;</span><br><span class="line">      host: &#x27;mysql2.com&#x27;,</span><br><span class="line">      port: &#x27;3307&#x27;,</span><br><span class="line">      user: &#x27;test_user&#x27;,</span><br><span class="line">      password: &#x27;test_password&#x27;,</span><br><span class="line">      database: &#x27;test&#x27;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 所有数据库配置的默认值</span></span><br><span class="line">  default: &#123;&#125;,</span><br><span class="line">  <span class="comment">// 是否加载到 app 上，默认开启</span></span><br><span class="line">  app: true,</span><br><span class="line">  <span class="comment">// 是否加载到 agent 上，默认关闭</span></span><br><span class="line">  agent: false,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> client1 = app.mysql.get(<span class="string">&#x27;db1&#x27;</span>);</span><br><span class="line"><span class="keyword">await</span> client1.query(sql, values);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> client2 = app.mysql.get(<span class="string">&#x27;db2&#x27;</span>);</span><br><span class="line"><span class="keyword">await</span> client2.query(sql, values);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;快速初始化&quot;&gt;&lt;a href=&quot;#快速初始化&quot; class=&quot;headerlink&quot; title=&quot;快速初始化&quot;&gt;&lt;/a&gt;快速初始化&lt;/h2&gt;&lt;p&gt;用npm&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
    
      <category term="后端" scheme="https://liang5757.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="egg.js" scheme="https://liang5757.github.io/tags/egg-js/"/>
    
  </entry>
  
  <entry>
    <title>redux入门</title>
    <link href="https://liang5757.github.io/2021/06/15/React/redux%E5%85%A5%E9%97%A8/"/>
    <id>https://liang5757.github.io/2021/06/15/React/redux%E5%85%A5%E9%97%A8/</id>
    <published>2021-06-15T13:02:58.000Z</published>
    <updated>2021-06-15T13:14:55.560Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Redux 官方文档对 Redux 的定义是：<strong>一个可预测的 JavaScript 应用状态管理容器</strong></p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save redux</span><br></pre></td></tr></table></figure><h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><blockquote><p>Redux应用只有单一的 store</p></blockquote><p>通过<code>createStore()</code>创建一个store</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> todoApp <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span> <span class="comment">// 这个在下面会讲</span></span><br><span class="line"><span class="keyword">let</span> store = createStore(todoApp)</span><br></pre></td></tr></table></figure><p><code>createStore()</code>的第二个参数是可选的, 用于设置 state 初始状态。这对开发同构应用时非常有用，服务器端 redux 应用的 state 结构可以与客户端保持一致, 那么客户端可以将从网络接收到的服务端 state 直接用于本地数据初始化。</p><p>提供四个函数</p><ul><li><code>getState()</code>方法获取 state</li><li><code>dispatch(action)</code>方法分发 action 更新 state</li><li><code>subscribe(listener)</code>注册监听器，返回的函数注销监听器</li><li><code>replaceReducer(nextReducer)</code> 一般在 Webpack Code-Splitting 按需加载的时候用</li></ul><p>redux规定禁止直接修改 state，也就是下面的写法</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> state = store.getState()</span><br><span class="line">state.counter = state.counter + <span class="number">1</span> <span class="comment">// 禁止在业务逻辑中直接修改 state</span></span><br></pre></td></tr></table></figure><p>只能通过 dispatch 一个 action 来修改</p><h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><p>是把数据从应用传到 store 的有效载荷。它是 store 数据的<strong>唯一</strong>来源。一般来说你会通过 <a href="https://cn.redux.js.org/docs/api/Store.html#dispatch"><code>store.dispatch()</code></a> 将 action 传到 store。</p><h3 id="1-Action格式"><a href="#1-Action格式" class="headerlink" title="1 Action格式"></a>1 Action格式</h3><p>除了<code>type</code>字段外，action的结构完全由你自己决定，一般参照 <a href="https://github.com/acdlite/flux-standard-action">Flux 标准 Action</a> 获取关于如何构造 action 的建议。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ADD_TODO = <span class="string">&#x27;ADD_TODO&#x27;</span></span><br><span class="line"><span class="comment">// 下面是常见的action格式</span></span><br><span class="line">&#123;</span><br><span class="line">  type: ADD_TODO,</span><br><span class="line">  text: <span class="string">&#x27;Build my first Redux app&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Action创建函数"><a href="#2-Action创建函数" class="headerlink" title="2 Action创建函数"></a>2 Action创建函数</h3><p>就是生成action的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        type: ADD_TODO,</span><br><span class="line">        text</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-dispatch"><a href="#3-dispatch" class="headerlink" title="3 dispatch"></a>3 dispatch</h3><p>只需把 action 创建函数的结果传给 <code>dispatch()</code> 方法即可发起一次 dispatch 过程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch(addTodo(text))</span><br></pre></td></tr></table></figure><h2 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h2><p>指定了应用状态的变化如何<strong>响应</strong> actions 并发送状态到 store 的，记住 actions 只是描述了<em>有事情发生了</em>这一事实，并没有描述应用如何更新 state。</p><p>reducer就是一个纯函数，<strong>接收旧的 state 和 action，返回新的 state</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;<span class="function">(<span class="params">previousState, action</span>) =&gt;</span> newState</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> initState = &#123;</span><br><span class="line">    counter: <span class="number">0</span>,</span><br><span class="line">    todos: []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 应用的初始状态是在第一次执行 reducer 时设置的 ※</span></span><br><span class="line">    <span class="keyword">if</span> (!state) state = initState</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;ADD_TODO&#x27;</span>:</span><br><span class="line">            <span class="keyword">var</span> nextState = _.cloneDeep(state) <span class="comment">// 用到了 lodash 的深克隆</span></span><br><span class="line">            nextState.todos.push(action.payload) </span><br><span class="line">            <span class="keyword">return</span> nextState</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;ADD_COUNT&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class="line">                visibilityFilter: action.filter</span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// 由于 nextState 会把原 state 整个替换掉</span></span><br><span class="line">            <span class="comment">// 若无修改，必须返回原 state（否则就是 undefined）</span></span><br><span class="line">            <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><strong>不要修改 <code>state</code>。</strong> 使用 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign"><code>Object.assign()</code></a> 新建了一个副本。不能这样使用 <code>Object.assign(state, &#123; visibilityFilter: action.filter &#125;)</code>，因为它会改变第一个参数的值</li><li><strong>在 <code>default</code> 情况下返回旧的 <code>state</code>。</strong>否则 state 会变成<code>undefined</code></li></ul><h2 id="拆分Reducer"><a href="#拆分Reducer" class="headerlink" title="拆分Reducer"></a>拆分Reducer</h2><p>当业务逻辑复杂时，所有状态聚合在一个reducer函数里处理，逻辑会变得相当复杂。</p><p>我们可以提出一个主reducer函数，它调用多个子 reducer 分别处理子 state 中的数据，然后再把这些数据合成一个大的单一对象。</p><p>主 reducer 并不需要设置初始化时完整的 state。初始时，如果传入 <code>undefined</code>, <strong>子 reducer 将负责返回它们的默认值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">todos</span>(<span class="params">state = [], action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> ADD_TODO:</span><br><span class="line">      <span class="keyword">return</span> [</span><br><span class="line">        ...state,</span><br><span class="line">        &#123;</span><br><span class="line">          text: action.text,</span><br><span class="line">          completed: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    <span class="keyword">case</span> TOGGLE_TODO:</span><br><span class="line">      <span class="keyword">return</span> state.map(<span class="function">(<span class="params">todo, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index === action.index) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, todo, &#123;</span><br><span class="line">            completed: !todo.completed</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> todo</span><br><span class="line">      &#125;)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">visibilityFilter</span>(<span class="params">state = SHOW_ALL, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> SET_VISIBILITY_FILTER:</span><br><span class="line">      <span class="keyword">return</span> action.filter</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主reducer</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">todoApp</span>(<span class="params">state = &#123;&#125;, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    visibilityFilter: visibilityFilter(state.visibilityFilter, action),</span><br><span class="line">    todos: todos(state.todos, action)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以利用<code>combineReducers()</code>来简化代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todoApp = combineReducers(&#123;</span><br><span class="line">  visibilityFilter,</span><br><span class="line">  a: todos</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> todoApp</span><br></pre></td></tr></table></figure><p>注意上面的写法和下面完全等价：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">todoApp</span>(<span class="params">state = &#123;&#125;, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    visibilityFilter: visibilityFilter(state.visibilityFilter, action),</span><br><span class="line">    todos: todos(state.todos, action)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步数据流"><a href="#异步数据流" class="headerlink" title="异步数据流"></a>异步数据流</h2><p>如果只是简单的redux store是不支持用dispatch异步更新store，可以使用<code>react-thunk</code>来增强</p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install redux-thunk</span><br></pre></td></tr></table></figure><h3 id="使用applyMiddleware引入中间件"><a href="#使用applyMiddleware引入中间件" class="headerlink" title="使用applyMiddleware引入中间件"></a>使用applyMiddleware引入中间件</h3><blockquote><p>与Koa和Express类似，redux也提供了注册中间件的方法：<code>applyMiddleware</code>，这个中间件执行时间是在<strong>dispatch一个action之后，到达reducer之前</strong>，执行顺序是从上到下，传递action</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">&#x27;redux-thunk&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  rootReducer,</span><br><span class="line">  applyMiddleware(</span><br><span class="line">    thunk, <span class="comment">// 允许我们 dispatch() 函数</span></span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>引入后<strong>允许我们<code>dispatch</code>一个函数</strong>，这个函数内部可以<code>dispatch</code>，这个函数接受两个参数，第一个是<code>dispatch</code>，第二个是<code>getState</code>，函数内部允许放一些异步操作，来解决redux只能同步<code>dispatch(action)</code>的问题</p><h3 id="react-thunk-源码"><a href="#react-thunk-源码" class="headerlink" title="react-thunk 源码"></a>react-thunk 源码</h3><p>出乎意料的简单</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createThunkMiddleware</span>(<span class="params">extraArgument</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">&#123; dispatch, getState &#125;</span>) =&gt;</span> <span class="function">(<span class="params">next</span>) =&gt;</span> <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">&#x27;function&#x27;</span>) &#123; <span class="comment">// 如果是函数，当作函数执行</span></span><br><span class="line">            <span class="keyword">return</span> action(dispatch, getState, extraArgument);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> next(action);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> thunk = createThunkMiddleware();</span><br><span class="line">thunk.withExtraArgument = createThunkMiddleware;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> thunk;</span><br></pre></td></tr></table></figure><p>当然我们也可以用<code>redux-promise</code>这个中间件来<code>dispatch</code>一个<code>promise</code></p><h3 id="redux-promise-源码"><a href="#redux-promise-源码" class="headerlink" title="redux-promise 源码"></a>redux-promise 源码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> isPromise <span class="keyword">from</span> <span class="string">&#x27;is-promise&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; isFSA &#125; <span class="keyword">from</span> <span class="string">&#x27;flux-standard-action&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">promiseMiddleware</span>(<span class="params">&#123; dispatch &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是不是 flux 标准的action</span></span><br><span class="line">        <span class="keyword">if</span> (!isFSA(action)) &#123;</span><br><span class="line">            <span class="keyword">return</span> isPromise(action) ? action.then(dispatch) : next(action);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isPromise(action.payload)</span><br><span class="line">            ? action.payload</span><br><span class="line">            .then(<span class="function"><span class="params">result</span> =&gt;</span> dispatch(&#123; ...action, <span class="attr">payload</span>: result &#125;))</span><br><span class="line">            .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">            dispatch(&#123; ...action, <span class="attr">payload</span>: error, <span class="attr">error</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">        &#125;)</span><br><span class="line">        : next(action);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="与react配合使用"><a href="#与react配合使用" class="headerlink" title="与react配合使用"></a>与react配合使用</h2><h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save react-redux</span><br></pre></td></tr></table></figure><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>利用 Provider 组件分发store状态</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./app/store&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;/Provider&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在组件中使用<code>useSelector</code>，<code>useDispatch</code>来获取 state 和分发 action</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">import</span> &#123; useSelector, useDispatch &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; decrement, increment &#125; <span class="keyword">from</span> <span class="string">&#x27;./counterSlice&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> count = useSelector(<span class="function">(<span class="params">state</span>) =&gt;</span> state.counter.value) <span class="comment">// 从state中获取count的值</span></span><br><span class="line">    <span class="keyword">const</span> dispatch = useDispatch() <span class="comment">// 获取dispatch方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="function">() =&gt;</span> dispatch(increment())&#125;&gt;</span><br><span class="line">                Increment</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">            &lt;span&gt;&#123;count&#125;&lt;/span&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="function">() =&gt;</span> dispatch(decrement())&#125;&gt;</span><br><span class="line">                Decrement</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者用<code>connect</code>函数包裹组件，将state和dispatch映射到props中</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect(mapStateToProps, mapDispatchToProps)(MyComponent)</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// prop : state.xxx  | 意思是将state中的某个数据映射到props中</span></span><br><span class="line">        foo: state.bar</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123; <span class="comment">// 默认传递参数就是dispatch</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        onClick: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            dispatch(&#123;</span><br><span class="line">                type: <span class="string">&#x27;increatment&#x27;</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line">    render () &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;&gt;</span><br><span class="line">                &lt;div&gt;<span class="built_in">this</span>.props.foo&lt;/div&gt;</span><br><span class="line">                &lt;button onClick = &#123;<span class="built_in">this</span>.props.onClick&#125;&gt;点击increase&lt;/button&gt;</span><br><span class="line">            &lt;/&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Foo = connect(mapStateToProps, mapDispatchToProps)(Foo);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Foo;</span><br></pre></td></tr></table></figure><h2 id="同步react-router"><a href="#同步react-router" class="headerlink" title="同步react-router"></a>同步react-router</h2><h3 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save connected-react-router</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>1.创建一个以history作为参数，返回根reducer的函数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reducers.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; connectRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;connected-react-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createRootReducer = <span class="function">(<span class="params">history</span>) =&gt;</span> combineReducers(&#123;</span><br><span class="line">  router: connectRouter(history),</span><br><span class="line">  ... <span class="comment">// rest of your reducers</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createRootReducer;</span><br></pre></td></tr></table></figure><p>2.创建一个history对象，将这个对象给上述的reducer和<code>createRootReducer</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// configureStore.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createBrowserHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;history&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; applyMiddleware, compose, createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; routerMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;connected-react-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> createRootReducer <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> history = createBrowserHistory()</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">configureStore</span>(<span class="params">preloadedState</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> store = createStore(</span><br><span class="line">        createRootReducer(history), <span class="comment">// root reducer with router state</span></span><br><span class="line">        preloadedState,</span><br><span class="line">        compose(</span><br><span class="line">            applyMiddleware(</span><br><span class="line">                routerMiddleware(history), <span class="comment">// for dispatching history actions</span></span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            ),</span><br><span class="line">        ),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> store</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.利用 ConnectedRouter组件，传递给他history对象作为prop，并将该组件作为 react-redux的Provider组件的子组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; Route, Switch &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router&#x27;</span> <span class="comment">// react-router v4/v5</span></span><br><span class="line"><span class="keyword">import</span> &#123; ConnectedRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;connected-react-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> configureStore, &#123; history &#125; <span class="keyword">from</span> <span class="string">&#x27;./configureStore&#x27;</span></span><br><span class="line"><span class="keyword">const</span> store = configureStore(<span class="comment">/* 提供初始state */</span>)</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">        &lt;ConnectedRouter history=&#123;history&#125;&gt; &#123; <span class="comment">/* place ConnectedRouter under Provider */</span> &#125;</span><br><span class="line">            &lt;&gt; </span><br><span class="line">            &lt;Switch&gt;</span><br><span class="line">                &lt;Route exact path=<span class="string">&quot;/&quot;</span> render=&#123;<span class="function">() =&gt;</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Match<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)&#125; /&gt;</span><br><span class="line">                &lt;Route render=&#123;<span class="function">() =&gt;</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Miss<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)&#125; /&gt;</span><br><span class="line">            &lt;/Switch&gt;</span><br><span class="line">            &lt;/&gt;</span><br><span class="line">        &lt;/ConnectedRouter&gt;</span><br><span class="line">    &lt;/Provider&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;react-root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><p>connect-react-router也提供了路由跳转的方法，比如 push 和 replace，但是这些方法只是创建了action，需要dispatch这些方法产生的action</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;push, replace&#125; <span class="keyword">from</span> <span class="string">&quot;connected-react-router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">XXX</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    dispatch(push(<span class="string">&quot;/page1&quot;</span>))</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.sakura-snow.com/post/react-node-6/">react学习笔记6-redux</a><br><a href="https://juejin.cn/post/6844903846666321934">一篇文章总结redux、react-redux、redux-saga</a><br><a href="https://cn.redux.js.org/">Redux中文文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Redux 官方文档对 Redux 的定义是：&lt;strong&gt;一个可预测的 JavaScript 应用状态管理容器&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="前端" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="React" scheme="https://liang5757.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React Hook</title>
    <link href="https://liang5757.github.io/2021/06/08/React/React%20Hook/"/>
    <id>https://liang5757.github.io/2021/06/08/React/React%20Hook/</id>
    <published>2021-06-08T14:45:46.000Z</published>
    <updated>2021-06-09T13:58:55.462Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>函数式组件只能使用props，Hook能够在函数式组件的情况下使用state、生命周期以及其他的React特性</p></blockquote><p>为什么需要引入React Hook，可以查看官方文档：<a href="https://zh-hans.reactjs.org/docs/hooks-intro.html#motivation">https://zh-hans.reactjs.org/docs/hooks-intro.html#motivation</a></p><h2 id="1-注意事项"><a href="#1-注意事项" class="headerlink" title="1. 注意事项"></a>1. 注意事项</h2><ul><li>只能在函数内部的最外层调用 Hook，不要在循环、条件判断或者子函数中调用</li><li>只能在 React 的函数组件或自定义Hook中调用 Hook，不要在其他 JavaScript 函数中调用</li><li>Hook 在 class 内部是<strong>不</strong>起作用的</li></ul><h2 id="2-useState"><a href="#2-useState" class="headerlink" title="2. useState"></a>2. useState</h2><p>useState在组件内创建的内部state，React 会在重复渲染时保留这个 state，该函数的<strong>第一个参数是初始值</strong>，可以传入一个函数，此函数只在初始渲染中被调用。调用该函数会返回一对值：[当前状态，更新当前状态的函数]。</p><p>这个更新状态的函数<strong>不会对state进行合并，而是直接替换</strong>，可以传递一个回调函数，携带参数是上一次的state</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>; <span class="number">2</span>:</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>); <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>)&#125;&gt;</span><br><span class="line">                Click me</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部使用<code>Object.js</code>（浅）来比较新/旧<code>state</code>是否相等，在修改状态时，<strong>传的状态值没有变化，则不重新渲染</strong></p><h3 id="惰性初始值"><a href="#惰性初始值" class="headerlink" title="惰性初始值"></a>惰性初始值</h3><p>下面的代码中，<code>initialState</code>是只在初始化时有其存在价值，但是如果真如下面一样写了，那么这个计算出<code>initialState</code>昂贵的操作在每次render都会执行。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = someExpensiveComputation(props); <span class="comment">// 这是一个耗时的操作</span></span><br><span class="line"><span class="keyword">const</span> [state, setState] = useState(initialState);</span><br></pre></td></tr></table></figure><p>我们可以让<code>someExpensiveComputation</code> 运行在一个<code>useState</code>匿名函数参数下，该函数当且仅当初始化时被调用，从而优化性能。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = useState(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> initialState = someExpensiveComputation(props);</span><br><span class="line">    <span class="keyword">return</span> initialState;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="2-useEffect"><a href="#2-useEffect" class="headerlink" title="2. useEffect"></a>2. useEffect</h2><p>用来在函数式组件内使用class组件的生命周期函数，可以传递两个参数，第一个是执行回调函数，第二个是监听的变量数组。</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><h4 id="1-只在第一次的componentDidMount执行"><a href="#1-只在第一次的componentDidMount执行" class="headerlink" title="1.只在第一次的componentDidMount执行"></a>1.只在第一次的componentDidMount执行</h4><p>第二个参数为 []</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure><h4 id="2-在第一次渲染和每次更新后执行"><a href="#2-在第一次渲染和每次更新后执行" class="headerlink" title="2. 在第一次渲染和每次更新后执行"></a>2. 在第一次渲染和每次更新后执行</h4><p>第二个参数为空</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="3-监听变量的变化执行"><a href="#3-监听变量的变化执行" class="headerlink" title="3. 监听变量的变化执行"></a>3. 监听变量的变化执行</h4><p>第二个参数是一个变量数组，只要有一个变量变化了就会执行</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// count改变才会执行</span></span><br><span class="line">&#125;, [count])</span><br></pre></td></tr></table></figure><h4 id="4-在componentWillUnmount中执行"><a href="#4-在componentWillUnmount中执行" class="headerlink" title="4. 在componentWillUnmount中执行"></a>4. 在componentWillUnmount中执行</h4><p>第一个回调函数可以return一个函数，这个return的函数会在<code>componentWillUnmount</code>这个生命周期执行。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;use effect...&#x27;</span>, count)</span><br><span class="line">    <span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> setCount(count +<span class="number">1</span>), <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(timer)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="3-useRef"><a href="#3-useRef" class="headerlink" title="3. useRef"></a>3. useRef</h2><p><code>useRef</code> 返回一个可变的 ref 对象，其 <code>.current</code> 属性被初始化为传入的参数（<code>initialValue</code>）。返回的 ref 对象在组件的整个生命周期内保持不变。</p><p>当 ref 对象内容发生变化时，<code>useRef</code> 并<em>不会</em>通知你。变更 <code>.current</code> 属性不会引发组件重新渲染。</p><p><strong>和createRef的区别</strong>：createRef 每次渲染都会返回一个新的引用，而 useRef 每次都会返回相同的引用（可以解决每次渲染引用不同的useState，导致状态异常的bug）</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [renderIndex, setRenderIndex] = useState(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> refFromUseRef = useRef();</span><br><span class="line">    <span class="keyword">const</span> refFromCreateRef = createRef();</span><br><span class="line">    <span class="keyword">if</span> (!refFromUseRef.current) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;useRef&quot;</span>)</span><br><span class="line">        refFromUseRef.current = renderIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!refFromCreateRef.current) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;createRef&quot;</span>)</span><br><span class="line">        refFromCreateRef.current = renderIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">            Current render index: &#123;renderIndex&#125;</span><br><span class="line">            &lt;p&gt;refFromUseRef value: &#123;refFromUseRef.current&#125;&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;refFromCreateRef value: &#123;refFromCreateRef.current&#125;&lt;/p&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="function">() =&gt;</span> setRenderIndex(<span class="function"><span class="params">prev</span> =&gt;</span> prev + <span class="number">1</span>)&#125;&gt;</span><br><span class="line">                Cause re-render</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>![image-20210606235123989](D:\OneDrive - mail2.gdut.edu.cn\typora_img\React Hook\image-20210606235123989.png)</p><h2 id="4-useImperativeHandle"><a href="#4-useImperativeHandle" class="headerlink" title="4. useImperativeHandle"></a>4. useImperativeHandle</h2><p><code>useImperativeHandle</code>可以让你在使用 ref 时，自定义暴露给父组件的实例值，不能让父组件想干嘛就干嘛</p><p><code>useImperativeHandle</code> 应当与 <a href="https://zh-hans.reactjs.org/docs/react-api.html#reactforwardref"><code>forwardRef</code></a> 一起使用：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">props, parentRef</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 子组件内部自己创建 ref</span></span><br><span class="line">    <span class="keyword">let</span> focusRef = useRef();</span><br><span class="line">    <span class="keyword">let</span> inputRef = useRef();</span><br><span class="line">    useImperativeHandle(parentRef, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 这个函数会返回一个对象</span></span><br><span class="line">        <span class="comment">// 该对象会作为父组件 current 属性的值</span></span><br><span class="line">        <span class="comment">// 通过这种方式，父组件可以使用操作子组件中的多个 ref</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            focusRef,</span><br><span class="line">            inputRef,</span><br><span class="line">            name: <span class="string">&#x27;计数器&#x27;</span>,</span><br><span class="line">            focus () &#123;</span><br><span class="line">                focusRef.current.focus();</span><br><span class="line">            &#125;,</span><br><span class="line">            changeText (text) &#123;</span><br><span class="line">                inputRef.current.value = text;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;React.Fragment&gt;</span><br><span class="line">            &lt;input ref=&#123;focusRef&#125;/&gt;</span><br><span class="line">            &lt;input ref=&#123;inputRef&#125;/&gt;</span><br><span class="line">        &lt;/React.Fragment&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child = forwardRef(Child);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> parentRef = useRef();<span class="comment">//&#123;current:&#x27;&#x27;&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getFocus</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        parentRef.current.focus();</span><br><span class="line">        <span class="comment">// 因为子组件中没有定义这个属性，实现了保护，所以这里的代码无效</span></span><br><span class="line">        <span class="comment">// parentRef.current.addNumber(666);</span></span><br><span class="line">        parentRef.current.changeText(<span class="string">&#x27;777&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(parentRef.current.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;React.Fragment&gt;</span><br><span class="line">            &lt;Child ref=&#123;parentRef&#125;/&gt;</span><br><span class="line">            &lt;button onClick=&#123;getFocus&#125;&gt;获得焦点&lt;/button&gt;</span><br><span class="line">        &lt;/React.Fragment&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-useMemo"><a href="#5-useMemo" class="headerlink" title="5.useMemo"></a>5.useMemo</h2><blockquote><p>父组件的state改变，子组件也会随之重新render，即使子组件内部state没有改变，我们可以用useMemo来进行性能优化</p></blockquote><p>参数列表</p><ul><li>回调函数，return出来的值作为useMemo的返回值</li><li>依赖项数组，只要有一个变量改变，就会重新执行回调，但不会触发渲染，如果<strong>没有提供依赖数组，则<code>useMemo</code> 在每次渲染时都会计算新的值</strong></li></ul><p><code>useMemo</code>返回一个 <a href="https://en.wikipedia.org/wiki/Memoization">memoized</a> 值，它仅会在会在某个依赖项改变时才重新计算 memoized 值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Child = memo(<span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;child render...&#x27;</span>, data.name)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;div&gt;child&lt;/div&gt;</span><br><span class="line">            &lt;div&gt;&#123;data.name&#125;&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Hook = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hook render...&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> [name, setName] = useState(<span class="string">&#x27;rose&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> data = useMemo(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, [name])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &#123;count&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>)&#125;&gt;update count &lt;/button&gt;</span><br><span class="line">            &lt;Child data=&#123;data&#125;/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-useCallback"><a href="#6-useCallback" class="headerlink" title="6. useCallback"></a>6. useCallback</h2><blockquote><p><code>useCallback</code>与<code>useMemo</code>的差别是，前者是缓存函数，后者是缓存值</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> onChange = useCallback(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    setText(e.target.value)</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure><p><code>useCallback(fn, deps)</code>相当于<code>useMemo(() =&gt; fn, deps)</code></p><h2 id="7-useContext"><a href="#7-useContext" class="headerlink" title="7. useContext"></a>7. useContext</h2><p>接收一个 context 对象（由<code>React.createContext</code> 所创建）并返回该 context 的当前值，当前的 context 值由上层组件中距离当前组件最近的 <code>&lt;MyContext.Provider&gt;</code> 的 <code>value</code> prop 决定</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TextContext = React.createContext();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;TextContext.Provider value=&#123;<span class="number">666</span>&#125;&gt;</span><br><span class="line">      &lt;Toolbar /&gt;</span><br><span class="line">    &lt;/TextContext.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Toolbar</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;xxxButton /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xxxButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> text = useContext(ThemeContext);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button style=&#123;&#123; <span class="attr">color</span>: text &#125;&#125;&gt;</span><br><span class="line">      I am styled by theme context!</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当组件上层最近的 <code>&lt;MyContext.Provider&gt;</code> 更新时，该 Hook 会触发重渲染，并使用最新传递给 <code>MyContext</code> provider 的 context <code>value</code> 值。即使祖先使用 <a href="https://zh-hans.reactjs.org/docs/react-api.html#reactmemo"><code>React.memo</code></a> 或 <a href="https://zh-hans.reactjs.org/docs/react-component.html#shouldcomponentupdate"><code>shouldComponentUpdate</code></a>，也会在组件本身使用 <code>useContext</code> 时重新渲染</p><h2 id="8-useLayoutEffect"><a href="#8-useLayoutEffect" class="headerlink" title="8. useLayoutEffect"></a>8. useLayoutEffect</h2><ul><li><p><code>useLayoutEffect</code>会在浏览器 layout 之后，painting 之前执行</p></li><li><p>其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后<strong>同步</strong>调用 effect</p></li><li><p><strong>可以使用它来读取 DOM 布局并同步触发重渲染</strong></p></li><li><p><strong>尽可能使用标准的 useEffect 以避免阻塞视图更新</strong></p></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LayoutEffect</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [color, setColor] = useState(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line">    useLayoutEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        alert(color);</span><br><span class="line">    &#125;);</span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;color&#x27;</span>, color);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;React.Fragment&gt;</span><br><span class="line">            &lt;div id=<span class="string">&quot;myDiv&quot;</span> style=&#123;&#123; <span class="attr">background</span>: color &#125;&#125;&gt;颜色&lt;/div&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="function">() =&gt;</span> setColor(<span class="string">&#x27;red&#x27;</span>)&#125;&gt;红&lt;/button&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="function">() =&gt;</span> setColor(<span class="string">&#x27;yellow&#x27;</span>)&#125;&gt;黄&lt;/button&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="function">() =&gt;</span> setColor(<span class="string">&#x27;blue&#x27;</span>)&#125;&gt;蓝&lt;/button&gt;</span><br><span class="line">        &lt;/React.Fragment&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 先alert出red，再渲染出页面，阻塞渲染</p><h2 id="9-自定义Hook"><a href="#9-自定义Hook" class="headerlink" title="9. 自定义Hook"></a>9. 自定义Hook</h2><p>其实就是写一个函数内部调用其他Hook，每次使用自定义Hook时，所有的state和副作用都是完全隔离的</p><p>例如：我们可以对useRef封装成自定义Hook来获取上一次的值</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> usePrevious = <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> ref = useRef();</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        ref.current = state;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ref.current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> prevCount = usePrevious(count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>)&#125;&gt;</span><br><span class="line">                Cause re-render</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">            &lt;p&gt; &#123;count&#125; &#123;prevCount&#125;&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次点击button，prevCount都是上一次count的值</p><h2 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h2><h3 id="1-为什么我的count没有更新"><a href="#1-为什么我的count没有更新" class="headerlink" title="1. 为什么我的count没有更新"></a>1. 为什么我的count没有更新</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ErrorDemo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> dom = useRef(<span class="literal">null</span>);</span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        dom.current.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>));</span><br><span class="line">    &#125;, []);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;dom&#125;</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码，用户点击div，count只会加到1，后面就不会再加了。</p><p>原因是：每次 <code>count</code> 都是重新声明的变量，指向一个全新的数据；每次的 <code>setCount</code> 虽然是重新声明的，但指向的是同一个引用。</p><h3 id="解决方式一：函数式更新"><a href="#解决方式一：函数式更新" class="headerlink" title="解决方式一：函数式更新"></a>解决方式一：函数式更新</h3><p>用回调函数的形式，<code>() =&gt; setCount(prevCount =&gt; ++prevCount)</code>，来消除对外部count的引用。</p><h3 id="解决方式二：重新绑定事件"><a href="#解决方式二：重新绑定事件" class="headerlink" title="解决方式二：重新绑定事件"></a>解决方式二：重新绑定事件</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    dom.current.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> dom.current.removeEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>));</span><br><span class="line">&#125;, [count]); <span class="comment">// 在这里对count进行监听，每次改变都会重新绑定事件</span></span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><h3 id="解决方式三：用ref重新获取引用"><a href="#解决方式三：用ref重新获取引用" class="headerlink" title="解决方式三：用ref重新获取引用"></a>解决方式三：用ref重新获取引用</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dom = useRef(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">const</span> countRef = useRef(count);</span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    dom.current.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        countRef.current++;</span><br><span class="line">        setCount(countRef.current);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844904090032406536">写React Hooks前必读</a><br><a href="https://juejin.cn/post/6844904072168865800">终于搞懂 React Hooks了！！！！！</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;函数式组件只能使用props，Hook能够在函数式组件的情况下使用state、生命周期以及其他的React特性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么需要引入React Hook，可以查看官方文档：&lt;a href=&quot;https://zh-
      
    
    </summary>
    
    
      <category term="前端" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="React" scheme="https://liang5757.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React Router</title>
    <link href="https://liang5757.github.io/2021/05/28/React/React%20Router/"/>
    <id>https://liang5757.github.io/2021/05/28/React/React%20Router/</id>
    <published>2021-05-28T12:13:21.000Z</published>
    <updated>2021-05-28T15:50:29.396Z</updated>
    
    <content type="html"><![CDATA[<ul><li>react-router：路由核心库，包含诸多和路由功能相关的核心代码</li><li>react-router-dom：利用路由核心库，结合实际的页面，实现跟页面路由密切相关的功能</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># react-router-dom依赖react-router</span></span><br><span class="line"><span class="comment"># 安装的时候会把react-router一起安装了</span></span><br><span class="line">npm install react-router-dom -S</span><br></pre></td></tr></table></figure><h2 id="1-两种路由模式-Hash、History"><a href="#1-两种路由模式-Hash、History" class="headerlink" title="1.两种路由模式 Hash、History"></a>1.两种路由模式 Hash、History</h2><ul><li><code>HashRouter</code>：使用 hash 模式匹配</li><li><code>BrowserRouter</code>：使用 BrowserHistory 模式匹配</li></ul><p>两者区别<br>1.底层原理不一样：<br>    BrowserRouter使用的是H5的history API，不兼容IE9及以下版本。<br>    HashRouter使用的是URL的哈希值。<br>2.path表现形式不一样<br>    BrowserRouter的路径中没有#，例如：localhost:3000/demo/test<br>    HashRouter的路径包含#,例如：localhost:3000/#/demo/test<br>3.刷新后对路由state参数的影响<br>    BrowserRouter没有任何影响，因为state保存在history对象中。<br>    HashRouter刷新后会导致路由state参数的丢失！！！<br>4.备注：HashRouter可以用于解决一些路径错误相关的问题。</p><h2 id="2-跳转组件-Link和NavLink"><a href="#2-跳转组件-Link和NavLink" class="headerlink" title="2. 跳转组件 Link和NavLink"></a>2. 跳转组件 Link和NavLink</h2><p>Link组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=<span class="string">&quot;/xxxxx&quot;</span>&gt;Demo&lt;/Link&gt;</span><br></pre></td></tr></table></figure><p>Link组件配置方式</p><ul><li><p>to：要跳转的链接（String | Object  | Function）</p></li><li><p>replace：设置为true，则跳转替换路由栈顶</p></li><li><p>innerRef：可以将内部的a元素的ref附着在传递的对象或函数参数上（Function | RefObject）</p></li><li><p>component：可以设置自定义的导航组件</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> FancyLink = React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> (</span><br><span class="line">    &lt;a ref=&#123;ref&#125; &#123;...props&#125;&gt;💅 &#123;props.children&#125;&lt;/a&gt;</span><br><span class="line">))</span><br><span class="line"></span><br><span class="line">&lt;Link to=<span class="string">&quot;/&quot;</span> component=&#123;FancyLink&#125; /&gt;</span><br></pre></td></tr></table></figure></li></ul><p><strong>NavLink</strong>可以实现路由链接的高亮，通过<code>activeClassName</code>指定样式类名</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink to=<span class="string">&quot;/xxxxx&quot;</span>&gt;Demo&lt;/NavLink&gt;</span><br></pre></td></tr></table></figure><h2 id="3-route组件"><a href="#3-route组件" class="headerlink" title="3. route组件"></a>3. route组件</h2><p>配置方式</p><ul><li>path：匹配的路径<ul><li>默认情况下，不区分大小写，可以设置sensitive属性为true，来区分大小写</li><li>默认情况下，只匹配初始目录，如果要精确匹配，配置exact属性为true</li><li>如果不写path，则会匹配任意路径</li></ul></li><li>component：匹配成功后要显示的组件</li><li>children<ul><li>传递React元素，无论是否匹配，一定会显示children，并且会忽略component属性</li><li>传递一个函数，该函数有多个参数，这些参数来自于上下文，该函数返回react元素，则一定会显示返回的元素，并且忽略component属性</li></ul></li><li>render：匹配成功渲染的组件，内联书写render，而不是创建一个React元素</li><li>sensitive：true则对paht的大小写敏感</li><li>exact：精确匹配</li></ul><h3 id="route嵌套"><a href="#route嵌套" class="headerlink" title="route嵌套"></a>route嵌套</h3><p>下述代码中，用户访问<code>/repos</code>时，会先加载<code>App</code>组件，然后在它的内部再加载<code>Repos</code>组件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;BrowserRouter history=&#123;hashHistory&#125;&gt;</span><br><span class="line">    &lt;Route path=<span class="string">&quot;/&quot;</span> component=&#123;App&#125;&gt;</span><br><span class="line">        &lt;Route path=<span class="string">&quot;/repos&quot;</span> component=&#123;Repos&#125;/&gt;</span><br><span class="line">        &lt;Route path=<span class="string">&quot;/about&quot;</span> component=&#123;About&#125;/&gt;</span><br><span class="line">    &lt;/Route&gt;</span><br><span class="line">&lt;/BrowserRouter&gt;</span><br></pre></td></tr></table></figure><h3 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h3><ol><li>:paramName</li></ol><p><code>:paramName</code>匹配URL的一个部分，直到遇到下一个<code>/</code>、<code>?</code>、<code>#</code>为止。这个路径参数可以通过<code>this.props.params.paramName</code>取出。</p><ol start="2"><li>()</li></ol><p><code>()</code>表示URL的这个部分是可选的。</p><ol start="3"><li>*</li></ol><p><code>*</code>匹配任意字符，直到模式里面的下一个字符为止。匹配方式是非贪婪模式。</p><ol start="4"><li>**</li></ol><p><code>**</code> 匹配任意字符，直到下一个<code>/</code>、<code>?</code>、<code>#</code>为止。匹配方式是贪婪模式。</p><p>此外，URL的查询字符串<code>/foo?bar=baz</code>，可以用<code>this.props.location.query.bar</code>获取。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserRouter, Route &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line">&lt;BrowserRouter&gt;</span><br><span class="line">    &lt;Route path=<span class="string">&quot;/a&quot;</span> component=&#123;A&#125; /&gt;</span><br><span class="line">    &lt;Route path=<span class="string">&quot;/a/d&quot;</span> exact component=&#123;D&#125;/&gt;  <span class="comment">// 精确匹配</span></span><br><span class="line">    &lt;Route component=&#123;C&#125; /&gt;</span><br><span class="line">    &lt;Route path=<span class="string">&#x27;/abc&#x27;</span> children=&#123;E&#125;/&gt;</span><br><span class="line">&lt;/BrowserRouter&gt;</span><br></pre></td></tr></table></figure><p>  上述代码，如果路由是 <strong>/a/d，则会渲染 A、D、C、E</strong>，react router是会从上至下完全匹配一遍，而为了解决这个问题，引入了Switch组件。</p><h2 id="4-Switch组件"><a href="#4-Switch组件" class="headerlink" title="4. Switch组件"></a>4. Switch组件</h2><p>会<strong>循环所有子元素</strong>，当匹配到第一个Route后，会立即停止匹配并渲染，因此不能在Switch组件的子元素中使用除Route外的其他组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">    &lt;Switch&gt;</span><br><span class="line">        &lt;Route path=<span class="string">&quot;/a&quot;</span> component=&#123;A&#125; /&gt;</span><br><span class="line">        &lt;Route path=<span class="string">&quot;/a/b&quot;</span> component=&#123;B&#125; /&gt;</span><br><span class="line">        &lt;Route component=&#123;C&#125; /&gt;</span><br><span class="line">    &lt;/Switch&gt;</span><br><span class="line">&lt;/Router&gt;</span><br></pre></td></tr></table></figure><h2 id="5-Redirect组件"><a href="#5-Redirect组件" class="headerlink" title="5. Redirect组件"></a>5. Redirect组件</h2><p>一般写在所有路由注册的最下方，当所有路由都无法匹配时，跳转到Redirect指定的路由</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Redirect to=<span class="string">&quot;/about/&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><h2 id="6-路由信息"><a href="#6-路由信息" class="headerlink" title="6. 路由信息"></a>6. 路由信息</h2><p>Router组件会创建一个上下文，并且向上下文中注入一些信息，该上下文对开发者是隐藏的，Route组件若匹配到了地址，则会将这些上下文中的信息作为属性传入对应的组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter <span class="keyword">as</span> Router, Route, Switch &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(props)</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>组件A<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Router&gt;</span><br><span class="line">            &lt;Switch&gt;</span><br><span class="line">                &lt;Route path=<span class="string">&quot;/a&quot;</span> component=&#123;A&#125; /&gt;</span><br><span class="line">            &lt;/Switch&gt;</span><br><span class="line">        &lt;/Router&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印一下props</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span>:</span><br><span class="line">go: ƒ go(n)</span><br><span class="line">goBack: ƒ goBack()</span><br><span class="line">goForward: ƒ goForward()</span><br><span class="line">push: ƒ push(path, state)</span><br><span class="line">replace: ƒ replace(path, state)</span><br><span class="line">location:</span><br><span class="line">    <span class="built_in">hash</span>：页面<span class="built_in">hash</span></span><br><span class="line">    pathname：页面的path</span><br><span class="line">    state：push时传入的数据</span><br><span class="line">    search：传入的参数</span><br><span class="line">match:</span><br><span class="line">isExact：事实上，当前的路径和路由配置的路径是否是精确匹配的</span><br><span class="line">params：获取路径中对应的数据</span><br><span class="line">path：路径规则</span><br><span class="line">url：页面路径</span><br></pre></td></tr></table></figure><h2 id="7-路由传参"><a href="#7-路由传参" class="headerlink" title="7.路由传参"></a>7.路由传参</h2><h3 id="5-1-params-参数"><a href="#5-1-params-参数" class="headerlink" title="5.1 params 参数"></a>5.1 params 参数</h3><p>路由链接(携带参数)：<code>&lt;Link to=&#39;/demo/test/tom/18&#39;&#125;&gt;详情&lt;/Link&gt;</code><br>注册路由(声明接收)：<code>&lt;Route path=&quot;/demo/test/:name/:age&quot; component=&#123;Test&#125;/&gt;</code><br>接收参数：this.props.match.params</p><h3 id="5-2-search参数"><a href="#5-2-search参数" class="headerlink" title="5.2 search参数"></a>5.2 search参数</h3><p>路由链接(携带参数)：<code>&lt;Link to=&#39;/demo/test?name=tom&amp;age=18&#39;&#125;&gt;详情&lt;/Link&gt;</code><br>注册路由(无需声明，正常注册即可)：<code>&lt;Route path=&quot;/demo/test&quot; component=&#123;Test&#125;/&gt;</code><br>接收参数：<code>this.props.location.search</code><br>备注：获取到的search是urlencoded编码字符串，需要借助querystring解析</p><h3 id="5-3-state参数"><a href="#5-3-state参数" class="headerlink" title="5.3 state参数"></a>5.3 state参数</h3><p>路由链接(携带参数)：<code>&lt;Link to=&#123;&#123;pathname:'/demo/test',state:&#123;name:'tom',age:18&#125;&#125;&#125;&gt;详情&lt;/Link&gt;</code><br>注册路由(无需声明，正常注册即可)：<code>&lt;Route path=&quot;/demo/test&quot; component=&#123;Test&#125;/&gt;</code><br>接收参数：<code>this.props.location.state</code><br>备注：刷新也可以保留住参数</p><h2 id="8-编程式导航"><a href="#8-编程式导航" class="headerlink" title="8. 编程式导航"></a>8. 编程式导航</h2><p>借助<code>this.props.history</code>上的方法，基本和H5的history一致，就只是列一下了</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.props.history.push()</span><br><span class="line"><span class="built_in">this</span>.props.history.replace()</span><br><span class="line"><span class="built_in">this</span>.props.history.goBack()</span><br><span class="line"><span class="built_in">this</span>.props.history.goForward()</span><br><span class="line"><span class="built_in">this</span>.props.history.go()</span><br></pre></td></tr></table></figure><h2 id="9-withRouter"><a href="#9-withRouter" class="headerlink" title="9. withRouter"></a>9. withRouter</h2><blockquote><p>由于<strong>只能在跳转的组件中获取路由信息</strong>，所以提出<code>withRouter</code>，用withRouter包裹的组件能获取路由信息</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ButtonContainer</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> history = props.history;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=&#123;<span class="string">&quot;container&quot;</span>&#125;&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="function">() =&gt;</span> &#123;history.push(<span class="string">&quot;/a?key=a&quot;</span>, <span class="string">&quot;A状态数据&quot;</span>)&#125;&#125;&gt;A&lt;/button&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="function">() =&gt;</span> &#123;history.push(<span class="string">&quot;/a/b?key=b&quot;</span>, <span class="string">&quot;B状态数据&quot;</span>)&#125;&#125;&gt;B&lt;/button&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="function">() =&gt;</span> &#123;history.push(<span class="string">&quot;/a/c?key=c&quot;</span>, <span class="string">&quot;C状态数据&quot;</span>)&#125;&#125;&gt;C&lt;/button&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="function">() =&gt;</span> &#123;history.push(<span class="string">&quot;/a/d?key=d&quot;</span>, <span class="string">&quot;D状态数据&quot;</span>)&#125;&#125;&gt;D&lt;/button&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="function">() =&gt;</span> &#123;history.push(<span class="string">&quot;/a/news/2020/12/21&quot;</span>)&#125;&#125;&gt;News&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> WithRouterButtonContainer = withRouter(ButtonContainer)</span><br></pre></td></tr></table></figure><p>其返回值是一个新组件</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.sakura-snow.com/post/react-node-5/">react学习笔记5-React Router</a><br>[React Router 使用教程](</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;react-router：路由核心库，包含诸多和路由功能相关的核心代码&lt;/li&gt;
&lt;li&gt;react-router-dom：利用路由核心库，结合实际的页面，实现跟页面路由密切相关的功能&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; c
      
    
    </summary>
    
    
      <category term="前端" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="React" scheme="https://liang5757.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React从入门到真香</title>
    <link href="https://liang5757.github.io/2021/05/27/React/React%E5%85%A5%E9%97%A8/"/>
    <id>https://liang5757.github.io/2021/05/27/React/React%E5%85%A5%E9%97%A8/</id>
    <published>2021-05-27T15:41:33.000Z</published>
    <updated>2021-06-09T13:59:28.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-设计思想"><a href="#1-设计思想" class="headerlink" title="1. 设计思想"></a>1. 设计思想</h2><ol><li><a href="https://github.com/react-guide/react-basic">React 设计思想</a></li><li><a href="http://www.infoq.com/cn/articles/react-art-of-simplity/">React的设计哲学 - 简单之美</a></li><li><a href="http://www.infoq.com/cn/articles/subversion-front-end-ui-development-framework-react/">颠覆式前端UI开发框架:React</a></li></ol><h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h2><h3 id="2-1-CDN的方式引入"><a href="#2-1-CDN的方式引入" class="headerlink" title="2.1 CDN的方式引入"></a>2.1 CDN的方式引入</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react@17/umd/react.development.js&quot;</span> <span class="attr">crossorigin</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react-dom@17/umd/react-dom.development.js&quot;</span> <span class="attr">crossorigin</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>react.js：React核心库</li><li>react-dom.js：提供操作 DOM 的 react 扩展库</li><li>babel.min.js：解析 JSX 语法代码转为 JS 代码的库</li></ul><h3 id="2-2-create-react-app"><a href="#2-2-create-react-app" class="headerlink" title="2.2 create-react-app"></a>2.2 create-react-app</h3><p>安装<code>create-react-app</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm isntall -g create-react-app</span><br></pre></td></tr></table></figure><p>创建项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create-react-app my-app</span><br></pre></td></tr></table></figure><h2 id="3-JSX"><a href="#3-JSX" class="headerlink" title="3. JSX"></a>3. JSX</h2><p>jsx 允许在模板中用<code>&#123;&#125;</code>插入JavaScript表达式，如果<code>&#123;&#125;</code>中的变量是数组，则会展开这个数组的所有成员</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">  &lt;h1&gt;Hello world!&lt;/h1&gt;,</span><br><span class="line">  &lt;h2&gt;React is awesome&lt;/h2&gt;,</span><br><span class="line">];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;&#123;arr&#125;&lt;/div&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;example&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> names = [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Emily&#x27;</span>, <span class="string">&#x27;Kate&#x27;</span>];</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    names.map(<span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123; <span class="comment">// 列表渲染</span></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello, &#123;name&#125;!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  &lt;/div&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;example2&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>ReactDOM.render</code>第一个参数是渲染的组件，第二个参数是挂载实例的位置。</p><ul><li>className替换class</li><li>内联样式——style=</li><li>只能含有一个最外层标签</li></ul><p>对于最后一个问题，可以使用React.Fragment组件，它能够在不额外创建 DOM 元素的情况下，让render返回多个元素</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;React.Fragment&gt;</span><br><span class="line">      Some text.</span><br><span class="line">      &lt;h2&gt;A heading&lt;/h2&gt;</span><br><span class="line">    &lt;/React.Fragment&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-组件"><a href="#4-组件" class="headerlink" title="4.组件"></a>4.组件</h2><h3 id="4-1-类组件（有状态）"><a href="#4-1-类组件（有状态）" class="headerlink" title="4.1 类组件（有状态）"></a>4.1 类组件（有状态）</h3><blockquote><p>组件类的第一个名字必须大写</p></blockquote><p>通过继承React.Component来实现类组件，需要实现一个render方法，该方法返回一个模板</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render () &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div onClick=&#123;<span class="built_in">this</span>.clickFunc.bind(<span class="built_in">this</span>)&#125;&gt; <span class="comment">// 将clickFunc内部this指向组件实例</span></span><br><span class="line">                &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">                &lt;h2&gt;It is &#123;<span class="built_in">this</span>.props.date.toLocaleTimeString()&#125;&lt;/h2&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 通过React.createClass生成一个组件类</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Clock = React.createClass(&#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">                &lt;h2&gt;It is &#123;<span class="built_in">this</span>.props.date.toLocaleTimeString()&#125;&lt;/h2&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>两种方式的区别是，前者不会自动绑定this</p><h3 id="4-2-函数式组件（无状态）"><a href="#4-2-函数式组件（无状态）" class="headerlink" title="4.2 函数式组件（无状态）"></a>4.2 函数式组件（无状态）</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;name, age, sex&#125; = props;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;姓名：&#123;name&#125;&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;性别：&#123;sex&#125;&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;年龄：&#123;age&#125;&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-State"><a href="#5-State" class="headerlink" title="5. State"></a>5. State</h2><h3 id="5-1-state初始化"><a href="#5-1-state初始化" class="headerlink" title="5.1 state初始化"></a>5.1 state初始化</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 第一种 直接在实例上定义state属性</span></span><br><span class="line">  state = &#123;</span><br><span class="line">      value: <span class="number">6</span>,</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 第二种 在构造器中设置state</span></span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.state = &#123;</span><br><span class="line">          value: <span class="number">6</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-state修改"><a href="#5-2-state修改" class="headerlink" title="5.2 state修改"></a>5.2 state修改</h3><p><strong>直接修改数据是不会触发视图更新</strong>的，只有使用<code>setState</code>来修改数据，会重新触发组件的render函数</p><p>setState第一个参数就是修改后的state对象，可以修改某一个值，<strong>setState是浅合并</strong>。</p><p>如果setState的第一个参数不是一个对象而是一个函数，这个函数在执行时会通过参数被传入prevState，也就是之前的状态，而返回值就会和state进行合并</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState(<span class="function">(<span class="params">prevState : any</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        num : prevState.num + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.num)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但是setState有两个问题</p><ul><li>setState对状态的修改，可能是异步执行的（如果改变状态的代码处于某个HTML元素的事件中，则其是异步的，否则是同步）</li><li>React会对异步的setState进行优化，将多次setState进行合并（将多次状态改变完成后，再统一对state进行改变，然后触发render）</li></ul><p>下面给出第一个问题的例子</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Comp</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        num: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">            num: <span class="built_in">this</span>.state.num + <span class="number">1</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.num) <span class="comment">// 第一下点击输出 0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render () &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;React.Fragment&gt;</span><br><span class="line">                &lt;p&gt;&#123;<span class="built_in">this</span>.state.num&#125;&lt;/p&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="built_in">this</span>.handleClick&#125;&gt;点我&lt;/button&gt;</span><br><span class="line">            &lt;/React.Fragment&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第一下点击按钮的时候，console.log输出 0，说明setState在DOM事件中是异步执行的。</p><p><strong>解决方式</strong>：setState有第二个参数，来放置render执行后接着执行的回调函数</p><h2 id="6-Props"><a href="#6-Props" class="headerlink" title="6. Props"></a>6. Props</h2><h3 id="6-1-传递参数"><a href="#6-1-传递参数" class="headerlink" title="6.1 传递参数"></a>6.1 传递参数</h3><p>父组件在使用子组件的时候，通过给子组件元素设置属性的方式传递参数给子组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件设置属性给子组件传参，这里属性名用value2用作区分</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Board</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render () &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;Square value2=&#123;<span class="number">0</span>&#125;/&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类组件 通过 this.props.[属性] 来获取参数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;button className=<span class="string">&quot;square&quot;</span>&gt;</span><br><span class="line">                &#123;<span class="built_in">this</span>.props.value2&#125;</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数式组件通过 props.[属性] 来获取参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square</span> (<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;button className=<span class="string">&quot;square&quot;</span>&gt;</span><br><span class="line">            &#123;props.value2&#125;</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-props传递事件"><a href="#6-2-props传递事件" class="headerlink" title="6.2 props传递事件"></a>6.2 props传递事件</h3><p>通过this.props.[事件名]调用</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Board</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render () &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;Square click=&#123;<span class="function">() =&gt;</span> &#123;alert(<span class="string">&quot;click event&quot;</span>)&#125;&#125;/&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;button onClick=&#123;<span class="built_in">this</span>.props.click&#125; className=<span class="string">&quot;square&quot;</span>&gt;</span><br><span class="line">              button</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-props校验"><a href="#6-3-props校验" class="headerlink" title="6.3 props校验"></a>6.3 props校验</h3><p>1.需要引入一个库prop-types.js</p><ul><li>cdn</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/prop-types@15.6/prop-types.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>npm</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save prop-types </span><br></pre></td></tr></table></figure><p>2.使用方式</p><p>在组件上定义 PropTypes对象，键就是props的名，值就是限制。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// ... do things with the props</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式一</span></span><br><span class="line">    <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">        value1: PropTypes.number.isRequired,</span><br><span class="line">        value2: PropTypes.string</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定props默认值</span></span><br><span class="line"><span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">        value1: <span class="number">666</span>,</span><br><span class="line">        value2: <span class="string">&quot;6&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line">Square.propTypes = &#123;</span><br><span class="line">    value1: PropTypes.number.isRequired,</span><br><span class="line">    value2: PropTypes.string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多使用方式参考：<a href="https://github.com/facebook/prop-types">https://github.com/facebook/prop-types</a></p><h3 id="6-4-this-props-children"><a href="#6-4-this-props-children" class="headerlink" title="6.4 this.props.children"></a>6.4 this.props.children</h3><blockquote><p>获取组件所有子节点</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotesList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;ol&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    React.Children.map(<span class="built_in">this</span>.props.children, <span class="function"><span class="keyword">function</span> (<span class="params">child</span>) </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;child&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &lt;/ol&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;NotesList&gt;</span><br><span class="line">        &lt;span&gt;hello&lt;/span&gt;</span><br><span class="line">        &lt;span&gt;world&lt;/span&gt;</span><br><span class="line">    &lt;/NotesList&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;example&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>没有子节点：undefined</li><li>一个子节点：object</li><li>多个子节点：array</li></ul><p>可以用<code>React.Children.map</code>来遍历子节点，则不需要担心子元素个数</p><h3 id="6-5-props传递组件"><a href="#6-5-props传递组件" class="headerlink" title="6.5 props传递组件"></a>6.5 props传递组件</h3><p>React组件本质就是对象，当作props像其他数据一样传递也是可以的</p><h2 id="7-React生命周期"><a href="#7-React生命周期" class="headerlink" title="7. React生命周期"></a>7. React生命周期</h2><blockquote><p>感觉和vue差不多，直接简单带过把</p></blockquote><h4 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount()"></a>componentWillMount()</h4><p>组件即将被渲染到页面之前触发，此时可以进行开启定时器、向服务器发送请求等操作</p><h4 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount()"></a>componentDidMount()</h4><p>组件已经被渲染到页面中后触发，可以通过<code>this.getDOMNode()</code>来进行访问DOM。</p><h4 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps()"></a>componentWillReceiveProps()</h4><p>在组件接收到一个新的 prop (更新后)时被调用。这个方法在初始化<code>render</code>时不会被调用。</p><h4 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate()"></a>shouldComponentUpdate()</h4><p>返回一个布尔值。在组件接收到新的<code>props</code>或者<code>state</code>时被调用。在初始化时或者使用<code>forceUpdate</code>时不被调用。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该钩子函数可以接收到两个参数，新的属性和状态，返回true/false来控制组件是否需要更新。</span></span><br><span class="line"><span class="function"><span class="title">shouldComponentUpdate</span>(<span class="params">newProps, newState</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (newProps.number &lt; <span class="number">5</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一个React项目需要更新一个小组件时，很可能需要父组件更新自己的状态。而一个<strong>父组件的重新更新会造成它旗下所有的子组件重新执行render()方法（即使没有使用父组件的state）</strong>，形成新的虚拟DOM，再用diff算法对新旧虚拟DOM进行结构和属性的比较，决定组件是否需要重新渲染，还可以使用下面说了PureComponent</p></blockquote><h4 id="componentWillUpdate"><a href="#componentWillUpdate" class="headerlink" title="componentWillUpdate()"></a>componentWillUpdate()</h4><p>在组件接收到新的<code>props</code>或者<code>state</code>但还没有<code>render</code>时被调用。在初始化时不会被调用。</p><h4 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate()"></a>componentDidUpdate()</h4><p>在组件完成更新后立即调用。在初始化时不会被调用。</p><h4 id="componentWillUnMount"><a href="#componentWillUnMount" class="headerlink" title="componentWillUnMount()"></a>componentWillUnMount()</h4><p>组件被销毁时触发。这里我们可以进行一些清理操作，例如清理定时器，取消Redux的订阅事件等等。</p><h4 id="getDerivedStateFromError"><a href="#getDerivedStateFromError" class="headerlink" title="getDerivedStateFromError()"></a>getDerivedStateFromError()</h4><p>这个生命周期方法在<strong>ErrorBoundary</strong>类中使用。实际上，如果使用这个生命周期方法，任何类都会变成<code>ErrorBoundary</code>。这用于在组件树中出现错误时呈现回退UI，而不是在屏幕上显示一些奇怪的错误。</p><h4 id="componentDidCatch"><a href="#componentDidCatch" class="headerlink" title="componentDidCatch()"></a>componentDidCatch()</h4><p>这个生命周期方法在<strong>ErrorBoundary</strong>类中使用。实际上，如果使用这个生命周期方法，任何类都会变成<code>ErrorBoundary</code>。这用于在组件树中出现错误时记录错误。</p><h2 id="8-Ref"><a href="#8-Ref" class="headerlink" title="8. Ref"></a>8. Ref</h2><p>用来访问DOM元素或render中的react元素，Ref的使用规则如下</p><ol><li>ref作用于内置的html组件时，得到的将是真实的dom对象</li><li>ref作用于类组件时，得到的将是类的实例</li><li>ref不能作用于函数组件（因为没有实例），但是函数组件内部可以</li></ol><h3 id="8-1-创建ref"><a href="#8-1-创建ref" class="headerlink" title="8.1 创建ref"></a>8.1 创建ref</h3><p>ref的可选值为</p><ol><li><p>字符串（不建议）</p><p> 原因：<a href="http://www.qiutianaimeili.com/html/page/2020/04/20204277uz3udr631a.html">react ref注意事项</a></p></li><li><p>回调函数</p><p> 触发时机：ref中的回调函数会在对应的<strong>普通</strong>组件（或元素）<code>componentDidMount</code>，<code>ComponentDidUpdate</code>之前，或者<code>componentWillUnmount</code>之后执行</p><p> <strong>注意：</strong>如果 <code>ref</code> 回调函数是以<strong>内联函数的方式定义</strong>的，在更新过程中它会被<strong>执行两次</strong>，第一次传入参数 <code>null</code>，然后第二次会传入参数 DOM 元素。这是因为在<strong>每次渲染时会创建一个新的函数实例</strong>，所以 React 清空旧的 ref 并且设置新的</p></li><li><p>createRef</p></li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.textInput = React.createRef();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">focusTextInput</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 注意：我们通过 &quot;current&quot; 来访问 DOM 节点</span></span><br><span class="line">        <span class="built_in">this</span>.textInput.current.focus();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;React.Fragment&gt;</span><br><span class="line">                &lt;input type=<span class="string">&quot;text&quot;</span> ref=&#123;<span class="built_in">this</span>.textInput&#125; /&gt;</span><br><span class="line">                &lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;Focus the text input&quot;</span> onClick=&#123;<span class="built_in">this</span>.focusTextInput.bind(<span class="built_in">this</span>)&#125;/&gt;</span><br><span class="line">            &lt;/React.Fragment&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-转发ref"><a href="#8-2-转发ref" class="headerlink" title="8.2 转发ref"></a>8.2 转发ref</h3><blockquote><p>用于获取组件内部的某个元素，有些高度复用的基础组件不可避免的需要在父组件获取，用以管理焦点等</p></blockquote><p><code>React.forwardRef</code>用以获取传递给它的<code>ref</code>，然后转发到渲染它的DOM。</p><p>对于<strong>函数式组件</strong>，<code>React.forwardRef</code>直接包裹函数就可以接收到ref</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> FancyButton = React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> (</span><br><span class="line">  &lt;button ref=&#123;ref&#125; className=<span class="string">&quot;FancyButton&quot;</span>&gt;</span><br><span class="line">    &#123;props.children&#125;</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你可以直接获取 DOM button 的 ref：</span></span><br><span class="line"><span class="keyword">const</span> ref = React.createRef();</span><br><span class="line">&lt;FancyButton ref=&#123;ref&#125;&gt;Click me!&lt;/FancyButton&gt;;</span><br></pre></td></tr></table></figure><p>使用 <code>FancyButton</code> 的组件可以获取底层 DOM 节点 <code>button</code> 的 ref </p><p>而对于<strong>类组件</strong>，需要使用HOC的形式，用<code>React.forwardRef</code>包裹返回的函数式组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logProps</span>(<span class="params">Component</span>) </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LogProps</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123;forwardedRef, ...rest&#125; = <span class="built_in">this</span>.props;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将自定义的 prop 属性 “forwardedRef” 定义为 ref</span></span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;forwardedRef&#125;</span> &#123;<span class="attr">...rest</span>&#125; /&gt;</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意 React.forwardRef 回调的第二个参数 “ref”。</span></span><br><span class="line">    <span class="comment">// 我们可以将其作为常规 prop 属性传递给 LogProps，例如 “forwardedRef”</span></span><br><span class="line">    <span class="comment">// 然后它就可以被挂载到被 LogProps 包裹的子组件上。</span></span><br><span class="line">    <span class="keyword">return</span> React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">LogProps</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">forwardedRef</span>=<span class="string">&#123;ref&#125;</span> /&gt;</span></span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>React.forwardRef</code>包裹的组件在<strong>DevTools中显示为”ForwardRef”</strong>，可以把包裹的函数用普通函数的形式命名，DevTools也将包含其名称（例如 “<em>ForwardRef(myFunction)</em>”），也可以<strong>设置函数的displayName属性</strong>来设置DevTools中显示的名字</p><h2 id="9-Context"><a href="#9-Context" class="headerlink" title="9.Context"></a>9.Context</h2><blockquote><p>跨组件的通信方式，等同Vue的provide、inject</p></blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>1.创建Context容器对象</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有当组件所处的树中没有匹配到 Provider 时，其 defaultValue 参数才会生效</span></span><br><span class="line"><span class="keyword">const</span> xxxContext = React.createContext(defaultValue) </span><br></pre></td></tr></table></figure><p>2.渲染子组时，外面包裹xxxContext.Provider，通过value属性给后代组件传递数据</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;xxxContext.Provider value=&#123;数据&#125;&gt;</span><br><span class="line">    &lt;子组件&gt;&lt;/子组件&gt;</span><br><span class="line">&lt;/xxxContext.Provider&gt;</span><br></pre></td></tr></table></figure><p>ps：如果要传多个数据，需要套多层</p><p>3.后代组件获取数据</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种：仅适用于类组件</span></span><br><span class="line"><span class="keyword">static</span> contextType = xxxContext <span class="comment">// 声明接受context</span></span><br><span class="line"><span class="built_in">this</span>.context; <span class="comment">// 读取context中的value数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种：函数组件与类组件都可以</span></span><br><span class="line">&lt;xxxContext.Consumer&gt;</span><br><span class="line">    &#123;value&#125;</span><br><span class="line">&lt;/xxxContext.Consumer&gt;</span><br></pre></td></tr></table></figure><p><strong>不建议使用该api，他提高了组件复用的难度</strong></p><h2 id="10-PureComponent"><a href="#10-PureComponent" class="headerlink" title="10.PureComponent"></a>10.PureComponent</h2><blockquote><p>父组件setState会触发子组件render，PureComponent通过prop和state的<strong>浅比较</strong>来实现shouldComponentUpdate，算是一种语法糖，帮我们应该在shouldComponentUpdate中应该手动比较的给做了</p></blockquote><p>如果是浅层state或prop没改变，那么不会触发视图更新，书写方式如下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexPage</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>由于是浅比较，所以直接修改对象内部的值是无法更新视图的</strong></p><p>在函数式组件则是用<code>React.memo</code>包裹函数式组件来做到PureComponent的效果</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/tsrot/study-notes/blob/master/React%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB.md">React学习资源汇总</a><br><a href="http://www.ruanyifeng.com/blog/2015/03/react.html">React 入门实例教程</a><br><a href="https://blog.sakura-snow.com/post/react-node-2/">react学习笔记2-react基本使用</a><br><a href="https://blog.sakura-snow.com/post/react-node-3/">react学习笔记3-react其他使用技巧</a><br><a href="https://juejin.cn/post/6844903510538977287">图解ES6中的React生命周期</a><br><a href="https://juejin.cn/post/6844903857135304718#heading-25">你要的 React 面试知识点，都在这了</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-设计思想&quot;&gt;&lt;a href=&quot;#1-设计思想&quot; class=&quot;headerlink&quot; title=&quot;1. 设计思想&quot;&gt;&lt;/a&gt;1. 设计思想&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/react-guide/react-
      
    
    </summary>
    
    
      <category term="前端" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="React" scheme="https://liang5757.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>js准确倒计时</title>
    <link href="https://liang5757.github.io/2021/05/25/Js/js%E5%87%86%E7%A1%AE%E5%80%92%E8%AE%A1%E6%97%B6/"/>
    <id>https://liang5757.github.io/2021/05/25/Js/js%E5%87%86%E7%A1%AE%E5%80%92%E8%AE%A1%E6%97%B6/</id>
    <published>2021-05-24T16:03:51.000Z</published>
    <updated>2021-05-24T16:04:59.178Z</updated>
    
    <content type="html"><![CDATA[<h1 id="js准确倒计时"><a href="#js准确倒计时" class="headerlink" title="js准确倒计时"></a>js准确倒计时</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>如果用最初始的<code>setTimeout</code>递归实现定时器，一秒执行一次回调，则代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟执行大量代码</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i++ &lt; <span class="number">100000000</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countDown</span> (<span class="params">fn, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime(), count = <span class="number">0</span>, second = <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">let</span> timeCounter = <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">interFunc</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> offset = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - (startTime + count * second);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;误差：&quot;</span> + offset + <span class="string">&quot;ms，下一次执行：&quot;</span> + <span class="number">1000</span> + <span class="string">&quot;ms后，离活动开始还有：&quot;</span> + time + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    time -= second;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (time &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timeCounter);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timeCounter = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        interFunc();</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">countDown(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;, <span class="number">10000</span>)(); <span class="comment">// 测试代码</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2021/05/25/Js/js%E5%87%86%E7%A1%AE%E5%80%92%E8%AE%A1%E6%97%B6/image-20210524235731030.png" alt="image-20210524235731030"></p><p>可以看到误差是会越来越多的。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>核心思想就是通过计算 <strong>当前时间 - 应该到的时间</strong> 计算出<strong>时间偏移量</strong>，<strong>下一次延迟时间就是 1s - 偏移量</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟执行大量代码</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i++ &lt; <span class="number">100000000</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 倒计时</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countDown</span> (<span class="params">fn, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime(), count = <span class="number">0</span>, second = <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">let</span> timeCounter = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">interFunc</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> offset = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - (startTime + count * second);</span><br><span class="line">    <span class="keyword">let</span> nextTime = second - offset;</span><br><span class="line">    <span class="keyword">if</span> (nextTime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      nextTime = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;误差：&quot;</span> + offset + <span class="string">&quot;ms，下一次执行：&quot;</span> + nextTime + <span class="string">&quot;ms后，离活动开始还有：&quot;</span> + time + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    time -= second;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (time &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timeCounter);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timeCounter = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        interFunc();</span><br><span class="line">      &#125;, nextTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">countDown(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;, <span class="number">10000</span>)(); <span class="comment">// 测试代码</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2021/05/25/Js/js%E5%87%86%E7%A1%AE%E5%80%92%E8%AE%A1%E6%97%B6/image-20210525000118726.png" alt="image-20210525000118726"></p><p>可以看到虽然仍有误差，但不会随着时间增大</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;js准确倒计时&quot;&gt;&lt;a href=&quot;#js准确倒计时&quot; class=&quot;headerlink&quot; title=&quot;js准确倒计时&quot;&gt;&lt;/a&gt;js准确倒计时&lt;/h1&gt;&lt;h2 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引
      
    
    </summary>
    
    
      <category term="前端" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://liang5757.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>如何给对象设置默认值</title>
    <link href="https://liang5757.github.io/2021/05/06/Js/%E5%A6%82%E4%BD%95%E7%BB%99%E5%AF%B9%E8%B1%A1%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E5%80%BC/"/>
    <id>https://liang5757.github.io/2021/05/06/Js/%E5%A6%82%E4%BD%95%E7%BB%99%E5%AF%B9%E8%B1%A1%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E5%80%BC/</id>
    <published>2021-05-05T17:06:29.000Z</published>
    <updated>2021-05-05T17:18:53.875Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-用-…-解构设置"><a href="#1-用-…-解构设置" class="headerlink" title="1.用 … 解构设置"></a>1.用 … 解构设置</h2><p>在看compressor.js的时候，他用一个文件来存默认值，然后导出，最后用解构的方式，后面的值覆盖前面的方式设置默认值。当然也可以用<code>Object.assign</code>都是一样的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// defaults.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    maxWidth: <span class="literal">Infinity</span>,</span><br><span class="line">    maxHeight: <span class="literal">Infinity</span>,</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> DEFAULTS <span class="keyword">from</span> <span class="string">&#x27;./defaults&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Compressor</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">option</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.option = &#123;</span><br><span class="line">            ...DEFAULTS,</span><br><span class="line">            ...option,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方法看着挺方便的，但是还有缺陷，解决不了下面的问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  a: <span class="string">&quot;a1&quot;</span>,</span><br><span class="line">  b: &#123;</span><br><span class="line">    c: <span class="string">&quot;c1&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> defaults = &#123;</span><br><span class="line">  a: <span class="string">&quot;a2&quot;</span>,</span><br><span class="line">  b: &#123;</span><br><span class="line">    c: <span class="string">&quot;c2&quot;</span>,</span><br><span class="line">    d: <span class="string">&quot;d1&quot;</span> <span class="comment">// 丢失了</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> option = &#123;</span><br><span class="line">  ...defaults,</span><br><span class="line">  ...user</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(option) <span class="comment">// &#123; a: &#x27;a1&#x27;, b: &#123; c: &#x27;c1&#x27; &#125; &#125;</span></span><br></pre></td></tr></table></figure><p>可以看到默认配置中 <strong>d丢失了</strong>，下面的方法可以解决这个问题</p><h2 id="2-extend方法"><a href="#2-extend方法" class="headerlink" title="2.extend方法"></a>2.extend方法</h2><p>Mescroll.js实现的方法，适合多个方法都需要默认值的时候，并且<strong>可以深度匹配默认值</strong>，默认值作为第二个参数传入，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MeScroll.extend = <span class="function"><span class="keyword">function</span> (<span class="params">userOption, defaultOption</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!userOption) <span class="keyword">return</span> defaultOption;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> defaultOption) &#123;</span><br><span class="line">        <span class="keyword">if</span> (userOption[key] == <span class="literal">null</span>) &#123; <span class="comment">// 如果用户没设置，则用默认值</span></span><br><span class="line">            userOption[key] = defaultOption[key]; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> userOption[key] === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">            MeScroll.extend(userOption[key], defaultOption[key]); <span class="comment">// 深度匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userOption;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是有些场景我们是需要有<strong>多个配置进行合并</strong>，我们可以参考jquery的<code>extend</code>实现方式</p><h2 id="3-extend"><a href="#3-extend" class="headerlink" title="3.$.extend"></a>3.$.extend</h2><p><code>$.extend([deep,] [target,] object1 [,objectN])</code></p><blockquote><p><strong>deep</strong>: Boolen类型，可选，表示是否进行递归合并（深/浅复制），为true是为深复制；默认值为false，浅复制。<br><strong>target</strong>:扩展对象，可选，将接收新的属性。<br><strong>objectN</strong>:一个对象，包含额外的属性，扩展到目标对象（扩展对象）。</p></blockquote><p>我们可以砍掉一个没必要的功能，就是<code>$.extend</code>如果参数中只有一个对象，则扩展jquery对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此方法会改变原对象</span></span><br><span class="line">jQuery.extend = jQuery.fn.extend = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> options, name, src, copy, copyIsArray, clone,</span><br><span class="line">    target = <span class="built_in">arguments</span>[<span class="number">0</span>] || &#123;&#125;,</span><br><span class="line">    i = <span class="number">1</span>,    <span class="comment">// i表示从第几个参数开始向目标参数进行合并，默认从第2个参数开始向第1个参数进行合并</span></span><br><span class="line">    length = <span class="built_in">arguments</span>.length,</span><br><span class="line">    deep = <span class="literal">false</span>;  <span class="comment">// 默认为浅度拷贝</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果第一个参数是用来设置deep的boolean值，则将target设置为下一个参数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">&quot;boolean&quot;</span>) &#123;</span><br><span class="line">    deep = target;</span><br><span class="line">    </span><br><span class="line">    target = <span class="built_in">arguments</span>[i] || &#123;&#125;;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//  判断目标参数的类型，若目标参数既不是object类型，也不是function类型，则为目标参数重新赋值</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target !== <span class="string">&quot;object&quot;</span> &amp;&amp; <span class="keyword">typeof</span> target !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    target = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 从第i个参数开始</span></span><br><span class="line">  <span class="keyword">for</span> (; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="comment">// 获取第i个不为null或undefined的参数</span></span><br><span class="line">    <span class="keyword">if</span> ((options = <span class="built_in">arguments</span>[i]) != <span class="literal">null</span>) &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> (name <span class="keyword">in</span> options) &#123;</span><br><span class="line">        src = target[name];</span><br><span class="line">        copy = options[name];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 防止循环引用</span></span><br><span class="line">        <span class="keyword">if</span> (name === <span class="string">&quot;__proto__&quot;</span> || target === copy) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 若deep为true，且当前参数中name字段的值存在且为object类型或Array类型，则进行深合并</span></span><br><span class="line">        <span class="keyword">if</span> (deep &amp;&amp; copy &amp;&amp; (isPlainObject(copy) || (copyIsArray = <span class="built_in">Array</span>.isArray(copy)))) &#123;</span><br><span class="line">          <span class="comment">// 如果copy是数组类型，则判断目标参数中name字段的值是否存在，若存在则使用原来的，否则进行初始化</span></span><br><span class="line">          <span class="keyword">if</span> (copyIsArray &amp;&amp; !<span class="built_in">Array</span>.isArray(src)) &#123;</span><br><span class="line">            clone = [];</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!copyIsArray &amp;&amp; !isPlainObject(src)) &#123;</span><br><span class="line">            clone = &#123;&#125;;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            clone = src;</span><br><span class="line">          &#125;</span><br><span class="line">          copyIsArray = <span class="literal">false</span>;</span><br><span class="line">          </span><br><span class="line">          target[name] = merge(deep, clone, copy);</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// deep为false，表示浅拷贝，直接进行赋值</span></span><br><span class="line">          <span class="comment">// 或者copy不为Object对象、数组，则直接赋值</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (copy !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">          <span class="comment">// 若原对象存在name属性，则直接覆盖掉；若不存在，则创建新的属性</span></span><br><span class="line">          target[name] = copy;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回修改后的目标参数</span></span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="附1：jquery重构了的一段代码"><a href="#附1：jquery重构了的一段代码" class="headerlink" title="附1：jquery重构了的一段代码"></a>附1：jquery重构了的一段代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (deep &amp;&amp; copy &amp;&amp; (jQuery.isPlainObject(copy) || (copyIsArray = <span class="built_in">Array</span>.isArray(copy)))) &#123;</span><br><span class="line">    <span class="keyword">if</span> (copyIsArray) &#123;</span><br><span class="line">        copyIsArray = <span class="literal">false</span>;</span><br><span class="line">        clone = src &amp;&amp; <span class="built_in">Array</span>.isArray(src) ? src : [];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    target[name] = jQuery.extend(deep, clone, copy);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( copy !== <span class="literal">undefined</span> ) &#123;</span><br><span class="line">    target[name] = copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (deep &amp;&amp; copy &amp;&amp; (isPlainObject(copy) || (copyIsArray = <span class="built_in">Array</span>.isArray(copy)))) &#123;</span><br><span class="line">    <span class="keyword">if</span> (copyIsArray &amp;&amp; !<span class="built_in">Array</span>.isArray(src)) &#123;</span><br><span class="line">        clone = [];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!copyIsArray &amp;&amp; !isPlainObject(src)) &#123;</span><br><span class="line">        clone = &#123;&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clone = src;</span><br><span class="line">    &#125;</span><br><span class="line">    copyIsArray = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    target[name] = merge(deep, clone, copy);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (copy !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    target[name] = copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码明显下面好看了许多，可以学习一下这种重构方式</p><h2 id="附2：isEmptyObject、isPlainObject"><a href="#附2：isEmptyObject、isPlainObject" class="headerlink" title="附2：isEmptyObject、isPlainObject"></a>附2：isEmptyObject、isPlainObject</h2><h4 id="1-isEmptyObject"><a href="#1-isEmptyObject" class="headerlink" title="1.isEmptyObject"></a>1.isEmptyObject</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">isEmptyObject: <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (name <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以利用JSON.stringify</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(obj) == <span class="string">&quot;&#123;&#125;&quot;</span></span><br></pre></td></tr></table></figure><h4 id="2-isPlainObject"><a href="#2-isPlainObject" class="headerlink" title="2.isPlainObject"></a>2.isPlainObject</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPlainObject</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.先排除明显不是Object的</span></span><br><span class="line">    <span class="keyword">if</span> (!target || <span class="built_in">Object</span>.prototype.toString.call(target) !== <span class="string">&quot;[object Object]&quot;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.判断是否有原型，没有原型的是简单对象</span></span><br><span class="line">    <span class="keyword">const</span> proto = <span class="built_in">Object</span>.getPrototypeOf(target);</span><br><span class="line">    <span class="keyword">if</span> (!proto) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.判断其构造函数是否为 Object</span></span><br><span class="line">    <span class="keyword">const</span> ctor = proto.constructor;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> ctor === <span class="string">&quot;function&quot;</span> &amp;&amp; ctor === <span class="built_in">Object</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/weixin_33694172/article/details/89369987">https://blog.csdn.net/weixin_33694172/article/details/89369987</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-用-…-解构设置&quot;&gt;&lt;a href=&quot;#1-用-…-解构设置&quot; class=&quot;headerlink&quot; title=&quot;1.用 … 解构设置&quot;&gt;&lt;/a&gt;1.用 … 解构设置&lt;/h2&gt;&lt;p&gt;在看compressor.js的时候，他用一个文件来存默认值，然后导出，最后
      
    
    </summary>
    
    
      <category term="前端" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://liang5757.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>crossvent源码解读</title>
    <link href="https://liang5757.github.io/2021/04/06/Js/crossvent%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>https://liang5757.github.io/2021/04/06/Js/crossvent%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</id>
    <published>2021-04-06T15:46:07.000Z</published>
    <updated>2021-04-06T16:06:44.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="crossvent源码解读"><a href="#crossvent源码解读" class="headerlink" title="crossvent源码解读"></a>crossvent源码解读</h1><blockquote><p>其实就是一个封装事件绑定的库，但是看到了一些技巧记录下来<br>github地址：<a href="https://github.com/bevacqua/crossvent/blob/master/src/crossvent.js">https://github.com/bevacqua/crossvent/blob/master/src/crossvent.js</a></p></blockquote><h2 id="从出口开始"><a href="#从出口开始" class="headerlink" title="从出口开始"></a>从出口开始</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  add: addEvent,</span><br><span class="line">  remove: removeEvent,</span><br><span class="line">  fabricate: fabricateEvent</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="add和remove函数"><a href="#add和remove函数" class="headerlink" title="add和remove函数"></a>add和remove函数</h2><p><code>addEvent</code>实际上就是判断window是否有<code>addEventListener</code>，如果没有就用<code>attachEvent</code>，remove同理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addEvent = addEventEasy;</span><br><span class="line"><span class="keyword">var</span> removeEvent = removeEventEasy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">global</span>.addEventListener) &#123;</span><br><span class="line">  addEvent = addEventHard;</span><br><span class="line">  removeEvent = removeEventHard;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEventEasy</span> (<span class="params">el, type, fn, capturing</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> el.addEventListener(type, fn, capturing); <span class="comment">// capturing如果为true则在事件捕获阶段执行，默认为false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEventHard</span> (<span class="params">el, type, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> el.attachEvent(<span class="string">&#x27;on&#x27;</span> + type, wrap(el, type, fn));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeEventEasy</span> (<span class="params">el, type, fn, capturing</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> el.removeEventListener(type, fn, capturing);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeEventHard</span> (<span class="params">el, type, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> listener = unwrap(el, type, fn);</span><br><span class="line">  <span class="keyword">if</span> (listener) &#123;</span><br><span class="line">    <span class="keyword">return</span> el.detachEvent(<span class="string">&#x27;on&#x27;</span> + type, listener);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意：在不支持<code>addEventListener</code>的时候，使用<code>attachEvent</code>和<code>detachEvent</code>事件回调函数多做了一层<code>wrap</code>和<code>unwrap</code>处理</p><h2 id="wrap和unwrap"><a href="#wrap和unwrap" class="headerlink" title="wrap和unwrap"></a>wrap和unwrap</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hardCache = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrap</span> (<span class="params">el, type, fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果已经注册过这个type的事件，则unwrap即从hardCache删除事件，并在下面重新添加到hardCache数组里</span></span><br><span class="line">  <span class="keyword">var</span> wrapper = unwrap(el, type, fn) || wrapperFactory(el, type, fn); </span><br><span class="line">  hardCache.push(&#123;</span><br><span class="line">    wrapper: wrapper,</span><br><span class="line">    element: el,</span><br><span class="line">    type: type,</span><br><span class="line">    fn: fn</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> wrapper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unwrap</span> (<span class="params">el, type, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = find(el, type, fn);</span><br><span class="line">  <span class="keyword">if</span> (i) &#123;</span><br><span class="line">    <span class="keyword">var</span> wrapper = hardCache[i].wrapper;</span><br><span class="line">    hardCache.splice(i, <span class="number">1</span>); <span class="comment">// free up a tad of memory</span></span><br><span class="line">    <span class="keyword">return</span> wrapper;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span> (<span class="params">el, type, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i, item;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; hardCache.length; i++) &#123;</span><br><span class="line">    item = hardCache[i];</span><br><span class="line">    <span class="keyword">if</span> (item.element === el &amp;&amp; item.type === type &amp;&amp; item.fn === fn) &#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到是利用一个数组存储事件回调，在绑定事件和解绑事件同时对hardCache数组进行操作，但是为啥要这样呢。可以看到在wrap函数的第一行<code>var wrapper = unwrap(el, type, fn) || wrapperFactory(el, type, fn);</code> ，实际上就是如果之前没有绑定这个type的事件，就调用<code>wrapperFactory</code>对<code>fn</code>进行二次封装，<strong><code>wrapperFactory</code>这个封装主要是为了解决event参数内的属性的兼容性</strong>。</p><p>这就解释了刚才提出的疑问，就是因为多了这层解决浏览器兼容性的包装，在解绑事件的时候，如果只是传递原来的fn，则不能解绑事件，需要一个hardCache数组来存取事件回调。</p><h2 id="wrapperFactory"><a href="#wrapperFactory" class="headerlink" title="wrapperFactory"></a>wrapperFactory</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapperFactory</span> (<span class="params">el, type, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">wrapper</span> (<span class="params">originalEvent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> e = originalEvent || <span class="built_in">global</span>.event;</span><br><span class="line">    e.target = e.target || e.srcElement;</span><br><span class="line">    e.preventDefault = e.preventDefault || <span class="function"><span class="keyword">function</span> <span class="title">preventDefault</span> (<span class="params"></span>) </span>&#123; e.returnValue = <span class="literal">false</span>; &#125;;</span><br><span class="line">    e.stopPropagation = e.stopPropagation || <span class="function"><span class="keyword">function</span> <span class="title">stopPropagation</span> (<span class="params"></span>) </span>&#123; e.cancelBubble = <span class="literal">true</span>; &#125;;</span><br><span class="line">    e.which = e.which || e.keyCode;</span><br><span class="line">    fn.call(el, e);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这层封装可以使event的各个属性在不同浏览器下行为一致。</p><p>add和revome就讲完了，我们来看看导出的最后一个函数fabricate</p><h2 id="fabricate"><a href="#fabricate" class="headerlink" title="fabricate"></a>fabricate</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fabricateEvent</span> (<span class="params">el, type, model</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> e = eventmap.indexOf(type) === -<span class="number">1</span> ? makeCustomEvent() : makeClassicEvent(); <span class="comment">// 判断事件类型 并 创建</span></span><br><span class="line">  <span class="keyword">if</span> (el.dispatchEvent) &#123; <span class="comment">// 触发事件</span></span><br><span class="line">    el.dispatchEvent(e);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    el.fireEvent(<span class="string">&#x27;on&#x27;</span> + type, e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">makeClassicEvent</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 创建原生事件</span></span><br><span class="line">    <span class="keyword">var</span> e;</span><br><span class="line">    <span class="keyword">if</span> (doc.createEvent) &#123;</span><br><span class="line">      e = doc.createEvent(<span class="string">&#x27;Event&#x27;</span>);</span><br><span class="line">      e.initEvent(type, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (doc.createEventObject) &#123;</span><br><span class="line">      e = doc.createEventObject();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">makeCustomEvent</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 创建自定义事件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> customEvent(type, &#123; <span class="attr">detail</span>: model &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>eventmap</code>是原生事件名的集合，如果没有在<code>eventmap</code>找到则创建一个自定义事件，否则创建一个原生事件，然后触发事件。</p><p>那么eventmap是怎么生成的呢，我们下面来看看</p><h2 id="获取原生事件名集合"><a href="#获取原生事件名集合" class="headerlink" title="获取原生事件名集合"></a>获取原生事件名集合</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> eventmap = [];</span><br><span class="line"><span class="keyword">var</span> eventname = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> ron = <span class="regexp">/^on/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (eventname <span class="keyword">in</span> <span class="built_in">global</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ron.test(eventname)) &#123;</span><br><span class="line">    eventmap.push(eventname.slice(<span class="number">2</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = eventmap;</span><br></pre></td></tr></table></figure><p>其实就是正则匹配window上的开头为on的属性名</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看到了挺多浏览器兼容的处理方式，以及原生事件名获取的骚操作，不过仍有一些兼容方式没看懂是兼容哪些浏览器的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;crossvent源码解读&quot;&gt;&lt;a href=&quot;#crossvent源码解读&quot; class=&quot;headerlink&quot; title=&quot;crossvent源码解读&quot;&gt;&lt;/a&gt;crossvent源码解读&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;其实就是一个封装事件绑定的
      
    
    </summary>
    
    
      <category term="前端" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://liang5757.github.io/tags/js/"/>
    
      <category term="源码解读" scheme="https://liang5757.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Koa洋葱原型源码解读</title>
    <link href="https://liang5757.github.io/2021/02/28/node.js/Koa%E6%B4%8B%E8%91%B1%E5%8E%9F%E5%9E%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>https://liang5757.github.io/2021/02/28/node.js/Koa%E6%B4%8B%E8%91%B1%E5%8E%9F%E5%9E%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</id>
    <published>2021-02-27T16:25:27.000Z</published>
    <updated>2021-04-06T15:47:30.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Koa洋葱原型源码解读"><a href="#Koa洋葱原型源码解读" class="headerlink" title="Koa洋葱原型源码解读"></a>Koa洋葱原型源码解读</h1><blockquote><p>版本：2.13.1</p></blockquote><h2 id="application-js"><a href="#application-js" class="headerlink" title="application.js"></a>application.js</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">this</span>.middleware = [];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>有一个<code>middleware</code>存函数</p></blockquote><h3 id="use方法"><a href="#use方法" class="headerlink" title="use方法"></a>use方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">use</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">this</span>.middleware.push(fn);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次使用app.use()就会吧回调函数push到<code>middleware</code>里</p><h3 id="listen方法"><a href="#listen方法" class="headerlink" title="listen方法"></a>listen方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">listen</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> server = http.createServer(<span class="built_in">this</span>.callback());</span><br><span class="line">    <span class="keyword">return</span> server.listen(...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个服务，执行callback方法</p><h3 id="callback和handleRequest方法"><a href="#callback和handleRequest方法" class="headerlink" title="callback和handleRequest方法"></a>callback和handleRequest方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">callback</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fn = compose(<span class="built_in">this</span>.middleware);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.listenerCount(<span class="string">&#x27;error&#x27;</span>)) <span class="built_in">this</span>.on(<span class="string">&#x27;error&#x27;</span>, <span class="built_in">this</span>.onerror);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleRequest = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> ctx = <span class="built_in">this</span>.createContext(req, res); <span class="comment">// node 原生的 req、res 对象把其中的属性挂载到 ctx 上</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.handleRequest(ctx, fn); <span class="comment">// 调用</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> handleRequest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">handleRequest</span>(<span class="params">ctx, fnMiddleware</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = ctx.res;</span><br><span class="line">    <span class="keyword">const</span> onerror = <span class="function"><span class="params">err</span> =&gt;</span> ctx.onerror(err);</span><br><span class="line">    <span class="comment">// 处理响应</span></span><br><span class="line">    <span class="keyword">const</span> handleResponse = <span class="function">() =&gt;</span> respond(ctx);</span><br><span class="line">    <span class="keyword">return</span> fnMiddleware(ctx).then(handleResponse).catch(onerror);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>compse函数返回一个中间件函数，在handleRequest执行中间件函数，如果全部 resolve 了就可以调用 handleResponse 发送给客户端</p><p>本片博客的重点就是compose是怎么实现koa的洋葱模型的</p><h2 id="koa-compose-js"><a href="#koa-compose-js" class="headerlink" title="koa-compose.js"></a>koa-compose.js</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="compose函数"><a href="#compose函数" class="headerlink" title="compose函数"></a>compose函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span> (<span class="params">middleware</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> <span class="variable">context</span></span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;Promise&#125;</span></span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@api <span class="variable">public</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">context, next</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// last called middleware #</span></span><br><span class="line">        <span class="keyword">let</span> index = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dispatch(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= index)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;next() called multiple times&#x27;</span>))</span><br><span class="line">            index = i</span><br><span class="line">            <span class="keyword">let</span> fn = middleware[i]</span><br><span class="line">            <span class="keyword">if</span> (i === middleware.length) fn = next</span><br><span class="line">            <span class="keyword">if</span> (!fn) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(fn(context, dispatch.bind(<span class="literal">null</span>, i + <span class="number">1</span>)));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>compose</code>函数接收<code>middleware</code>数组，<code>dispatch(0)</code>即开始分发一号中间件。</p></li><li><p><code>dispatch(0)</code>内部，此时 fn 为一号中间件，会走到 try/catch 块，尝试执行<code>Promise.resolve(fn(context, dispatch.bind(null, i + 1)))</code>，即一号中间件此时获得入参<code>context</code>、<code>dispatch(1)</code>。</p></li><li><p>一号中间件开始执行，遇到 next()（即dispatch(1)），控制权移交，执行 dispatch(1)，此时二号中间件获得入参<code>context</code>、<code>dispatch(2)</code>。</p></li><li><p>二号中间件开始执行，执行到<code>await next()</code>时，再重复上述逻辑，dispatch(2)，但是这一次会停在这里：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = middleware[i];</span><br><span class="line"><span class="keyword">if</span> (i === middleware.length) fn = next;</span><br><span class="line"><span class="keyword">if</span> (!fn) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br></pre></td></tr></table></figure><p>  fn = next，这里的 next 由于并没有值，所以会直接 return 一个立即 resolve 的 Promise。也就是说二号中间件内部的 await next()会立刻返回。</p></li><li><p>二号中间件做完自己的事后，相当于一号中间件内部的<code>await next()</code>返回了，因此控制权就归还给一号中间件。</p></li></ul><h2 id="如果中间件中的next-方法报错了怎么办。"><a href="#如果中间件中的next-方法报错了怎么办。" class="headerlink" title="如果中间件中的next()方法报错了怎么办。"></a>如果中间件中的<code>next()</code>方法报错了怎么办。</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ctx.onerror = <span class="function"><span class="keyword">function</span> </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.app.emit(<span class="string">&#x27;error&#x27;</span>, err, <span class="built_in">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">listen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span>  fnMiddleware = compose(<span class="built_in">this</span>.middleware);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.listenerCount(<span class="string">&#x27;error&#x27;</span>)) <span class="built_in">this</span>.on(<span class="string">&#x27;error&#x27;</span>, <span class="built_in">this</span>.onerror);</span><br><span class="line">    <span class="keyword">const</span> onerror = <span class="function"><span class="params">err</span> =&gt;</span> ctx.onerror(err);</span><br><span class="line">    fnMiddleware(ctx).then(handleResponse).catch(onerror);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">onerror</span>(<span class="params">err</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 代码省略</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：中间件链错误会由<code>ctx.onerror</code>捕获，该函数中会调用<code>this.app.emit(&#39;error&#39;, err, this)</code>（因为<code>koa</code>继承自<code>Emitter</code>，所以有<code>emit</code>和<code>on</code>等方法），可以使用<code>app.on(&#39;error&#39;, (err) =&gt; &#123;&#125;)</code>，或者<code>app.onerror = (err) =&gt; &#123;&#125;</code>进行捕获。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://juejin.cn/post/6844904088220467213#heading-16">https://juejin.cn/post/6844904088220467213#heading-16</a><br><a href="https://linbudu.top/posts/2020/02/25/koa%E6%BA%90%E7%A0%81%E7%B2%BE%E8%AF%BB.html#new-%E4%B8%80%E4%B8%AA-koa-%EF%BC%8C%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F">https://linbudu.top/posts/2020/02/25/koa%E6%BA%90%E7%A0%81%E7%B2%BE%E8%AF%BB.html#new-%E4%B8%80%E4%B8%AA-koa-%EF%BC%8C%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Koa洋葱原型源码解读&quot;&gt;&lt;a href=&quot;#Koa洋葱原型源码解读&quot; class=&quot;headerlink&quot; title=&quot;Koa洋葱原型源码解读&quot;&gt;&lt;/a&gt;Koa洋葱原型源码解读&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;版本：2.13.1&lt;/p&gt;
&lt;/block
      
    
    </summary>
    
    
      <category term="后端" scheme="https://liang5757.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="源码解读" scheme="https://liang5757.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="node.js" scheme="https://liang5757.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>尤雨溪frontend Master课程笔记</title>
    <link href="https://liang5757.github.io/2021/02/18/Vue/%E5%B0%A4%E9%9B%A8%E6%BA%AAfrontend%20Master%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <id>https://liang5757.github.io/2021/02/18/Vue/%E5%B0%A4%E9%9B%A8%E6%BA%AAfrontend%20Master%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</id>
    <published>2021-02-17T18:46:31.000Z</published>
    <updated>2021-02-17T18:47:34.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="尤雨溪Frontend-Master课程笔记"><a href="#尤雨溪Frontend-Master课程笔记" class="headerlink" title="尤雨溪Frontend Master课程笔记"></a>尤雨溪Frontend Master课程笔记</h1><h2 id="1-响应式"><a href="#1-响应式" class="headerlink" title="1.响应式"></a>1.响应式</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>实现一个神奇的函数auto，会在<code>state.count</code>改变后，自动运行里面的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">autoRun(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;app&quot;</span>).innerText = state.count;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">state.count++; <span class="comment">// 重新执行autoRun内的函数</span></span><br></pre></td></tr></table></figure><h3 id="第一步-getter和setter"><a href="#第一步-getter和setter" class="headerlink" title="第一步 getter和setter"></a>第一步 getter和setter</h3><p>需要能监听到对象内属性的改变</p><h4 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;</span><br><span class="line">observer(obj);</span><br><span class="line">obj.foo <span class="comment">// 需要打印: &#x27;getting key &quot;foo&quot;: 123&#x27;</span></span><br><span class="line">obj.foo = <span class="number">234</span> <span class="comment">// 需要打印: &#x27;setting key &quot;foo&quot; to 234&#x27;</span></span><br><span class="line">obj.foo <span class="comment">// 需要打印: &#x27;getting key &quot;foo&quot;: 234&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 保存属性初始值</span></span><br><span class="line">    <span class="keyword">let</span> internalValue = obj[key]</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">      get () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`getting key &quot;<span class="subst">$&#123;key&#125;</span>&quot;: <span class="subst">$&#123;internalValue&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">return</span> internalValue</span><br><span class="line">      &#125;,</span><br><span class="line">      set (newValue) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`setting key &quot;<span class="subst">$&#123;key&#125;</span>&quot; to: <span class="subst">$&#123;newValue&#125;</span>`</span>)</span><br><span class="line">        internalValue = newValue</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二步-依赖收集-Dep"><a href="#第二步-依赖收集-Dep" class="headerlink" title="第二步 依赖收集 Dep"></a>第二步 依赖收集 Dep</h3><h4 id="实现效果-1"><a href="#实现效果-1" class="headerlink" title="实现效果"></a>实现效果</h4><p>即一个发布订阅模式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line"></span><br><span class="line">autoRun(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  dep.depend()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;updated&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 打印: &quot;updated&quot;</span></span><br><span class="line"></span><br><span class="line">dep.notify()</span><br><span class="line"><span class="comment">// 打印: &quot;updated&quot;</span></span><br></pre></td></tr></table></figure><h4 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs = []</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">depend</span>(<span class="params"></span>)</span> &#123; <span class="comment">// 订阅函数</span></span><br><span class="line">    <span class="keyword">if</span> (activeUpdate) &#123;</span><br><span class="line">      <span class="built_in">this</span>.subs.push(activeUpdate); <span class="comment">// 把全局变量activeUpdate存的函数放入订阅者列表</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">notify</span>(<span class="params"></span>)</span> &#123; <span class="comment">// 发布函数</span></span><br><span class="line">    <span class="built_in">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> sub());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> activeUpdate = <span class="literal">null</span> <span class="comment">// 放置依赖函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">autoRun</span> (<span class="params">update</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> wrappedUpdate = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    activeUpdate = wrappedUpdate <span class="comment">// 把wrappedUpdate存起来</span></span><br><span class="line">    update() <span class="comment">// 在update内部调用dep.depend()收集依赖</span></span><br><span class="line">    activeUpdate = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  wrappedUpdate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三步-整合一、二"><a href="#第三步-整合一、二" class="headerlink" title="第三步 整合一、二"></a>第三步 整合一、二</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs = []</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">depend</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (activeUpdate) &#123;</span><br><span class="line">      <span class="built_in">this</span>.subs.push(activeUpdate);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">notify</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> sub());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">obj</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.dep = <span class="keyword">new</span> Dep();</span><br><span class="line">    <span class="built_in">this</span>.walk(obj);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">walk</span>(<span class="params">obj</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.defineReactive(obj, key);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">defineReactive</span>(<span class="params">obj, key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> internalValue = obj[key];</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">      enumerable: <span class="literal">false</span>,</span><br><span class="line">      configurable: <span class="literal">false</span>,</span><br><span class="line">      <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        that.dep.depend();</span><br><span class="line">        <span class="keyword">return</span> internalValue;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">set</span>(<span class="params">newVal</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> isChanged = internalValue !== newVal;</span><br><span class="line">        <span class="keyword">if</span> (isChanged) &#123;</span><br><span class="line">          internalValue = newVal;</span><br><span class="line">          that.dep.notify();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> activeUpdate = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">autoRun</span> (<span class="params">update</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> wrappedUpdate = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    activeUpdate = wrappedUpdate <span class="comment">// 把wrappedUpdate存起来</span></span><br><span class="line">    update() <span class="comment">// 在update内部调用dep.depend()收集依赖</span></span><br><span class="line">    activeUpdate = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  wrappedUpdate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-虚拟DOM"><a href="#2-虚拟DOM" class="headerlink" title="2. 虚拟DOM"></a>2. 虚拟DOM</h2><h3 id="2-1虚拟DOM和真实的DOM的差异"><a href="#2-1虚拟DOM和真实的DOM的差异" class="headerlink" title="2.1虚拟DOM和真实的DOM的差异"></a>2.1虚拟DOM和真实的DOM的差异</h3><p>1.资源消耗问题</p><p>使用javascript操作真实DOM是非常消耗资源的，虽然很多浏览器做了优化但是效果不大。你看到虚拟DOM是一个纯javascript对象。而DOM节点有70＋个属性，继承层级有6，7层（文本节点6层，元素节点7层）,访问一个属性，可能会追溯几重原型链。</p><p>2.执行效率问题</p><p>如果你要修改一个真实DOM，一般调用<code>innerHTML</code>方法，那浏览器会把旧的节点移除再添加新的节点，但是在虚拟DOM中，只需要修改一个对象的属性，再把虚拟DOM渲染到真实DOM上。很多人会误解虚拟DOM比真实DOM速度快，其实虚拟DOM只是把DOM变更的逻辑提取出来，使用javascript计算差异，减少了操作真实DOM的次数，只在最后一次才操作真实DOM，所以如果你的应用有复杂的DOM变更操作，虚拟DOM会比较快。</p><p>3.虚拟DOM还有其他好处</p><p>其实虚拟DOM还可以应用在其他地方，因为他们只是抽象节点，可以把它编译成其他平台，例如android、ios。市面上利用形同架构模式的应用有React Native，Weeks，Native script，就是利用虚拟DOM的特点实现的。</p><h3 id="2-2-虚拟DOM在线查看"><a href="#2-2-虚拟DOM在线查看" class="headerlink" title="2.2 虚拟DOM在线查看"></a>2.2 虚拟DOM在线查看</h3><p>使用Vue Template Explorer可以查看Vue是如何转换虚拟DOM的。</p><p><a href="https://template-explorer.vuejs.org/">访问地址</a></p><h2 id="3-template和jsx对比"><a href="#3-template和jsx对比" class="headerlink" title="3.template和jsx对比"></a>3.template和jsx对比</h2><p><strong>模版的优势</strong>：模版是一种更静态更具有约束的表现形态，它可以避免发明新语法，任何可以解析HTML的引擎都可以使用它，迁移成本更低；另外最重要的是<strong>静态模版可以在编译进行比较多的优化</strong>，而动态语言就没法实现了。</p><p><strong>jsx的优势</strong>：更灵活，任何的js代码都可以放在jsx中执行实现你想要的效果，但是也<strong>由于他的灵活性导致在编译阶段优化比较困难，只能通过开发者自己优化</strong>。</p><h2 id="4-函数组件"><a href="#4-函数组件" class="headerlink" title="4. 函数组件"></a>4. 函数组件</h2><p>函数组件就是不包含state和props的组件，就像它的名字一样，你可以理解为他就是一个函数，在Vue中声明一个函数组件代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">functional: <span class="literal">true</span>,</span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(<span class="string">&#x27;div&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>组件不支持实例化。</li><li>优化更优，因为在Vue中它的渲染函数比父级组件更早被调用，但是他并不会占用很多资源，因为它没有保存数据和属性，所以它常用于优化一个有很多节点的组件。</li><li>容易扩展，如果你的组件只是用来接收 prop然后显示数据，或者一个没有状态的按钮，建议使用函数组件。</li><li>函数组件没有this，获取prop可以通过render函数的第二参数得到<code>render(h, context)</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;example&#x27;</span>, &#123;</span><br><span class="line">    functional: <span class="literal">true</span>, <span class="comment">// 声明是函数组件</span></span><br><span class="line">    <span class="comment">// 因为函数组件没有this,可以通过render第二参数获取相关信息</span></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params">h, &#123; props: &#123; tags &#125; &#125;</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// context.slots() 通过slots方法获取子节点</span></span><br><span class="line">        <span class="comment">// context.children 获取子组件</span></span><br><span class="line">        <span class="comment">// context.parent 父组件，因为函数组件实挂载到根节点上，也就是&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span></span><br><span class="line">        <span class="comment">// context.props 组件属性，这里得到tags属性</span></span><br><span class="line">        <span class="comment">// return h(&#x27;div&#x27;, this.tags.map((tag, i) =&gt; h(tag, i)))</span></span><br><span class="line">        <span class="comment">// 通过函数组件实现标签动态渲染</span></span><br><span class="line">        <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, tags.map(<span class="function">(<span class="params">tag, i</span>) =&gt;</span> h(tag, i)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="5-HOC-高阶组件"><a href="#5-HOC-高阶组件" class="headerlink" title="5.HOC 高阶组件"></a>5.HOC 高阶组件</h2><blockquote><p>高阶组件是一个函数，接收一个组件，然后返回一个新的组件，类似装饰者模式</p></blockquote><p>这里不展开说了，大概列一下写法，下面模拟了一个图片骨架</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mock API</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchURL</span> (<span class="params">username, cb</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// hard coded, bonus: exercise: make it fetch from gravatar!</span></span><br><span class="line">    cb(<span class="string">&#x27;https://avatars3.githubusercontent.com/u/6128107?v=4&amp;s=200&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">500</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Avatar = &#123;</span><br><span class="line">  props: [<span class="string">&#x27;src&#x27;</span>],</span><br><span class="line">  template: <span class="string">`&lt;img :src=&quot;src&quot;&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withAvatarURL</span> (<span class="params">InnerComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      attrs: <span class="built_in">this</span>.$attrs, <span class="comment">// 2.4 only</span></span><br><span class="line">      username: <span class="built_in">String</span></span><br><span class="line">    &#125;,</span><br><span class="line">    data () &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        url: <span class="string">&#x27;http://via.placeholder.com/200x200&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created () &#123;</span><br><span class="line">      fetchURL(<span class="built_in">this</span>.username, <span class="function">(<span class="params">url</span>) =&gt;</span> &#123; <span class="built_in">this</span>.url = url &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    render (h) &#123;</span><br><span class="line">      <span class="keyword">return</span> h(InnerComponent, &#123; <span class="attr">props</span>: &#123; <span class="attr">src</span>: <span class="built_in">this</span>.url &#125; &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SmartAvatar = withAvatarURL(Avatar)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  components: &#123; SmartAvatar &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li><strong>重用性</strong>：因为minxin对原组件具有侵入性，这会导致原来组件的可重用性降低，而高阶组件不会，高阶组件对原组件只是一个调用关系，并没有修改原来组件任何内容。</li><li><strong>可测试性</strong>：因为高阶组件只是一个嵌套关系，在组件测试的时候，可以单独的测试原始组件和高阶组件。</li><li><strong>层级问题</strong>：高阶组件也有他的弊端，如果你高阶组件嵌套层级太深，会导致出错的时候调试困难的问题，所以到底使用高阶组件和minxin需要看实际场景。</li></ol><h2 id="6-路由"><a href="#6-路由" class="headerlink" title="6. 路由"></a>6. 路由</h2><p>实现根据路由匹配显示组件，并路由匹配参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件</span></span><br><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">    props: [<span class="string">&#x27;id&#x27;</span>],</span><br><span class="line">    template: <span class="string">`&lt;div&gt;foo with id: &#123;&#123; id &#125;&#125;&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Bar = &#123; <span class="attr">template</span>: <span class="string">`&lt;div&gt;bar&lt;/div&gt;`</span> &#125;</span><br><span class="line"><span class="keyword">const</span> NotFound = &#123; <span class="attr">template</span>: <span class="string">`&lt;div&gt;not found!&lt;/div&gt;`</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由表</span></span><br><span class="line"><span class="keyword">const</span> routeTable = &#123;</span><br><span class="line">    <span class="string">&#x27;/foo/:id&#x27;</span>: Foo,</span><br><span class="line">    <span class="string">&#x27;/bar&#x27;</span>: Bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将路由表的键通过 path-to-regexp库 进行正则封装</span></span><br><span class="line"><span class="comment">// 下面这个数组储存：组件、正则对象、匹配的name</span></span><br><span class="line"><span class="keyword">const</span> compiledRoutes = []</span><br><span class="line"><span class="built_in">Object</span>.keys(routeTable).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> dynamicSegments = []</span><br><span class="line">    <span class="keyword">const</span> regex = pathToRegexp(key, dynamicSegments)</span><br><span class="line">    <span class="keyword">const</span> component = routeTable[key]</span><br><span class="line">    compiledRoutes.push(&#123;</span><br><span class="line">        component,</span><br><span class="line">        regex,</span><br><span class="line">        dynamicSegments</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听hashchange，将改变的路由赋值给url</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;hashchange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    app.url = <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        url: <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    render (h) &#123;</span><br><span class="line">        <span class="keyword">const</span> path = <span class="string">&#x27;/&#x27;</span> + <span class="built_in">this</span>.url</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> componentToRender <span class="comment">// 要渲染的组件</span></span><br><span class="line">        <span class="keyword">let</span> props = &#123;&#125; <span class="comment">// 路由匹配到的值</span></span><br><span class="line"></span><br><span class="line">        compiledRoutes.some(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> match = route.regex.exec(path) <span class="comment">// 执行匹配</span></span><br><span class="line">            componentToRender = NotFound</span><br><span class="line">            <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                componentToRender = route.component</span><br><span class="line">                <span class="comment">// 设置参数</span></span><br><span class="line">                route.dynamicSegments.forEach(<span class="function">(<span class="params">segment, index</span>) =&gt;</span> &#123;</span><br><span class="line">                    props[segment.name] = match[index + <span class="number">1</span>]</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, [</span><br><span class="line">            h(componentToRender, &#123; props &#125;),</span><br><span class="line">            h(<span class="string">&#x27;a&#x27;</span>, &#123; <span class="attr">attrs</span>: &#123; <span class="attr">href</span>: <span class="string">&#x27;#foo/123&#x27;</span> &#125;&#125;, <span class="string">&#x27;foo 123&#x27;</span>),</span><br><span class="line">            <span class="string">&#x27; | &#x27;</span>,</span><br><span class="line">            h(<span class="string">&#x27;a&#x27;</span>, &#123; <span class="attr">attrs</span>: &#123; <span class="attr">href</span>: <span class="string">&#x27;#foo/234&#x27;</span> &#125;&#125;, <span class="string">&#x27;foo 234&#x27;</span>),</span><br><span class="line">            <span class="string">&#x27; | &#x27;</span>,</span><br><span class="line">            h(<span class="string">&#x27;a&#x27;</span>, &#123; <span class="attr">attrs</span>: &#123; <span class="attr">href</span>: <span class="string">&#x27;#bar&#x27;</span> &#125;&#125;, <span class="string">&#x27;bar&#x27;</span>),</span><br><span class="line">            <span class="string">&#x27; | &#x27;</span>,</span><br><span class="line">            h(<span class="string">&#x27;a&#x27;</span>, &#123; <span class="attr">attrs</span>: &#123; <span class="attr">href</span>: <span class="string">&#x27;#garbage&#x27;</span> &#125;&#125;, <span class="string">&#x27;garbage&#x27;</span>)</span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;尤雨溪Frontend-Master课程笔记&quot;&gt;&lt;a href=&quot;#尤雨溪Frontend-Master课程笔记&quot; class=&quot;headerlink&quot; title=&quot;尤雨溪Frontend Master课程笔记&quot;&gt;&lt;/a&gt;尤雨溪Frontend Master课程
      
    
    </summary>
    
    
      <category term="前端" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="vue" scheme="https://liang5757.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>MPA首屏加载速率优化实战</title>
    <link href="https://liang5757.github.io/2021/02/14/Webpack/MPA%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E7%8E%87%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/"/>
    <id>https://liang5757.github.io/2021/02/14/Webpack/MPA%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E7%8E%87%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/</id>
    <published>2021-02-14T07:45:27.000Z</published>
    <updated>2021-02-14T07:48:02.536Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MPA首屏加载速率优化实战"><a href="#MPA首屏加载速率优化实战" class="headerlink" title="MPA首屏加载速率优化实战"></a>MPA首屏加载速率优化实战</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    学校实验室的项目，因为学校只开放给我们一个端口，所以只能把后台管理和学生端合并成多页应用，我是做后台管理的，老师要求某个功能要加上代码高亮，在全局引入highlight.js后发现首屏加载速率不行了，记录一下发现更多问题并优化的过程。</p><h2 id="有用的优化"><a href="#有用的优化" class="headerlink" title="有用的优化"></a>有用的优化</h2><h3 id="1-HighLight-js被放在首屏加载了"><a href="#1-HighLight-js被放在首屏加载了" class="headerlink" title="1. HighLight.js被放在首屏加载了"></a>1. HighLight.js被放在首屏加载了</h3><p>首先用<code>webpack-bundle-analyer</code>进行构建分析</p><p><img src= "/img/loading.gif" data-lazy-src="/2021/02/14/Webpack/MPA%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E7%8E%87%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20210126203158808-1613288799701.png" alt="image-20210126203158808"></p><p>发现了两个巨大的包<code>chunk-vendors.44cd6d2c.js</code>有2.4MB，<code>chunk-94715762.bb0c42f0.js</code>有1.4MB，不幸的是c端需要在首屏同时下载两个大包（此处有误，后面讲解，正确的是左边这个包加入口）才开始渲染，而c端并没有用到<code>highlight.js</code>但是他也得等待下载。</p><p>然后把<code>highlight.js</code>放到封装的组件里引用，然后打包分析</p><p><img src= "/img/loading.gif" data-lazy-src="/2021/02/14/Webpack/MPA%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E7%8E%87%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20210126204428302.png" alt="image-20210126204428302"></p><p>发现就分离了，<strong>2.4MB的包变成了1.5MB</strong></p><h3 id="2-两个应用使用的element组件没有分离"><a href="#2-两个应用使用的element组件没有分离" class="headerlink" title="2. 两个应用使用的element组件没有分离"></a>2. 两个应用使用的element组件没有分离</h3><p>但是又发现了新的问题——<code>element-ui</code>两个应用使用的组件被打包到了一起，即时c端没有使用到诸如<code>el-upload</code>、<code>el-pagination</code>等组件，但是也要首屏也要下载，想了想<code>highlight.js</code>被放到b端入口文件引入就被打进这个包里。</p><p>是不是<strong>两个入口使用了同一个element按需引入文件的原因</strong>，然后我给<strong>两个应用各开了自己的按需引入文件</strong>。<strong>打包分析没啥变化</strong>。</p><p>问了大哥，大哥甩手就是一个连接<a href="https://www.cnblogs.com/HYZhou2018/p/10419703.html">https://www.cnblogs.com/HYZhou2018/p/10419703.html</a></p><p>大概就是<code>vue-cli3</code>的脚手架配置自动分包的时候是针对单页应用的，下面是<code>vue-cli3</code>的配置项</p><p><img src= "/img/loading.gif" data-lazy-src="/2021/02/14/Webpack/MPA%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E7%8E%87%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20210126205853873.png" alt="image-20210126205853873"></p><p><code>splitChunks</code>默认<code>minChunks</code>是1，但是我们是多页应用啊，所以两个应用使用的第三方库全被抽离到一个<code>chunk-vendor.js</code>了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">config.optimization.splitChunks(&#123;</span><br><span class="line">    cacheGroups: &#123;</span><br><span class="line">        vendors: &#123;</span><br><span class="line">            name: <span class="string">&#x27;chunk-vendors&#x27;</span>,</span><br><span class="line">            minChunks: <span class="number">2</span>, <span class="comment">// 设置为2，两个应用同时使用才抽离</span></span><br><span class="line">            test: <span class="regexp">/node_modules/</span>,</span><br><span class="line">            priority: -<span class="number">10</span>,</span><br><span class="line">            chunks: <span class="string">&#x27;initial&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        common: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>再次打包分析</p><p><img src= "/img/loading.gif" data-lazy-src="/2021/02/14/Webpack/MPA%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E7%8E%87%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20210126210625547.png" alt="image-20210126210625547"></p><p>不仅分离了一些组件，还把一些使用到的第三方库给分离了，这个2.4MB的打包到此为止就变成了<strong>1.2MB</strong>的包。</p><h2 id="走过的坑"><a href="#走过的坑" class="headerlink" title="走过的坑"></a>走过的坑</h2><h3 id="1-怎么coding包还是在首屏下载了"><a href="#1-怎么coding包还是在首屏下载了" class="headerlink" title="1.怎么coding包还是在首屏下载了"></a>1.怎么coding包还是在首屏下载了</h3><p>已经使用了路由懒加载，为什么coding包还是在首屏下载了，我曾一度以为是没有<a href="https://babeljs.io/docs/plugins/syntax-dynamic-import/"><code>syntax-dynamic-import</code></a>这个插件的原因，还装过了试了下，但是并没有什么用，而且webpack已经使用动态import来做到懒加载了。</p><p>查阅<a href="https://blog.csdn.net/sinat_35538827/article/details/87969834">文章</a>发现</p><p>原来 vue-cli3 默认会把所有通过<code>import()</code>按需加载的javascript文件加上 prefetch 。</p><p><strong>prefetch是什么？</strong>在打包后的文件中，查看index.html我们会发现类似这个 <link href="/js/chunk-118075e7.5725ab1a.js" rel="prefetch">。<link rel="prefetch">会在页面加载完成后，利用空闲时间提前加载获取用户未来可能会访问的内容。</p><p><strong>prefetch链接会消耗宽带，如果是在移动端，而且存在大量的chunk，那么可以关掉 prefetch 链接，手动选择要提前获取的代码区块。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//手动选定要提前获取的代码</span></span><br><span class="line"><span class="keyword">import</span>(webpackPrefetch: <span class="literal">true</span>, <span class="string">&#x27;./someAsyncComponent.vue&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>关闭prefetch:</strong> (官网示例)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 移除 prefetch 插件</span></span><br><span class="line">    config.plugins.delete(<span class="string">&#x27;prefetch&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 或者</span></span><br><span class="line">    <span class="comment">// 修改它的选项：</span></span><br><span class="line">    config.plugin(<span class="string">&#x27;prefetch&#x27;</span>).tap(<span class="function"><span class="params">options</span> =&gt;</span> &#123;</span><br><span class="line">      options[<span class="number">0</span>].fileBlacklist = options[<span class="number">0</span>].fileBlacklist || []</span><br><span class="line">      options[<span class="number">0</span>].fileBlacklist.push(<span class="regexp">/myasyncRoute(.)+?\.js$/</span>)</span><br><span class="line">      <span class="keyword">return</span> options</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-第三方库怎么这么多重复的bn-js"><a href="#2-第三方库怎么这么多重复的bn-js" class="headerlink" title="2. 第三方库怎么这么多重复的bn.js"></a>2. 第三方库怎么这么多重复的bn.js</h3><p><img src= "/img/loading.gif" data-lazy-src="/2021/02/14/Webpack/MPA%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E7%8E%87%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20210126212734717.png" alt="image-20210126212734717"></p><p>可以看到有8个重复的<code>bn.js</code>，一个40KB，gzip后10KB，离谱。</p><p>但是大小是不一样的，可能<strong>用的版本不同</strong>，目前没有好的方法抽离。。</p><p>其实可以用cdn来搞，但是第三方的cdn不稳定，就没搞。</p><h3 id="3-打包后mini-css-extract-plugin警告Conflicting-order"><a href="#3-打包后mini-css-extract-plugin警告Conflicting-order" class="headerlink" title="3. 打包后mini-css-extract-plugin警告Conflicting order"></a>3. 打包后mini-css-extract-plugin警告Conflicting order</h3><p>对应的issus：<a href="https://github.com/webpack-contrib/mini-css-extract-plugin/issues/250">https://github.com/webpack-contrib/mini-css-extract-plugin/issues/250</a></p><p>是由于组件使用顺序不一致导致的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MPA首屏加载速率优化实战&quot;&gt;&lt;a href=&quot;#MPA首屏加载速率优化实战&quot; class=&quot;headerlink&quot; title=&quot;MPA首屏加载速率优化实战&quot;&gt;&lt;/a&gt;MPA首屏加载速率优化实战&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; cla
      
    
    </summary>
    
    
      <category term="前端" scheme="https://liang5757.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Webpack" scheme="https://liang5757.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>适配器模式</title>
    <link href="https://liang5757.github.io/2021/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://liang5757.github.io/2021/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-02-11T07:38:26.000Z</published>
    <updated>2021-05-05T17:07:27.751Z</updated>
    
    <content type="html"><![CDATA[<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><blockquote><p>适配器模式的作用是解决两个软件实体间的接口不兼容的问题。使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体可以一起工作。 适配器的别名是包装器(wrapper)，这是一个相对简单的模式</p></blockquote><p>在程序开发中有许多这样的场景：当我们试图调用模块或者对象的某个接口时，却发现这个接口的格式并不符合目前的需求。 这时候有两种解决办法，第一种是修改原来的接口实现，但如果原来的模块很复杂，或者我们拿到的模块是一段别人编写的经过压缩的代码，修改原接口就显得不太现实了。第二种办法是创建一个适配器，将原接口转换为客户希望的另一个接口，客户只需要和适配器打交道。</p><h2 id="故事背景"><a href="#故事背景" class="headerlink" title="故事背景"></a>故事背景</h2><p>现在使用 谷歌地图 和 百度地图 在页面展现地图</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> googleMap = &#123;</span><br><span class="line">  show: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;开始渲染谷歌地图&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> baiduMap = &#123;</span><br><span class="line">  show: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;开始渲染百度地图&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> renderMap = <span class="function"><span class="keyword">function</span> (<span class="params">map</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (map.show <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">    map.show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">renderMap(googleMap); <span class="comment">// 输出:开始渲染谷歌地图</span></span><br><span class="line">renderMap(baiduMap); <span class="comment">// 输出:开始渲染百度地图</span></span><br></pre></td></tr></table></figure><p>上面的代码能够运行成功是因为两个第三方均为show方法，如果两个接口提供调用的方式不一样，那么就不能运行了</p><h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> googleMap = &#123;</span><br><span class="line">  show: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;开始渲染谷歌地图&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> baiduMap = &#123;</span><br><span class="line">  display: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;开始渲染百度地图&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> baiduMapAdapter = &#123;</span><br><span class="line">  show: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> baiduMap.display();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> renderMap = <span class="function"><span class="keyword">function</span> (<span class="params">map</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (map.show <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">    map.show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">renderMap(googleMap); <span class="comment">// 输出:开始渲染谷歌地图</span></span><br><span class="line">renderMap(baiduMapAdapter); <span class="comment">// 输出:开始渲染百度地图</span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>适配器模式主要用来解决两个已有接口之间不匹配的问题，它不考虑这些接口是怎样实现的，也不考虑它们将来可能会如何演化。适配器模式不需要改变已有的接口，就能够使它们协同作用。</li><li>装饰者模式和代理模式也不会改变原有对象的接口，但装饰者模式的作用是为了给对象增加功能。装饰者模式常常形成一条长的装饰链，而适配器模式通常只包装一次。代理模式是为了控制对对象的访问，通常也只包装一次。</li><li>外观模式的作用倒是和适配器比较相似，有人把外观模式看成一组对象的适配器，但外观模式最显著的特点是定义了一个新的接口。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《javascript设计模式与开发实践》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;适配器模式&quot;&gt;&lt;a href=&quot;#适配器模式&quot; class=&quot;headerlink&quot; title=&quot;适配器模式&quot;&gt;&lt;/a&gt;适配器模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;适配器模式的作用是解决两个软件实体间的接口不兼容的问题。使用适配器模式之后，原本由于接口不
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://liang5757.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://liang5757.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>状态模式</title>
    <link href="https://liang5757.github.io/2021/02/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <id>https://liang5757.github.io/2021/02/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-02-10T07:38:03.000Z</published>
    <updated>2021-05-05T17:07:38.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><blockquote><p>允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类</p><p>状态模式的关键是区分事物内部的状态，事物内部状态的改变往往会带来事物的行为改变</p></blockquote><h2 id="故事背景"><a href="#故事背景" class="headerlink" title="故事背景"></a>故事背景</h2><p>我们来想象这样一个场景：有一个电灯，电灯上面只有一个开关。当电灯开着的时候，此时 按下开关，电灯会切换到关闭状态;再按一次开关，电灯又将被打开。同一个开关按钮，在不同 的状态下，表现出来的行为是不一样的 </p><h2 id="未使用状态模式"><a href="#未使用状态模式" class="headerlink" title="未使用状态模式"></a>未使用状态模式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Light = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.state = <span class="string">&quot;off&quot;</span>; <span class="comment">// 给电灯设置初始状态 off</span></span><br><span class="line">  <span class="built_in">this</span>.button = <span class="literal">null</span>;<span class="comment">// 电灯开关按钮</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Light.prototype.init = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> button = <span class="built_in">document</span>.createElement(<span class="string">&quot;button&quot;</span>),</span><br><span class="line">    self = <span class="built_in">this</span>;</span><br><span class="line">  button.innerHTML = <span class="string">&quot;开关&quot;</span>;</span><br><span class="line">  <span class="built_in">this</span>.button = <span class="built_in">document</span>.body.appendChild(button);</span><br><span class="line">  <span class="built_in">this</span>.button.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    self.buttonWasPressed();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Light.prototype.buttonWasPressed = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.state === <span class="string">&quot;off&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;开灯&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.state = <span class="string">&quot;on&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.state === <span class="string">&quot;on&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;关灯&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.state = <span class="string">&quot;off&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> light = <span class="keyword">new</span> Light();</span><br><span class="line">light.init();</span><br></pre></td></tr></table></figure><p>但是如果需要在新增状态，那么就得直接在buttonWasPressed里修改，不符合开闭原则。</p><h2 id="状态模式重构"><a href="#状态模式重构" class="headerlink" title="状态模式重构"></a>状态模式重构</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> OffLightState = <span class="function"><span class="keyword">function</span> (<span class="params">light</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.light = light;</span><br><span class="line">&#125;;</span><br><span class="line">OffLightState.prototype.buttonWasPressed = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;弱光&quot;</span>); <span class="comment">// offLightState 对应的行为</span></span><br><span class="line">  <span class="built_in">this</span>.light.setState(<span class="built_in">this</span>.light.weakLightState);<span class="comment">// 切换状态到 weakLightState</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> WeakLightState = <span class="function"><span class="keyword">function</span> (<span class="params">light</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.light = light;</span><br><span class="line">&#125;;</span><br><span class="line">WeakLightState.prototype.buttonWasPressed = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;强光&quot;</span>); <span class="comment">// weakLightState 对应的行为</span></span><br><span class="line">  <span class="built_in">this</span>.light.setState(<span class="built_in">this</span>.light.strongLightState); <span class="comment">//切换状态到 strongLightState</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> StrongLightState = <span class="function"><span class="keyword">function</span> (<span class="params">light</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.light = light;</span><br><span class="line">&#125;;</span><br><span class="line">StrongLightState.prototype.buttonWasPressed = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;关灯&quot;</span>); <span class="comment">// strongLightState 对应的行为</span></span><br><span class="line">  <span class="built_in">this</span>.light.setState(<span class="built_in">this</span>.light.offLightState); <span class="comment">// 切换状态到 offLightState</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改写 Light 类，使用状态对象记录当前的状态</span></span><br><span class="line"><span class="keyword">let</span> Light = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.offLightState = <span class="keyword">new</span> OffLightState(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">this</span>.weakLightState = <span class="keyword">new</span> WeakLightState(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">this</span>.strongLightState = <span class="keyword">new</span> StrongLightState(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">this</span>.button = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供一个 方法来切换 light 对象的状态</span></span><br><span class="line">Light.prototype.init = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> button = <span class="built_in">document</span>.createElement(<span class="string">&quot;button&quot;</span>),</span><br><span class="line">    self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="built_in">this</span>.button = <span class="built_in">document</span>.body.appendChild(button);</span><br><span class="line">  <span class="built_in">this</span>.button.innerHTML = <span class="string">&quot;开关&quot;</span>;</span><br><span class="line">  <span class="built_in">this</span>.currState = <span class="built_in">this</span>.offLightState;</span><br><span class="line">  <span class="built_in">this</span>.button.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    self.currState.buttonWasPressed();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">Light.prototype.setState = <span class="function"><span class="keyword">function</span> (<span class="params">newState</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.currState = newState;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> light = <span class="keyword">new</span> Light();</span><br><span class="line">light.init();</span><br></pre></td></tr></table></figure><p>它可以使每一种状态和它对应的行为之间的关系局部化，这些行为被分散和封装在各自对应的状态类之中，便于阅读和管理代码。</p><p>状态之间的切换都被分布在状态类内部，这使得我们无需编写过多的 if、else 条件 分支语言来控制状态之间的转换</p><p>用对象代替字符串来记录当前状态，使得状态的切换更加一目了然。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《javascript设计模式与开发实践》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;状态模式&quot;&gt;&lt;a href=&quot;#状态模式&quot; class=&quot;headerlink&quot; title=&quot;状态模式&quot;&gt;&lt;/a&gt;状态模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类&lt;/p&gt;
&lt;p&gt;状态模式的关
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://liang5757.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://liang5757.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>装饰者模式</title>
    <link href="https://liang5757.github.io/2021/02/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://liang5757.github.io/2021/02/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-02-09T07:37:36.000Z</published>
    <updated>2021-05-05T17:07:36.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><blockquote><p>在传统的面向对象语言中，给对象添加功能常常使用继承的方式，但是继承的方式并不灵活， 还会带来许多问题：一方面会导致超类和子类之间存在强耦合性，当超类改变时，子类也会随之改变；另一方面，继承这种功能复用方式通常被称为“白箱复用”，“白箱”是相对可见性而言的， 在继承方式中，超类的内部细节是对子类可见的，继承常常被认为破坏了封装性。装饰者模式能够在不改变对象自身的基础上，在程序运行期间给对象动态地添加职责。跟继承相比，装饰者是一种更轻便灵活的做法，这是一种“即用即付”的方式</p></blockquote><h2 id="故事背景"><a href="#故事背景" class="headerlink" title="故事背景"></a>故事背景</h2><p>假设我们在编写一个飞机大战的游戏，随着经验值的增加，我们操作的飞机对象可以升级成更厉害的飞机，一开始这些飞机只能发射普通的子弹，升到第二级时可以发射导弹，升到第三级时可以发射原子弹。</p><h2 id="传统面向对象实现"><a href="#传统面向对象实现" class="headerlink" title="传统面向对象实现"></a>传统面向对象实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Plane = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Plane.prototype.fire = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;发射普通子弹&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导弹类</span></span><br><span class="line"><span class="keyword">let</span> MissileDecorator = <span class="function"><span class="keyword">function</span> (<span class="params">plane</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.plane = plane;</span><br><span class="line">&#125;;</span><br><span class="line">MissileDecorator.prototype.fire = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.plane.fire();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;发射导弹&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子弹类</span></span><br><span class="line"><span class="keyword">let</span> AtomDecorator = <span class="function"><span class="keyword">function</span> (<span class="params">plane</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.plane = plane;</span><br><span class="line">&#125;;</span><br><span class="line">AtomDecorator.prototype.fire = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.plane.fire();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;发射原子弹&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> plane = <span class="keyword">new</span> Plane();</span><br><span class="line">plane = <span class="keyword">new</span> MissileDecorator(plane);</span><br><span class="line">plane = <span class="keyword">new</span> AtomDecorator(plane);</span><br><span class="line">plane.fire();</span><br></pre></td></tr></table></figure><p>装饰者对象和它所装饰的对象拥有一致的接口，通过传入被装饰对象，调用其对应方法，并添加职责形成聚合对象。</p><h2 id="动态语言实现"><a href="#动态语言实现" class="headerlink" title="动态语言实现"></a>动态语言实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> plane = &#123;</span><br><span class="line">  fire: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;发射普通子弹&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> missileDecorator = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;发射导弹&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> atomDecorator = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;发射原子弹&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fire1 = plane.fire;</span><br><span class="line">plane.fire = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  fire1();</span><br><span class="line">  missileDecorator();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fire2 = plane.fire;</span><br><span class="line">plane.fire = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  fire2();</span><br><span class="line">  atomDecorator();</span><br><span class="line">&#125;;</span><br><span class="line">plane.fire();</span><br></pre></td></tr></table></figure><p>因为js可以直接修改对象或者对象的某个方法，那么可以通过一个变量<code>a</code>暂存被装饰函数，然后替换旧方法，在新方法内通过<code>a</code>调用旧方法。</p><p>但是<strong>直接替换有this指向问题</strong>。</p><h2 id="AOP实现"><a href="#AOP实现" class="headerlink" title="AOP实现"></a>AOP实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span> (<span class="params">beforefn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _self = <span class="built_in">this</span>; <span class="comment">// 保存原函数的引用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 返回包含了原函数和新函数的&quot;代理&quot;函数</span></span><br><span class="line">    beforefn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 执行新函数，且保证 this 不被劫持，新函数接受的参数 </span></span><br><span class="line">                                     <span class="comment">// 也会被原封不动地传入原函数，新函数在原函数之前执行</span></span><br><span class="line">    <span class="keyword">return</span> _self.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 执行原函数并返回原函数的执行结果，  // 并且保证 this 不被劫持</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span> (<span class="params">afterfn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ret = _self.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    afterfn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>通过AOP实际上放回的是新函数，在原函数上保存的属性则会丢失</li><li>叠加了作用域，如果装饰的链条过长，性能上会受到影响</li></ul><h2 id="与代理模式的区别"><a href="#与代理模式的区别" class="headerlink" title="与代理模式的区别"></a>与代理模式的区别</h2><p>代理模式的目的：当直接访问本体不方便或者不符合需要时，为这个本体提供一个替代者。本体定义了关键功能，而代理提供或拒绝对它的访问，或者在访问本体之前做一些额外的事情。</p><p>装饰者模式的作用：为对象动态的加入行为。</p><p>换句话说，代理模式的关系一开始就可以被确定，而装饰者模式用于一开始不能确定对象的全部功能时</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《javascript设计模式与开发实践》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;装饰者模式&quot;&gt;&lt;a href=&quot;#装饰者模式&quot; class=&quot;headerlink&quot; title=&quot;装饰者模式&quot;&gt;&lt;/a&gt;装饰者模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;在传统的面向对象语言中，给对象添加功能常常使用继承的方式，但是继承的方式并不灵活， 还会带
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://liang5757.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://liang5757.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>中介者模式</title>
    <link href="https://liang5757.github.io/2021/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://liang5757.github.io/2021/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-02-08T07:37:14.000Z</published>
    <updated>2021-05-05T17:07:34.055Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><blockquote><p>中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。中介者模式使网状的多对多关系变成了相对简单的一对多关系</p></blockquote><h2 id="故事背景"><a href="#故事背景" class="headerlink" title="故事背景"></a>故事背景</h2><p>假如在玩泡泡堂的游戏，使用泡泡击败对方所有玩家才能获得胜利。现在将队伍分成两个组进行游戏</p><h2 id="代码实现-未使用中介者模式"><a href="#代码实现-未使用中介者模式" class="headerlink" title="代码实现(未使用中介者模式)"></a>代码实现(未使用中介者模式)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 玩家</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Player</span>(<span class="params">name, teamColor</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.partners = []; <span class="comment">// 队友列表</span></span><br><span class="line">  <span class="built_in">this</span>.enemies = []; <span class="comment">// 敌人列表</span></span><br><span class="line">  <span class="built_in">this</span>.state = <span class="string">&quot;live&quot;</span>; <span class="comment">// 玩家状态</span></span><br><span class="line">  <span class="built_in">this</span>.name = name; <span class="comment">// 角色名字</span></span><br><span class="line">  <span class="built_in">this</span>.teamColor = teamColor; <span class="comment">// 队伍颜色</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Player.prototype.win = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 玩家团队胜利</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;winner: &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line">Player.prototype.lose = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 玩家团队失败</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;loser: &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 玩家死亡的方法</span></span><br><span class="line">Player.prototype.die = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 玩家死亡</span></span><br><span class="line">  <span class="keyword">let</span> all_dead = <span class="literal">true</span>;</span><br><span class="line">  <span class="built_in">this</span>.state = <span class="string">&quot;dead&quot;</span>; <span class="comment">// 设置玩家状态为死亡</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, partner; partner = <span class="built_in">this</span>.partners[i++];) &#123; <span class="comment">// 遍历队友列表</span></span><br><span class="line">    <span class="keyword">if</span> (partner.state !== <span class="string">&quot;dead&quot;</span>) &#123; <span class="comment">// 如果还有一个队友没有死亡，则游戏还未失败</span></span><br><span class="line">      all_dead = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (all_dead === <span class="literal">true</span>) &#123; <span class="comment">// 如果队友全部死亡</span></span><br><span class="line">    <span class="built_in">this</span>.lose(); <span class="comment">// 通知自己游戏失败</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, partner; partner = <span class="built_in">this</span>.partners[i++];) &#123;</span><br><span class="line">      partner.lose();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, enemy; enemy = <span class="built_in">this</span>.enemies[i++];) &#123;</span><br><span class="line">      enemy.win();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个工厂来创建玩家</span></span><br><span class="line"><span class="keyword">let</span> playerFactory = <span class="function"><span class="keyword">function</span> (<span class="params">name, teamColor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newPlayer = <span class="keyword">new</span> Player(name, teamColor);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, player; player = players[i++];) &#123; <span class="comment">// 通知所有的玩家，有新角色加入</span></span><br><span class="line">    <span class="keyword">if</span> (player.teamColor === newPlayer.teamColor) &#123; <span class="comment">// 如果是同一队的玩家</span></span><br><span class="line">      player.partners.push(newPlayer); <span class="comment">// 相互添加到队友列表</span></span><br><span class="line">      newPlayer.partners.push(player);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      player.enemies.push(newPlayer); <span class="comment">// 相互添加到敌人列表</span></span><br><span class="line">      newPlayer.enemies.push(player);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  players.push(newPlayer);</span><br><span class="line">  <span class="keyword">return</span> newPlayer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> players = [];</span><br><span class="line"><span class="comment">//红队:</span></span><br><span class="line"><span class="keyword">let</span> player1 = playerFactory(<span class="string">&quot;皮蛋&quot;</span>, <span class="string">&quot;red&quot;</span>),</span><br><span class="line">  player2 = playerFactory(<span class="string">&quot;小乖&quot;</span>, <span class="string">&quot;red&quot;</span>),</span><br><span class="line">  player3 = playerFactory(<span class="string">&quot;宝宝&quot;</span>, <span class="string">&quot;red&quot;</span>),</span><br><span class="line">  player4 = playerFactory(<span class="string">&quot;小强&quot;</span>, <span class="string">&quot;red&quot;</span>);</span><br><span class="line"><span class="comment">//蓝队:</span></span><br><span class="line"><span class="keyword">let</span> player5 = playerFactory(<span class="string">&quot;黑妞&quot;</span>, <span class="string">&quot;blue&quot;</span>),</span><br><span class="line">  player6 = playerFactory(<span class="string">&quot;葱头&quot;</span>, <span class="string">&quot;blue&quot;</span>),</span><br><span class="line">  player7 = playerFactory(<span class="string">&quot;胖墩&quot;</span>, <span class="string">&quot;blue&quot;</span>),</span><br><span class="line">  player8 = playerFactory(<span class="string">&quot;海盗&quot;</span>, <span class="string">&quot;blue&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让红队玩家全部死亡:</span></span><br><span class="line">player1.die();</span><br><span class="line">player2.die();</span><br><span class="line">player4.die();</span><br><span class="line">player3.die();</span><br></pre></td></tr></table></figure><p>每个玩家添加或者死亡，都必须修改所有其他玩家内部的队友列表和敌人列表。耦合度很高。</p><h2 id="代码重构-使用中介者模式"><a href="#代码重构-使用中介者模式" class="headerlink" title="代码重构(使用中介者模式)"></a>代码重构(使用中介者模式)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 玩家</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Player</span>(<span class="params">name, teamColor</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.state = <span class="string">&quot;live&quot;</span>; <span class="comment">// 玩家状态</span></span><br><span class="line">  <span class="built_in">this</span>.name = name; <span class="comment">// 角色名字</span></span><br><span class="line">  <span class="built_in">this</span>.teamColor = teamColor; <span class="comment">// 队伍颜色</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Player.prototype.win = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="built_in">this</span>.name + <span class="string">&#x27; won &#x27;</span> );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Player.prototype.lose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="built_in">this</span>.name +<span class="string">&#x27; lost&#x27;</span> );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************玩家死亡*****************/</span></span><br><span class="line">Player.prototype.die = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.state = <span class="string">&quot;dead&quot;</span>;</span><br><span class="line">  playerDirector.receiveMessage(<span class="string">&quot;playerDead&quot;</span>, <span class="built_in">this</span>);<span class="comment">// 给中介者发送消息，玩家死亡</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************移除玩家*****************/</span></span><br><span class="line">Player.prototype.remove = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 给中介者发送消息，移除一个玩家</span></span><br><span class="line">  playerDirector.receiveMessage(<span class="string">&quot;removePlayer&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************玩家换队*****************/</span></span><br><span class="line">Player.prototype.changeTeam = <span class="function"><span class="keyword">function</span> (<span class="params">color</span>) </span>&#123;</span><br><span class="line">  playerDirector.receiveMessage(<span class="string">&quot;changeTeam&quot;</span>, <span class="built_in">this</span>, color); <span class="comment">// 给中介者发送消息，玩家换队</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************定义中介者对象*****************/</span></span><br><span class="line"><span class="keyword">let</span> playerDirector = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> players = &#123;&#125;, <span class="comment">// 保存所有玩家</span></span><br><span class="line">    operations = &#123;&#125;; <span class="comment">// 中介者可以执行的操作</span></span><br><span class="line">  <span class="comment">/****************新增一个玩家***************************/</span></span><br><span class="line">  operations.addPlayer = <span class="function"><span class="keyword">function</span> (<span class="params">player</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> teamColor = player.teamColor; <span class="comment">// 玩家的队伍颜色</span></span><br><span class="line">    players[teamColor] = players[teamColor] || []; <span class="comment">// 如果该颜色的玩家还没有成立队伍，则新成立一个队伍</span></span><br><span class="line">    players[teamColor].push(player); <span class="comment">// 添加玩家进队伍</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">/****************移除一个玩家***************************/</span></span><br><span class="line">  operations.removePlayer = <span class="function"><span class="keyword">function</span> (<span class="params">player</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> teamColor = player.teamColor, <span class="comment">// 玩家的队伍颜色</span></span><br><span class="line">      teamPlayers = players[teamColor] || []; <span class="comment">// 该队伍所有成员</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = teamPlayers.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 遍历删除</span></span><br><span class="line">      <span class="keyword">if</span> (teamPlayers[i] === player) &#123;</span><br><span class="line">        teamPlayers.splice(i, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">/****************玩家换队***************************/</span></span><br><span class="line">  operations.changeTeam = <span class="function"><span class="keyword">function</span> (<span class="params">player, newTeamColor</span>) </span>&#123; <span class="comment">// 玩家换队</span></span><br><span class="line">    operations.removePlayer(player); <span class="comment">// 从原队伍中删除</span></span><br><span class="line">    player.teamColor = newTeamColor; <span class="comment">// 改变队伍颜色</span></span><br><span class="line">    operations.addPlayer(player);<span class="comment">// 增加到新队伍中</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">/****************玩家死亡***************************/</span></span><br><span class="line">  operations.playerDead = <span class="function"><span class="keyword">function</span> (<span class="params">player</span>) </span>&#123; <span class="comment">// 玩家死亡</span></span><br><span class="line">    <span class="keyword">let</span> teamColor = player.teamColor,</span><br><span class="line">      teamPlayers = players[teamColor]; <span class="comment">// 玩家所在队伍</span></span><br><span class="line">    <span class="keyword">let</span> all_dead = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, player; player = teamPlayers[i++];) &#123;</span><br><span class="line">      <span class="keyword">if</span> (player.state !== <span class="string">&quot;dead&quot;</span>) &#123;</span><br><span class="line">        all_dead = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (all_dead === <span class="literal">true</span>) &#123;<span class="comment">// 全部死亡</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, player; player = teamPlayers[i++];) &#123;</span><br><span class="line">        player.lose(); <span class="comment">// 本队所有玩家 lose</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> color <span class="keyword">in</span> players) &#123;</span><br><span class="line">        <span class="keyword">if</span> (color !== teamColor) &#123;</span><br><span class="line">          <span class="keyword">let</span> teamPlayers = players[color];  <span class="comment">// 其他队伍的玩家</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, player; player = teamPlayers[i++];) &#123;</span><br><span class="line">            player.win(); <span class="comment">// 其他队伍所有玩家 win</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> receiveMessage = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> message = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    operations[message].apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    receiveMessage: receiveMessage,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************设置工厂函数*****************/</span></span><br><span class="line"><span class="keyword">let</span> playerFactory = <span class="function"><span class="keyword">function</span> (<span class="params">name, teamColor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newPlayer = <span class="keyword">new</span> Player(name, teamColor); <span class="comment">// 创造一个新的玩家对象</span></span><br><span class="line">  playerDirector.receiveMessage(<span class="string">&quot;addPlayer&quot;</span>, newPlayer); <span class="comment">// 给中介者发送消息，新增玩家</span></span><br><span class="line">  <span class="keyword">return</span> newPlayer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//红队</span></span><br><span class="line"><span class="keyword">let</span> player1 = playerFactory(<span class="string">&quot;皮蛋&quot;</span>, <span class="string">&quot;red&quot;</span>),</span><br><span class="line">  player2 = playerFactory(<span class="string">&quot;小乖&quot;</span>, <span class="string">&quot;red&quot;</span>),</span><br><span class="line">  player3 = playerFactory(<span class="string">&quot;宝宝&quot;</span>, <span class="string">&quot;red&quot;</span>),</span><br><span class="line">  player4 = playerFactory(<span class="string">&quot;小强&quot;</span>, <span class="string">&quot;red&quot;</span>);</span><br><span class="line"><span class="comment">// 蓝队:</span></span><br><span class="line"><span class="keyword">let</span> player5 = playerFactory(<span class="string">&quot;黑妞&quot;</span>, <span class="string">&quot;blue&quot;</span>),</span><br><span class="line">  player6 = playerFactory(<span class="string">&quot;葱头&quot;</span>, <span class="string">&quot;blue&quot;</span>),</span><br><span class="line">  player7 = playerFactory(<span class="string">&quot;胖墩&quot;</span>, <span class="string">&quot;blue&quot;</span>),</span><br><span class="line">  player8 = playerFactory(<span class="string">&quot;海盗&quot;</span>, <span class="string">&quot;blue&quot;</span>);</span><br><span class="line"></span><br><span class="line">player1.die();</span><br><span class="line">player2.die();</span><br><span class="line">player3.die();</span><br><span class="line">player4.die();</span><br></pre></td></tr></table></figure><p>现在玩家与玩家之间的耦合消除了，所有操作逻辑在中介者对象中实现，玩家只需要向中介者发生消息，中介者会把处理结果反馈给其他玩家对象。</p><h2 id="使用时机"><a href="#使用时机" class="headerlink" title="使用时机"></a>使用时机</h2><p>中介者模式可以非常方便地对模块或者对象进行解耦，但对象之间并非一定需要解耦。在实际项目中，模块或对象之间有一些依赖关系是很正常的。毕竟我们写程序是为了快速完成项目交付生产，而不是堆砌模式和过度设计。关键就在于如何去衡量对象之间的耦合程度。一般来说， 如果对象之间的复杂耦合确实导致调用和维护出现了困难，而且这些耦合度随项目的变化呈指数增长曲线，那我们就可以考虑用中介者模式来重构代码。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>中介者模式是迎合迪米特法则的一种实现。迪米特法则也叫最少知识原则，是指一个对象应该尽可能少地了解另外的对象。如果对象之间的耦合性太高，一个对象发生改变之后，难免会影响到其他的对象，而在中介者模式里，对象之间几乎不知道彼此的存在，它们只能通过中介者对象来互相影响对方。</p><p>中介者模式也存在一些缺点。其中最大的缺点是系统中会新增一个中介者对象，因 为对象之间交互的复杂性，转移成了中介者对象的复杂性，使得中介者对象经常是巨大的。中介者对象自身往往就是一个难以维护的对象。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《javascript设计模式与开发实践》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;中介者模式&quot;&gt;&lt;a href=&quot;#中介者模式&quot; class=&quot;headerlink&quot; title=&quot;中介者模式&quot;&gt;&lt;/a&gt;中介者模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://liang5757.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://liang5757.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>职责链模式</title>
    <link href="https://liang5757.github.io/2021/02/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>https://liang5757.github.io/2021/02/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-02-07T07:36:10.000Z</published>
    <updated>2021-05-05T17:07:31.647Z</updated>
    
    <content type="html"><![CDATA[<h1 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h1><blockquote><p>职责链模式的定义是：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p><p>职责链模式的名字非常形象，一系列可能会处理请求的对象被连接成一条链，请求在这些对 象之间依次传递，直到遇到一个可以处理它的对象，我们把这些对象称为链中的节点</p></blockquote><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>​    假设我们负责一个售卖手机的电商网站，经过分别交纳 500 元定金和 200 元定金的两轮预定后(订单已在此时生成)，现在已经到了正式购买的阶段。</p><p>​    在正式购买后，已经支付过 500 元定金的用户会收到 100 元的商城优惠券，200 元定金的用户可以收到 50 元的优惠券，而之前没有支付定金的用户只能进入普通购买模式，也就是没有优惠券，且在库存有限的情况下不一定保证能买到。</p><ul><li>orderType：订单类型</li><li>pay：用户是否已经支付定金</li><li>stock：用于普通用户，普通购买的手机库存数量</li></ul><h2 id="代码实现（未使用职责链模式）"><a href="#代码实现（未使用职责链模式）" class="headerlink" title="代码实现（未使用职责链模式）"></a>代码实现（未使用职责链模式）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> order = <span class="function"><span class="keyword">function</span> (<span class="params">orderType, pay, stock</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (orderType === <span class="number">1</span>) &#123; <span class="comment">// 500 元定金购买模式</span></span><br><span class="line">    <span class="keyword">if</span> (pay === <span class="literal">true</span>) &#123; <span class="comment">// 已支付定金</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;500 元定金预购, 得到 100 优惠券&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 未支付定金，降级到普通购买模式</span></span><br><span class="line">      <span class="keyword">if</span> (stock &gt; <span class="number">0</span>) &#123; <span class="comment">// 用于普通购买的手机还有库存</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;普通购买, 无优惠券&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;手机库存不足&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pay === <span class="literal">true</span>) &#123; <span class="comment">// 200 元定金购买模式</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;200 元定金预购, 得到 50 优惠券&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (stock &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;普通购买, 无优惠券&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;手机库存不足&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType === <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (stock &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;普通购买, 无优惠券&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;手机库存不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">order(<span class="number">1</span>, <span class="literal">true</span>, <span class="number">500</span>); <span class="comment">// 输出: 500 元定金预购, 得到 100 优惠券</span></span><br></pre></td></tr></table></figure><h2 id="用职责链模式重构代码"><a href="#用职责链模式重构代码" class="headerlink" title="用职责链模式重构代码"></a>用职责链模式重构代码</h2><p>​    先把 500 元订单、200 元订单以及普通购买分成 3 个函数。</p><p>​    接下来把 orderType、pay、stock 这 3 个字段当作参数传递给 500 元订单函数，如果该函数不符合处理条件，则把这个请求传递给后面的 200 元订单函数，如果 200 元订单函数依然不能处理该请求，则继续传递请求给普通购买函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> order500 = <span class="function"><span class="keyword">function</span> (<span class="params">orderType, pay, stock</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (orderType === <span class="number">1</span> &amp;&amp; pay === <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;500 元定金预购，得到 100 优惠券&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;nextSuccessor&quot;</span>; <span class="comment">// 我不知道下一个节点是谁，反正把请求往后面传递</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> order200 = <span class="function"><span class="keyword">function</span> (<span class="params">orderType, pay, stock</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (orderType === <span class="number">2</span> &amp;&amp; pay === <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;200 元定金预购，得到 50 优惠券&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;nextSuccessor&quot;</span>; <span class="comment">// 我不知道下一个节点是谁，反正把请求往后面传递</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> orderNormal = <span class="function"><span class="keyword">function</span> (<span class="params">orderType, pay, stock</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (stock &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;普通购买，无优惠券&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;手机库存不足&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Chain.prototype.setNextSuccessor 指定在链中的下一个节点</span></span><br><span class="line"><span class="comment">// Chain.prototype.passRequest 传递请求给某个节点</span></span><br><span class="line"><span class="keyword">let</span> Chain = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.fn = fn;</span><br><span class="line">  <span class="built_in">this</span>.successor = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Chain.prototype.setNextSuccessor = <span class="function"><span class="keyword">function</span> (<span class="params">successor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.successor = successor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Chain.prototype.passRequest = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ret = <span class="built_in">this</span>.fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">if</span> (ret === <span class="string">&quot;nextSuccessor&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.successor &amp;&amp; <span class="built_in">this</span>.successor.passRequest.apply(<span class="built_in">this</span>.successor, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> chainOrder500 = <span class="keyword">new</span> Chain(order500);</span><br><span class="line"><span class="keyword">let</span> chainOrder200 = <span class="keyword">new</span> Chain(order200);</span><br><span class="line"><span class="keyword">let</span> chainOrderNormal = <span class="keyword">new</span> Chain(orderNormal);</span><br><span class="line"></span><br><span class="line">chainOrder500.setNextSuccessor(chainOrder200);</span><br><span class="line">chainOrder200.setNextSuccessor(chainOrderNormal);</span><br><span class="line"></span><br><span class="line">chainOrder500.passRequest(<span class="number">1</span>, <span class="literal">true</span>, <span class="number">500</span>);   <span class="comment">// 输出:500 元定金预购，得到 100 优惠券</span></span><br><span class="line">chainOrder500.passRequest(<span class="number">2</span>, <span class="literal">true</span>, <span class="number">500</span>);   <span class="comment">// 输出:200 元定金预购，得到 50 优惠券</span></span><br><span class="line">chainOrder500.passRequest(<span class="number">3</span>, <span class="literal">true</span>, <span class="number">500</span>);   <span class="comment">// 输出:普通购买，无优惠券</span></span><br><span class="line">chainOrder500.passRequest(<span class="number">1</span>, <span class="literal">false</span>, <span class="number">0</span>);    <span class="comment">// 输出:手机库存不足</span></span><br></pre></td></tr></table></figure><h2 id="异步的职责链"><a href="#异步的职责链" class="headerlink" title="异步的职责链"></a>异步的职责链</h2><p>​    在现实开发中，我们经常会遇到一些异步的问题，比如我们要在节点函数中发起一个 ajax 异步请求，异步请求返回的结果才能决定是否继续在职责链中 passRequest。 这时候让节点函数同步返回 “nextSuccessor” 已经没有意义了，所以要给 Chain 类再增加一个原型方法 Chain.prototype.next，表示手动传递请求给职责链中的下一个节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Chain.prototype.next = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.successor &amp;&amp; <span class="built_in">this</span>.successor.passRequest.apply(<span class="built_in">this</span>.successor, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步职责链</span></span><br><span class="line"><span class="keyword">let</span> fn1 = <span class="keyword">new</span> Chain(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;nextSuccessor&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn2 = <span class="keyword">new</span> Chain(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">let</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    self.next();</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn3 = <span class="keyword">new</span> Chain(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;);</span><br><span class="line">fn1.setNextSuccessor(fn2).setNextSuccessor(fn3);</span><br><span class="line">fn1.passRequest();</span><br></pre></td></tr></table></figure><p>现在我们得到了一个特殊的链条，请求在链中的节点里传递，但节点有权利决定什么时候把 请求交给下一个节点。可以想象，异步的职责链加上命令模式(把 ajax 请求封装成命令对象)，我们可以很方便地创建一个异步 ajax 队列库。</p><h2 id="AOP实现职责链"><a href="#AOP实现职责链" class="headerlink" title="AOP实现职责链"></a>AOP实现职责链</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ret = self.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret === <span class="string">&quot;nextSuccessor&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> order = order500.after(order200).after(orderNormal);</span><br><span class="line">order(<span class="number">1</span>, <span class="literal">true</span>, <span class="number">500</span>);    <span class="comment">// 输出:500 元定金预购，得到 100 优惠券</span></span><br><span class="line">order(<span class="number">2</span>, <span class="literal">true</span>, <span class="number">500</span>);    <span class="comment">// 输出:200 元定金预购，得到 50 优惠券</span></span><br><span class="line">order(<span class="number">1</span>, <span class="literal">false</span>, <span class="number">500</span>);   <span class="comment">// 输出:普通购买，无优惠券</span></span><br></pre></td></tr></table></figure><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>但是职责链模式并不能保证某个请求一定会被链中的节点处理，而是径直的从链尾离开，这种情况下，我们可以在链尾<strong>增加一个保底的接受者节点来处理这种即将离开链尾的请求</strong>。</p><p>并且职责链模式使得程序中多了一些节点对象，可能在某一次的请求传递过程中，并没有起到实质性的作用，它们的作用仅仅是让请求传递下去，从性能方面考虑，我们要<strong>避免过长的职责链</strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《javascript设计模式与开发实践》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;职责链模式&quot;&gt;&lt;a href=&quot;#职责链模式&quot; class=&quot;headerlink&quot; title=&quot;职责链模式&quot;&gt;&lt;/a&gt;职责链模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;职责链模式的定义是：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://liang5757.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://liang5757.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>享元模式</title>
    <link href="https://liang5757.github.io/2021/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <id>https://liang5757.github.io/2021/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-02-06T07:35:23.000Z</published>
    <updated>2021-05-05T17:07:29.754Z</updated>
    
    <content type="html"><![CDATA[<h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><blockquote><p>享元(flyweight)模式是一种用于性能优化的模式，“fly”在这里是苍蝇的意思，意为“蝇量级”。享元模式的核心是运用共享技术来有效支持大量细粒度的对象。</p><p>如果系统中因为创建了大量类似的对象而导致内存占用过高，享元模式就非常有用了。在 JavaScript 中，浏览器特别是移动端的浏览器分配的内存并不算多，如何节省内存就成了一件非常有意义的事情。</p></blockquote><h2 id="故事背景"><a href="#故事背景" class="headerlink" title="故事背景"></a>故事背景</h2><p>​    假设有个内衣工厂，目前的产品有 50 种男式内衣和 50 种女士内衣，为了推销产品，工厂决定生产一些塑料模特来穿上他们的内衣拍成广告照片。 正常情况下需要 50个男模特和50个女模特，然后让他们每人分别穿上一件内衣来拍照。</p><h2 id="代码实现-未使用享元模式"><a href="#代码实现-未使用享元模式" class="headerlink" title="代码实现(未使用享元模式)"></a>代码实现(未使用享元模式)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">sex, underwear</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    <span class="built_in">this</span>.underwear = underwear;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">takePhoto</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;sex= &#x27;</span> + <span class="built_in">this</span>.sex + <span class="string">&#x27; underwear=&#x27;</span> + <span class="built_in">this</span>.underwear);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> maleModel = <span class="keyword">new</span> Model(<span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;underwear&#x27;</span> + i);</span><br><span class="line">  maleModel.takePhoto();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= <span class="number">50</span>; j++) &#123;</span><br><span class="line">  <span class="keyword">let</span> femaleModel = <span class="keyword">new</span> Model(<span class="string">&#x27;female&#x27;</span>, <span class="string">&#x27;underwear&#x27;</span> + j);</span><br><span class="line">  femaleModel.takePhoto();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考：真的需要如此多数量的对象吗？"><a href="#思考：真的需要如此多数量的对象吗？" class="headerlink" title="思考：真的需要如此多数量的对象吗？"></a>思考：真的需要如此多数量的对象吗？</h2><p>​    如上所述，现在一共有 50 种男内 衣和 50 种女内衣，所以一共会产生 100 个对象。如果将来生产了 10000 种内衣，那这个程序可能会因为存在如此多的对象已经提前崩溃。 下面我们来考虑一下如何优化这个场景。虽然有 100 种内衣，但很显然并不需要 50 个男模特和 50 个女模特。其实男模特和女模特各自有一个就足够了，他们可以分别穿上不同的内衣来拍照。</p><h2 id="代码重构-享元模式"><a href="#代码重构-享元模式" class="headerlink" title="代码重构(享元模式)"></a>代码重构(享元模式)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只需要区别男女模特</span></span><br><span class="line"><span class="comment">//  那我们先把 underwear 参数从构造函数中 移除，构造函数只接收 sex 参数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">sex</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.sex = sex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">takePhoto</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;sex= &#x27;</span> + <span class="built_in">this</span>.sex + <span class="string">&#x27; underwear=&#x27;</span> + <span class="built_in">this</span>.underwear);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分别创建一个男模特对象和一个女模特对象</span></span><br><span class="line"><span class="keyword">let</span> maleModel = <span class="keyword">new</span> Model(<span class="string">&#x27;male&#x27;</span>),</span><br><span class="line">  femaleModel = <span class="keyword">new</span> Model(<span class="string">&#x27;female&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给男模特依次穿上所有的男装，并进行拍照</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">  maleModel.underwear = <span class="string">&#x27;underwear&#x27;</span> + i; <span class="comment">// 设置外部状态</span></span><br><span class="line">  maleModel.takePhoto();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给女模特依次穿上所有的女装，并进行拍照</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= <span class="number">50</span>; j++) &#123;</span><br><span class="line">  femaleModel.underwear = <span class="string">&#x27;underwear&#x27;</span> + j; <span class="comment">// 设置外部状态</span></span><br><span class="line">  femaleModel.takePhoto();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要两个对象便完成了同样的功能</p><h2 id="如何使用享元模式"><a href="#如何使用享元模式" class="headerlink" title="如何使用享元模式"></a>如何使用享元模式</h2><p>享元模式要求将对象的属性划分为<strong>内部状态</strong>与<strong>外部状态</strong>(状态在这里通常指属性)。享元模式的目标是尽量减少共享对象的数量，关于如何划分内部状态和外部状态，下面的几条经验提供了一些指引</p><ul><li>内部状态可以被一些对象共享</li><li>内部状态独立于具体的场景，通常不会改变</li><li>外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享</li></ul><p>在上面的例子中，<strong>性别是内部状态，内衣是外部状态</strong>，通过区分这两种状态，大大减少了系统中的对象数量。通常来讲，内部状态有多少种组合，系统中便最多存在多少个对象，因为性别通常只有男女两种，所以该内衣厂商最多只需要 2 个对象。</p><h2 id="享元模式的通用结构"><a href="#享元模式的通用结构" class="headerlink" title="享元模式的通用结构"></a>享元模式的通用结构</h2><h3 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h3><ol><li>我们通过构造函数显示<code>new</code>出了男女两个model对象，在其他系统中，<strong>也许并不是一开始就需要所有的共享对象</strong></li><li>给<code>model</code>对象手动设置了<code>underwear</code>外部状态，在更复杂的系统中，这不是一个最好的方式，因为<strong>外部状态可能相当复杂，它们与共享对象的联系会变得困难</strong></li></ol><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>第一个问题可以用<strong>工厂模式</strong>解决，如果某种内部状态对应的共享对象已经被创建过，那么直接返回这个对象</p><p>第二个问题可以<strong>用一个管理器记录对象相关的外部状态</strong>，使这些外部状态通过某个钩子和共享对象联系起来</p><h2 id="享元模式的替代方案-——-对象池"><a href="#享元模式的替代方案-——-对象池" class="headerlink" title="享元模式的替代方案 —— 对象池"></a>享元模式的替代方案 —— 对象池</h2><p>​    对象池是另外一种性能优化方案，它跟享元模式有一些相似之处，但没有分离内部状态和外部状态这个过程。对象池维护一个装载空闲对象的池子，如果需要对象的时候，不是直接 new，而是转从对象池里获取。如果对象池里没有空闲对象，则创建一个新的对象，当获取出的对象完成它的职责之后， 再进入池子等待被下次获取。</p><h3 id="通用的对象池实现"><a href="#通用的对象池实现" class="headerlink" title="通用的对象池实现"></a>通用的对象池实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用的对象池</span></span><br><span class="line"><span class="keyword">let</span> objectPoolFactory = <span class="function"><span class="keyword">function</span> (<span class="params">createObjFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> objectPool = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    create: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> objectPool.length === <span class="number">0</span> ?</span><br><span class="line">        createObjFn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>) : objectPool.shift();</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    recover: <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">      objectPool.push(obj);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在利用<code>objectPoolFactory</code>来创建一个装载一些 iframe 的对象池</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iframeFactory = objectPoolFactory(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">&quot;iframe&quot;</span>);</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line">  iframe.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    iframe.onload = <span class="literal">null</span>; <span class="comment">// 防止 iframe 重复加载的 bug</span></span><br><span class="line">    iframeFactory.recover(iframe);<span class="comment">// iframe 加载完成之后回收节点</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> iframe;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iframe1 = iframeFactory.create();</span><br><span class="line">iframe1.src = <span class="string">&quot;http:// baidu.com&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iframe2 = iframeFactory.create();</span><br><span class="line">iframe2.src = <span class="string">&quot;http:// QQ.com&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> iframe3 = iframeFactory.create();</span><br><span class="line">  iframe3.src = <span class="string">&quot;http:// 163.com&quot;</span>;</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>对象池的应用非常广泛，HTTP连接池和数据库连接池都是其代表应用，也可以用在dom的重复利用上。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《javascript设计模式与开发实践》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;享元模式&quot;&gt;&lt;a href=&quot;#享元模式&quot; class=&quot;headerlink&quot; title=&quot;享元模式&quot;&gt;&lt;/a&gt;享元模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;享元(flyweight)模式是一种用于性能优化的模式，“fly”在这里是苍蝇的意思，意为“蝇量级
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://liang5757.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://liang5757.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>模板方法模式</title>
    <link href="https://liang5757.github.io/2021/02/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>https://liang5757.github.io/2021/02/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-02-05T07:34:10.000Z</published>
    <updated>2021-05-05T17:07:23.639Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><blockquote><p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行</p></blockquote><h2 id="Coffee-or-Tea"><a href="#Coffee-or-Tea" class="headerlink" title="Coffee or Tea"></a>Coffee or Tea</h2><p>我们现在需要冲泡一杯咖啡和一壶茶，它们的操作步骤基本上是一样的，如下所示</p><table><thead><tr><th>泡咖啡</th><th>泡茶</th></tr></thead><tbody><tr><td>把水煮沸</td><td>把水煮沸</td></tr><tr><td>用沸水冲泡<strong>咖啡</strong></td><td>用沸水浸泡<strong>茶叶</strong></td></tr><tr><td>把<strong>咖啡</strong>倒进杯子</td><td>把<strong>茶水</strong>倒进杯子</td></tr><tr><td><strong>加糖和牛奶</strong></td><td><strong>加柠檬</strong></td></tr></tbody></table><p> 基本的步骤是一样的，我们可以使用抽象类的形式，把步骤框架抽象出来，Coffee类和Tea类继承这个抽象类，再各自实现抽象父类上的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个抽象父类来表示泡一杯饮料的整个过程。</span></span><br><span class="line"><span class="comment">// 不论是 Coffee,还是 Tea,都被我们用Beverage来表示</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">boilWater</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;把水煮沸&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">brew</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;子类必须重写 brew 方法&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">pourInCup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;子类必须重写 pourInCup 方法&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">addCondiments</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;子类必须重写 addCondiments 方法&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123; <span class="comment">// 模板方法</span></span><br><span class="line">    <span class="built_in">this</span>.boilWater();</span><br><span class="line">    <span class="built_in">this</span>.brew();</span><br><span class="line">    <span class="built_in">this</span>.pourInCup();</span><br><span class="line">    <span class="built_in">this</span>.addCondiments();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Coffee类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> <span class="keyword">extends</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">brew</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;用沸水冲泡咖啡&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">pourInCup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;把咖啡倒进杯子&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">addCondiments</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;加糖和牛奶&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> coffee = <span class="keyword">new</span> Coffee();</span><br><span class="line">coffee.init();</span><br><span class="line"><span class="comment">// 把水煮沸</span></span><br><span class="line"><span class="comment">// 用沸水冲泡咖啡</span></span><br><span class="line"><span class="comment">// 把咖啡倒进杯子</span></span><br><span class="line"><span class="comment">// 加糖和牛奶</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Tea类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tea</span> <span class="keyword">extends</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">brew</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;用沸水浸泡茶叶&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">pourInCup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;把茶倒进杯子&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">addCondiments</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;加柠檬&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tea = <span class="keyword">new</span> Tea();</span><br><span class="line">tea.init();</span><br><span class="line"><span class="comment">// 把水煮沸</span></span><br><span class="line"><span class="comment">// 用沸水浸泡茶叶</span></span><br><span class="line"><span class="comment">// 把茶倒进杯子</span></span><br><span class="line"><span class="comment">// 加柠檬</span></span><br></pre></td></tr></table></figure><p>上面代码中，Beverage父类里的<code>init</code>方法即为<strong>模板方法</strong>，init封装了子类的算法框架，作为算法的模板，指导子类以何种顺序去执行哪些方法。</p><h2 id="好莱坞原则"><a href="#好莱坞原则" class="headerlink" title="好莱坞原则"></a>好莱坞原则</h2><p>​    好莱坞无疑是演员的天堂，但好莱坞也有很多找不到工作的新人演员，许多新人演员在好莱坞把简历递给演艺公司之后就只有回家等待电话。有时候该演员等得不耐烦了，给演艺公司打电话询问情况，演艺公司往往这样回答：“不要来找我，我会给你打电话。” 在设计中，这样的规则就称为好莱坞原则。在这一原则的指导下，我们允许底层组件将自己挂钩到高层组件中，而高层组件会决定什么时候、以何种方式去使用这些底层组件，高层组件对 待底层组件的方式，跟演艺公司对待新人演员一样，都是“别调用我们，我们会调用你”。<br>​    比如发布订阅模式和回调函数</p><h2 id="是否真的需要继承"><a href="#是否真的需要继承" class="headerlink" title="是否真的需要继承"></a>是否真的需要继承</h2><p>在JavaScript这种灵活的语言中，我们是否真的需要使用继承这种重武器呢。在好莱坞原则的指导下，我们可以重构上面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Beverage = <span class="function"><span class="keyword">function</span> (<span class="params">param</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> boilWater = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;把水煮沸&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> brew = param.brew || <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;必须传递 brew 方法&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> pourInCup = param.pourInCup || <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;必须传递 pourInCup 方法&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> addCondiments = param.addCondiments || <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;必须传递 addCondiments 方法&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  F.prototype.init = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    boilWater();</span><br><span class="line">    brew();</span><br><span class="line">    pourInCup();</span><br><span class="line">    addCondiments();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Coffee = Beverage(&#123;</span><br><span class="line">  <span class="function"><span class="title">brew</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;用沸水冲泡咖啡&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">pourInCup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;把咖啡倒进杯子&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">addCondiments</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;加糖和牛奶&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Tea = Beverage(&#123;</span><br><span class="line">  <span class="function"><span class="title">brew</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;用沸水浸泡茶叶&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">pourInCup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;把茶倒进杯子&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">addCondiments</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;加柠檬&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    模板方法模式是一种典型的通过封装变化提高系统扩展性的设计模式。在传统的面向对象语言中，一个运用了模板方法模式的程序中，子类的方法种类和执行顺序都是不变的，所以我们把这部分逻辑抽象到父类的模板方法里面。而子类的方法具体怎么实现则是可变的，于是我们把这部分变化的逻辑封装到子类中。通过增加新的子类，我们便能给系统增加新的功能，并不需要改动抽象父类以及其他子类，这也是符合开放-封闭原则的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《javascript设计模式与开发实践》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;模板方法模式&quot;&gt;&lt;a href=&quot;#模板方法模式&quot; class=&quot;headerlink&quot; title=&quot;模板方法模式&quot;&gt;&lt;/a&gt;模板方法模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://liang5757.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://liang5757.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>组合模式</title>
    <link href="https://liang5757.github.io/2021/02/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <id>https://liang5757.github.io/2021/02/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-02-04T07:32:50.000Z</published>
    <updated>2021-05-05T17:07:41.444Z</updated>
    
    <content type="html"><![CDATA[<h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><blockquote><p>组合模式将对象组合成树形结构，以表示“部分-整体”的层次结构。 除了用来表示树形结构之外，组合模式的另一个好处是通过对象的多态性表现，使得用户对单个对象和组合对象的使用具有一致性</p></blockquote><p>​    在组合模式中，请求在树中传递的过程总是遵循一种逻辑。请求从树最顶端的对象往下传递，如果当前处理请求的对象是叶对象(普通子命令)，叶对象自身会对请求作出相应的处理，如果当前处理请求的对象是组合对象(宏命令)， 组合对象则会遍历它属下的子节点，将请求继续传递给这些子节点。</p><p><img src= "/img/loading.gif" data-lazy-src="/2021/02/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/167b6de69881f746" alt="组合模式请求传递方式"></p><h2 id="组合模式下更为强大的宏命令"><a href="#组合模式下更为强大的宏命令" class="headerlink" title="组合模式下更为强大的宏命令"></a>组合模式下更为强大的宏命令</h2><p>​    目前的万能遥控器，包含了关门、开电脑、登录 QQ 这 3 个命令。现在我们需要一个“超级万能遥控器”，可以控制家里所有的电器，这个遥控器拥有以下功能</p><ul><li>打开空调</li><li>打开电视和音响</li><li>关门、开电脑、登录 QQ</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> MacroCommand = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    commandsList: [],</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span> (<span class="params">command</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.commandsList.push(command);</span><br><span class="line">    &#125;,</span><br><span class="line">    execute: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, command; command = <span class="built_in">this</span>.commandsList[i++];) &#123;</span><br><span class="line">        command.execute();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> openAcCommand = &#123;</span><br><span class="line">  execute: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;打开空调&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 家里的电视和音响是连接在一起的，所以可以用一个宏命令来组合打开电视和打开音响的命令</span></span><br><span class="line"><span class="keyword">let</span> openTvCommand = &#123;</span><br><span class="line">  execute: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;打开电视&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> openSoundCommand = &#123;</span><br><span class="line">  execute: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;打开音响&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> macroCommand1 = MacroCommand();</span><br><span class="line">macroCommand1.add(openTvCommand);</span><br><span class="line">macroCommand1.add(openSoundCommand);</span><br><span class="line"><span class="comment">// 关门、打开电脑和打登录 QQ 的命令</span></span><br><span class="line"><span class="keyword">let</span> closeDoorCommand = &#123;</span><br><span class="line">  execute: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;关门&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> openPcCommand = &#123;</span><br><span class="line">  execute: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;开电脑&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> openQQCommand = &#123;</span><br><span class="line">  execute: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;登录 QQ&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> macroCommand2 = MacroCommand();</span><br><span class="line">macroCommand2.add(closeDoorCommand);</span><br><span class="line">macroCommand2.add(openPcCommand);</span><br><span class="line">macroCommand2.add(openQQCommand);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在把所有的命令组合成一个“超级命令”</span></span><br><span class="line"><span class="keyword">let</span> macroCommand = MacroCommand();</span><br><span class="line">macroCommand.add(openAcCommand);</span><br><span class="line">macroCommand.add(macroCommand1);</span><br><span class="line">macroCommand.add(macroCommand2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后给遥控器绑定“超级命令”</span></span><br><span class="line"><span class="keyword">let</span> setCommand = (<span class="function"><span class="keyword">function</span> (<span class="params">command</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;button&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    command.execute();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(macroCommand);</span><br></pre></td></tr></table></figure><p>​    <strong>不管是宏命令对象，还是子命令对象，都有一个execute方法负责执行命令</strong>。<br>​    这在静态类型语言中实现显的尤为便利，比如在JAVA中，<code>Composite</code>类和<code>Leaf</code>类都必须继承自一个<code>Compenent</code>抽象类，这个Compenent抽象即表示组合对象，又代表叶对象，它也能保证两者均有<code>execute</code>方法，从而做出反馈。</p><p>​    但是在JavaScript这种动态语言中实现组合模式，由于鸭子类型，我们并不需要有一个<code>Compenent</code>抽象类，但是这也导致了一定的严谨性。</p><h2 id="透明性带来的安全问题"><a href="#透明性带来的安全问题" class="headerlink" title="透明性带来的安全问题"></a>透明性带来的安全问题</h2><p>我们可以给叶子节点也增加<code>add</code>方法，并在调用的时候，抛出一个异常来提醒客户。比如上面的打开电视的命令对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> openTvCommand = &#123;</span><br><span class="line">  execute: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;打开电视&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  add: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 同样的添加add方法</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;叶对象不能添加子节点&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="应用场景-—-扫描文件夹"><a href="#应用场景-—-扫描文件夹" class="headerlink" title="应用场景 — 扫描文件夹"></a>应用场景 — 扫描文件夹</h2><p>​    文件夹和文件之间的关系，非常适合用组合模式来描述。文件夹里既可以包含文件，又可以包含其他文件夹，最终可能组合成一棵树 当使用用杀毒软件扫描该文件夹时，往往不会关心里面有多少文件和子文件夹，组合模式使得我们只需要操作最外层的文件夹进行扫描。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><h3 id="组合模式不是父子关系"><a href="#组合模式不是父子关系" class="headerlink" title="组合模式不是父子关系"></a>组合模式不是父子关系</h3><p>​    组合模式是一种HAS-A（聚合）的关系，而不是IS-A；Leaf并不是Composite的子类。</p><h3 id="对叶对象操作的一致性"><a href="#对叶对象操作的一致性" class="headerlink" title="对叶对象操作的一致性"></a>对叶对象操作的一致性</h3><p>​    组合模式除了要求组合对象和叶子对象拥有相同的接口之外，还有一个必要条件，就是对一组叶对象的操作的一致性。</p><p>​    比如公司要给全体员工发元旦的过节费1000元，这个场景可以运用组合模式，但如果公司要给今天过生日的员工发送一封生日祝福的邮件，组合模式就做不到了，除非先把今天过生日的员工挑选出来。只有用一致的方式对待列表中的每一个叶子对象的时候，才适合使用组合模式。</p><h3 id="双向映射关系"><a href="#双向映射关系" class="headerlink" title="双向映射关系"></a>双向映射关系</h3><p>​    发放过节费的通知步骤是从公司到各个部门，再到各个小组，最后到每个员工的邮箱里。这本身是一个组合模式的好例子，但某些员工可能隶属于多个组织，对象之间的关系并不是严格意义上的层次结构，在这种情况下，是不适合使用组合模式的，该员工可能收到多份过节费。</p><p>​    这种复合情况下我们必须给父节点和子节点建立双向映射关系，一个简单的方法是给小组和员工对象都增加集合来保存对方的引用。<br>但是这种相互间的引用相当复杂，而且对象之间产生了过多的耦合性，修改或者删除一个对象都变得困难，此时我们可以引入中介者模式来管理这些对象。</p><h3 id="用职责链模式提高组合模式性能"><a href="#用职责链模式提高组合模式性能" class="headerlink" title="用职责链模式提高组合模式性能"></a>用职责链模式提高组合模式性能</h3><p>​    在组合模式中，如果树的结构比较复杂，节点数量很多，在遍历树的过程中，性能方面也许表现的不够理想，我们可以借助职责链模式避免遍历整棵树。职责链模式一般需要我们手动去设置链条，但在组合模式中，父对象和子对象之间实际形成了天然的职责链。让请求顺着链条从父对象往子对象传递，或者是反过来从子对象往父对象传递，直到遇到可以处理该请求的对象位置。</p><h2 id="引用父对象"><a href="#引用父对象" class="headerlink" title="引用父对象"></a>引用父对象</h2><p>在组合模式中使用职责链时，有可能需要让请求从子节点往父节点上冒泡传递</p><p>在文件系统中，当我们删除某个文件夹的时候，实际上是从这个文件夹所在的上层文件夹中删除改文件的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Folder</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.parent = <span class="literal">null</span>; <span class="comment">// 增加 this.parent 属性</span></span><br><span class="line">    <span class="built_in">this</span>.files = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params">file</span>)</span> &#123;</span><br><span class="line">    file.parent = <span class="built_in">this</span>; <span class="comment">// 设置父对象</span></span><br><span class="line">    <span class="built_in">this</span>.files.push(file);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">scan</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;开始扫描文件夹: &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, file, files = <span class="built_in">this</span>.files; file = files[i++];) &#123;</span><br><span class="line">      file.scan();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.parent) &#123; <span class="comment">// 根节点或者树外的游离节点</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> files = <span class="built_in">this</span>.parent.files, l = files.length - <span class="number">1</span>; l &gt;= <span class="number">0</span>; l--) &#123; <span class="comment">// 从父目录下搜索删除当前文件或文件夹</span></span><br><span class="line">      <span class="keyword">let</span> file = files[l];</span><br><span class="line">      <span class="keyword">if</span> (file === <span class="built_in">this</span>) &#123;</span><br><span class="line">        files.splice(l, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.parent = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;不能添加在文件下面&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">scan</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;开始扫描文件: &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.parent) &#123; <span class="comment">//根节点或者树外的游离节点</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> files = <span class="built_in">this</span>.parent.files, l = files.length - <span class="number">1</span>; l &gt;= <span class="number">0</span>; l--) &#123;</span><br><span class="line">      <span class="keyword">let</span> file = files[l];</span><br><span class="line">      <span class="keyword">if</span> (file === <span class="built_in">this</span>) &#123;</span><br><span class="line">        files.splice(l, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="何时使用组合模式"><a href="#何时使用组合模式" class="headerlink" title="何时使用组合模式"></a>何时使用组合模式</h2><ul><li>表示对象的部分-整体层次结构。组合模式可以方便的构造一棵树来表示对象的部分-整体结构。<strong>特别是我们不确定该树到底存在多少层次的时候</strong></li><li>用户希望以统一的方式对待树中的所有对象</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>​    组合模式并不是完美的，它可能会产生一个这样的系统:系统中的每个对象看起来都与其他对象差不多。它们的区别只有在运行的时候会才会显现出来，这会使代码难以理解。此外,如果通过组合模式创建了太多的对象，那么这些对象可能会让系统负担不起。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《javascript设计模式与开发实践》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;组合模式&quot;&gt;&lt;a href=&quot;#组合模式&quot; class=&quot;headerlink&quot; title=&quot;组合模式&quot;&gt;&lt;/a&gt;组合模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;组合模式将对象组合成树形结构，以表示“部分-整体”的层次结构。 除了用来表示树形结构之外，组合模式
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://liang5757.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://liang5757.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>命令模式</title>
    <link href="https://liang5757.github.io/2021/02/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>https://liang5757.github.io/2021/02/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-02-03T07:32:07.000Z</published>
    <updated>2021-05-05T17:07:21.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><blockquote><p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作</p></blockquote><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>​    有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。此时希望用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。</p><h3 id="菜单案例"><a href="#菜单案例" class="headerlink" title="菜单案例"></a>菜单案例</h3><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>  假设我们正在编写一个用户界面程序，该用户界面上至少有数十个 Button 按钮。因为项目比较复杂，所以我们决定让某个程序员负责绘制这些按钮，而另外一些程序员则负责编写点击按钮后的具体行为，这些行为都将被封装在对象里。</p><p>  在大型项目开发中，这是很正常的分工。对于绘制按钮的程序员来说，他完全不知道某个按钮未来将用来做什么，可能用来刷新菜单界面，也可能用来增加一些子菜单，他只知道点击这个 按钮会发生某些事情。那么当完成这个按钮的绘制之后，应该如何给它绑定<code>onclick</code> 事件呢?</p><p>  我们很快可以找到在这里运用命令模式的理由:点击了按钮之后，必须向某些负责具体行为的对象发送请求，这些对象就是请求的接收者。但是目前并不知道接收者是什么对象，也不知道接收者究竟会做什么。此时我们需要借助命令对象的帮助，以便解开按钮和负责具体行为对象之间的耦合。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> RefreshMenuBarCommand = <span class="function"><span class="keyword">function</span> (<span class="params">receiver</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        execute: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            receiver.refresh();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> setCommand = <span class="function"><span class="keyword">function</span> (<span class="params">button, command</span>) </span>&#123;</span><br><span class="line">    button.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> refreshMenuBarCommand = RefreshMenuBarCommand(MenuBar);</span><br><span class="line">setCommand(button1, refreshMenuBarCommand);</span><br></pre></td></tr></table></figure><h3 id="撤销和重做命令"><a href="#撤销和重做命令" class="headerlink" title="撤销和重做命令"></a>撤销和重做命令</h3><h4 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h4><p>  命令模式的作用不仅是封装运算块，而且可以很方便地给命令对象增加撤销操作。现在页面上有游戏需要对已经进行的操作进行<strong>回放</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Ryu = &#123;</span><br><span class="line">    <span class="function"><span class="title">attack</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;攻击&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">defense</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;防御&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">jump</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;跳跃&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">crouch</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;蹲下&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> makeCommand = <span class="function"><span class="keyword">function</span> (<span class="params">receiver, state</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> receiver[state];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> commands = &#123;</span><br><span class="line">    <span class="string">&quot;119&quot;</span>: <span class="string">&quot;jump&quot;</span>, <span class="comment">// w</span></span><br><span class="line">    <span class="string">&quot;115&quot;</span>: <span class="string">&quot;crouch&quot;</span>, <span class="comment">// s</span></span><br><span class="line">    <span class="string">&quot;97&quot;</span>: <span class="string">&quot;defense&quot;</span>, <span class="comment">// a</span></span><br><span class="line">    <span class="string">&quot;100&quot;</span>: <span class="string">&quot;attack&quot;</span>, <span class="comment">// d</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> commandStack = []; <span class="comment">// 保存命令的堆栈</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.onkeypress = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> keyCode = e.keyCode;</span><br><span class="line">    <span class="keyword">let</span> command = makeCommand(Ryu, commands[keyCode]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (command) &#123;</span><br><span class="line">        command();</span><br><span class="line">        commandStack.push(command);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;replay&quot;</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 点击播放录像</span></span><br><span class="line">    <span class="keyword">let</span> command;</span><br><span class="line">    <span class="keyword">while</span> (command = commandStack.shift()) &#123; <span class="comment">// 从堆栈获取此前的命令并执行</span></span><br><span class="line">        command();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>《javascript设计模式与开发实践》书上的这个例子写的更像是策略模式，书上为了和策略模式区分还把<code>receiver[state]()</code>用一个匿名函数给包起来，被我给删了，不要为了用设计模式而用设计模式。其实<strong>策略模式是对一系列算法的封装，使他们互相可替换</strong>，但<strong>命令模式是对一系列命令对象的封装，使接受者和发送者解耦</strong>。</p><h3 id="宏命令"><a href="#宏命令" class="headerlink" title="宏命令"></a>宏命令</h3><p>​    宏命令是一组命令的集合，通过执行宏命令的方式，可以一次执行一批命令。想象一下，家里有一个万能遥控器，每天回家的时候，只要按一个特别的按钮，它就会帮我们关上房间门，顺便打开电脑并登录 QQ。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> closeDoorCommand = &#123;</span><br><span class="line">  execute: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;关门&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> openPcCommand = &#123;</span><br><span class="line">  execute: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;开电脑&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> openQQCommand = &#123;</span><br><span class="line">  execute: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;登录 QQ&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> MacroCommand = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    commandsList: [],</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span> (<span class="params">command</span>) </span>&#123; <span class="comment">// 给宏命令添加指令</span></span><br><span class="line">      <span class="built_in">this</span>.commandsList.push(command);</span><br><span class="line">    &#125;,</span><br><span class="line">    execute: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 执行宏命令</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, command; command = <span class="built_in">this</span>.commandsList[i++];) &#123;</span><br><span class="line">        command.execute();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> macroCommand = MacroCommand();</span><br><span class="line"></span><br><span class="line">macroCommand.add(closeDoorCommand); </span><br><span class="line">macroCommand.add(openPcCommand);</span><br><span class="line">macroCommand.add(openQQCommand);</span><br><span class="line"></span><br><span class="line">macroCommand.execute();</span><br></pre></td></tr></table></figure><h3 id="智能命令与傻瓜命令"><a href="#智能命令与傻瓜命令" class="headerlink" title="智能命令与傻瓜命令"></a>智能命令与傻瓜命令</h3><p>​    上一个例子的命令没用包含任何<code>receiver</code>的信息，它本身就包揽了执行请求的行为，这跟我们之前看到的命令对象都包含了一个<code>receiver</code>是矛盾的。</p><p>​    一般来说，命令模式都会在command对象中保存一个接受者来负责真正执行客户的请求，这种情况下命令对象是“<strong>傻瓜式</strong>”的，它只负责把客户的请求转交给接受者来执行，这种模式的好处是请求的发起者和请求的接受者之间尽可能的解耦。</p><p>​    “聪明”的命令对象可以直接实现请求，这样一来就不需要接收者的存在，和策略模式非常接近，但命令模式解决的问题更具发散性。</p><p>​    命令模式还可以完成撤销、排队等功能</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《javascript设计模式与开发实践》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;命令模式&quot;&gt;&lt;a href=&quot;#命令模式&quot; class=&quot;headerlink&quot; title=&quot;命令模式&quot;&gt;&lt;/a&gt;命令模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://liang5757.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://liang5757.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
